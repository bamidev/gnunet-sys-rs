/* automatically generated by rust-bindgen 0.55.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _GNU_SOURCE: u32 = 1;
pub const DOCUMENTATION: u32 = 1;
pub const DOCUMENTATION_ONLY: u32 = 0;
pub const ENABLE_HEAP_STATISTICS: u32 = 0;
pub const ENABLE_MALICIOUS: u32 = 0;
pub const ENABLE_NLS: u32 = 1;
pub const ENABLE_NSE_HISTOGRAM: u32 = 0;
pub const ENABLE_POISONING: u32 = 0;
pub const ENABLE_SUPERMUC: u32 = 0;
pub const GNUNET_DEFAULT_INTERFACE: &'static [u8; 5usize] = b"eth0\0";
pub const GNUNET_LOGREAD: u32 = 0;
pub const HAVE_ABE: u32 = 0;
pub const HAVE_ARGZ_H: u32 = 1;
pub const HAVE_ARPA_INET_H: u32 = 1;
pub const HAVE_ATOLL: u32 = 1;
pub const HAVE_AWK: u32 = 1;
pub const HAVE_BYTESWAP_H: u32 = 1;
pub const HAVE_CHOWN: u32 = 1;
pub const HAVE_CTYPE_H: u32 = 1;
pub const HAVE_DCGETTEXT: u32 = 1;
pub const HAVE_DECL_CURLINFO_TLS_SESSION: u32 = 1;
pub const HAVE_DECL_GCRY_MPI_SET_OPAQUE_COPY: u32 = 1;
pub const HAVE_DECL_STRUCT_IN6_IFREQ: u32 = 0;
pub const HAVE_DIRENT_H: u32 = 1;
pub const HAVE_DLFCN_H: u32 = 1;
pub const HAVE_ENDIAN_H: u32 = 1;
pub const HAVE_ERRNO_H: u32 = 1;
pub const HAVE_EXECINFO_H: u32 = 1;
pub const HAVE_EXPLICIT_BZERO: u32 = 1;
pub const HAVE_EXTRACTOR_H: u32 = 1;
pub const HAVE_FCNTL_H: u32 = 1;
pub const HAVE_FORK: u32 = 1;
pub const HAVE_FREEIFADDRS: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_GETADDRINFO_A: u32 = 1;
pub const HAVE_GETHOSTBYNAME2: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETLOADAVG: u32 = 1;
pub const HAVE_GETRESGID: u32 = 1;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_GETRUSAGE: u32 = 1;
pub const HAVE_GETTEXT: u32 = 1;
pub const HAVE_GNUTLS_ABSTRACT_H: u32 = 1;
pub const HAVE_GNUTLS_DANE: u32 = 1;
pub const HAVE_GNUTLS_DANE_H: u32 = 1;
pub const HAVE_ICONV: u32 = 1;
pub const HAVE_IDN2_H: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_INITGROUPS: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LIBATOMIC: u32 = 1;
pub const HAVE_LIBBLUETOOTH: u32 = 1;
pub const HAVE_LIBCURL: u32 = 1;
pub const HAVE_LIBEXTRACTOR: u32 = 1;
pub const HAVE_LIBGNURL: u32 = 0;
pub const HAVE_LIBIDN2: u32 = 1;
pub const HAVE_LIBINTL_H: u32 = 1;
pub const HAVE_LIBM: u32 = 1;
pub const HAVE_LIBPQ_FE_H: u32 = 1;
pub const HAVE_LIBUNISTRING: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_LOCALE_H: u32 = 1;
pub const HAVE_LTDL_H: u32 = 1;
pub const HAVE_MALLINFO: u32 = 1;
pub const HAVE_MALLOC_H: u32 = 1;
pub const HAVE_MALLOC_USABLE_SIZE: u32 = 1;
pub const HAVE_MATH_H: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_MEMRCHR: u32 = 1;
pub const HAVE_MHD: u32 = 1;
pub const HAVE_MREMAP: u32 = 1;
pub const HAVE_NETDB_H: u32 = 1;
pub const HAVE_NETINET_IN_H: u32 = 1;
pub const HAVE_NETINET_IN_SYSTM_H: u32 = 1;
pub const HAVE_NETINET_IP_H: u32 = 1;
pub const HAVE_NSS_H: u32 = 1;
pub const HAVE_OFF_T: u32 = 1;
pub const HAVE_OPUS: u32 = 0;
pub const HAVE_PBC: u32 = 0;
pub const HAVE_PERL: u32 = 1;
pub const HAVE_POSTGRESQL: u32 = 1;
pub const HAVE_PULSE: u32 = 1;
pub const HAVE_RANDOM: u32 = 1;
pub const HAVE_SETRESUID: u32 = 1;
pub const HAVE_SETRLIMIT: u32 = 1;
pub const HAVE_SIGNAL_H: u32 = 1;
pub const HAVE_SIGSET_T: u32 = 1;
pub const HAVE_SIZE_T: u32 = 1;
pub const HAVE_SQLITE3_H: u32 = 1;
pub const HAVE_SRANDOM: u32 = 1;
pub const HAVE_STAT: u32 = 1;
pub const HAVE_STAT64: u32 = 1;
pub const HAVE_STATFS: u32 = 1;
pub const HAVE_STATIC_ASSERT: u32 = 1;
pub const HAVE_STATVFS: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_STDATOMIC_H: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDDEF_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRFTIME: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRNDUP: u32 = 1;
pub const HAVE_STRNLEN: u32 = 1;
pub const HAVE_SYSCONF: u32 = 1;
pub const HAVE_SYS_FILE_H: u32 = 1;
pub const HAVE_SYS_IOCTL_H: u32 = 1;
pub const HAVE_SYS_MMAN_H: u32 = 1;
pub const HAVE_SYS_MOUNT_H: u32 = 1;
pub const HAVE_SYS_MSG_H: u32 = 1;
pub const HAVE_SYS_PARAM_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_STATVFS_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_SYSINFO_H: u32 = 1;
pub const HAVE_SYS_TIMEB_H: u32 = 1;
pub const HAVE_SYS_TIME_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_VFS_H: u32 = 1;
pub const HAVE_SYS_WAIT_H: u32 = 1;
pub const HAVE_THREAD_LOCAL_GCC: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_TM_GMTOFF: u32 = 1;
pub const HAVE_UNALIGNED_64_ACCESS: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_UNISTR_H: u32 = 1;
pub const HAVE_VFORK: u32 = 1;
pub const HAVE_VPRINTF: u32 = 1;
pub const HAVE_WAIT4: u32 = 1;
pub const HAVE_WORKING_FORK: u32 = 1;
pub const HAVE_WORKING_VFORK: u32 = 1;
pub const HAVE_ZBAR: u32 = 0;
pub const HAVE__BOOL: u32 = 1;
pub const IFCONFIG: &'static [u8; 15usize] = b"/sbin/ifconfig\0";
pub const IF_TUN_HDR: &'static [u8; 15usize] = b"linux/if_tun.h\0";
pub const INCLUDE_MANPAGES: u32 = 0;
pub const IP6TABLES: &'static [u8; 16usize] = b"/sbin/ip6tables\0";
pub const IPTABLES: &'static [u8; 15usize] = b"/sbin/iptables\0";
pub const LIBCURL_FEATURE_ASYNCHDNS: u32 = 1;
pub const LIBCURL_FEATURE_IDN: u32 = 1;
pub const LIBCURL_FEATURE_IPV6: u32 = 1;
pub const LIBCURL_FEATURE_LIBZ: u32 = 1;
pub const LIBCURL_FEATURE_NTLM: u32 = 1;
pub const LIBCURL_FEATURE_SSL: u32 = 1;
pub const LIBCURL_PROTOCOL_DICT: u32 = 1;
pub const LIBCURL_PROTOCOL_FILE: u32 = 1;
pub const LIBCURL_PROTOCOL_FTP: u32 = 1;
pub const LIBCURL_PROTOCOL_FTPS: u32 = 1;
pub const LIBCURL_PROTOCOL_HTTP: u32 = 1;
pub const LIBCURL_PROTOCOL_HTTPS: u32 = 1;
pub const LIBCURL_PROTOCOL_IMAP: u32 = 1;
pub const LIBCURL_PROTOCOL_LDAP: u32 = 1;
pub const LIBCURL_PROTOCOL_POP3: u32 = 1;
pub const LIBCURL_PROTOCOL_RTSP: u32 = 1;
pub const LIBCURL_PROTOCOL_SMTP: u32 = 1;
pub const LIBCURL_PROTOCOL_TELNET: u32 = 1;
pub const LIBCURL_PROTOCOL_TFTP: u32 = 1;
pub const LINUX: u32 = 1;
pub const LSTAT_FOLLOWS_SLASHED_SYMLINK: u32 = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\0";
pub const NEED_LIBGCRYPT_VERSION: &'static [u8; 6usize] = b"1.6.0\0";
pub const PACKAGE: &'static [u8; 7usize] = b"gnunet\0";
pub const PACKAGE_BUGREPORT: &'static [u8; 19usize] = b"bug-gnunet@gnu.org\0";
pub const PACKAGE_NAME: &'static [u8; 7usize] = b"gnunet\0";
pub const PACKAGE_STRING: &'static [u8; 14usize] = b"gnunet 0.14.0\0";
pub const PACKAGE_TARNAME: &'static [u8; 7usize] = b"gnunet\0";
pub const PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_VERSION: &'static [u8; 7usize] = b"0.14.0\0";
pub const PATH_TO_IP: &'static [u8; 12usize] = b"/usr/bin/ip\0";
pub const STDC_HEADERS: u32 = 1;
pub const SYSCTL: &'static [u8; 13usize] = b"/sbin/sysctl\0";
pub const TEXI2MDOC_GENERATION: u32 = 0;
pub const TIME_WITH_SYS_TIME: u32 = 1;
pub const VCS_VERSION: &'static [u8; 14usize] = b"git-b0dcf66a2\0";
pub const VERSION: &'static [u8; 7usize] = b"0.14.0\0";
pub const _DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const HAVE_GNUTLS: u32 = 1;
pub const GNUNET_CONSTANTS_IDLE_LOAD_THRESHOLD: u32 = 70;
pub const GNUNET_CONSTANTS_MAX_BANDWIDTH_CARRY_S: u32 = 5;
pub const GNUNET_CONSTANTS_MAX_ENCRYPTED_MESSAGE_SIZE: u32 = 64512;
pub const GNUNET_CONSTANTS_CADET_P2P_OVERHEAD: u32 = 164;
pub const GNUNET_CONSTANTS_MAX_CADET_MESSAGE_SIZE: u32 = 64348;
pub const GNUNET_CONSTANTS_MAX_BLOCK_SIZE: u32 = 63488;
pub const GNUNET_CONSTANTS_BLOOMFILTER_K: u32 = 16;
pub const GNUNET_MAX_MESSAGE_SIZE: u32 = 65536;
pub const GNUNET_AGPL_URL: &'static [u8; 41usize] = b"https://gnunet.org/git/gnunet.git#0.14.0\0";
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const INT8_WIDTH: u32 = 8;
pub const UINT8_WIDTH: u32 = 8;
pub const INT16_WIDTH: u32 = 16;
pub const UINT16_WIDTH: u32 = 16;
pub const INT32_WIDTH: u32 = 32;
pub const UINT32_WIDTH: u32 = 32;
pub const INT64_WIDTH: u32 = 64;
pub const UINT64_WIDTH: u32 = 64;
pub const INT_LEAST8_WIDTH: u32 = 8;
pub const UINT_LEAST8_WIDTH: u32 = 8;
pub const INT_LEAST16_WIDTH: u32 = 16;
pub const UINT_LEAST16_WIDTH: u32 = 16;
pub const INT_LEAST32_WIDTH: u32 = 32;
pub const UINT_LEAST32_WIDTH: u32 = 32;
pub const INT_LEAST64_WIDTH: u32 = 64;
pub const UINT_LEAST64_WIDTH: u32 = 64;
pub const INT_FAST8_WIDTH: u32 = 8;
pub const UINT_FAST8_WIDTH: u32 = 8;
pub const INT_FAST16_WIDTH: u32 = 64;
pub const UINT_FAST16_WIDTH: u32 = 64;
pub const INT_FAST32_WIDTH: u32 = 64;
pub const UINT_FAST32_WIDTH: u32 = 64;
pub const INT_FAST64_WIDTH: u32 = 64;
pub const UINT_FAST64_WIDTH: u32 = 64;
pub const INTPTR_WIDTH: u32 = 64;
pub const UINTPTR_WIDTH: u32 = 64;
pub const INTMAX_WIDTH: u32 = 64;
pub const UINTMAX_WIDTH: u32 = 64;
pub const PTRDIFF_WIDTH: u32 = 64;
pub const SIG_ATOMIC_WIDTH: u32 = 32;
pub const SIZE_WIDTH: u32 = 64;
pub const WCHAR_WIDTH: u32 = 32;
pub const WINT_WIDTH: u32 = 32;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const CHAR_WIDTH: u32 = 8;
pub const SCHAR_WIDTH: u32 = 8;
pub const UCHAR_WIDTH: u32 = 8;
pub const SHRT_WIDTH: u32 = 16;
pub const USHRT_WIDTH: u32 = 16;
pub const INT_WIDTH: u32 = 32;
pub const UINT_WIDTH: u32 = 32;
pub const LONG_WIDTH: u32 = 64;
pub const ULONG_WIDTH: u32 = 64;
pub const LLONG_WIDTH: u32 = 64;
pub const ULLONG_WIDTH: u32 = 64;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const SODIUM_VERSION_STRING: &'static [u8; 7usize] = b"1.0.18\0";
pub const SODIUM_LIBRARY_VERSION_MAJOR: u32 = 10;
pub const SODIUM_LIBRARY_VERSION_MINOR: u32 = 3;
pub const crypto_aead_aes256gcm_KEYBYTES: u32 = 32;
pub const crypto_aead_aes256gcm_NSECBYTES: u32 = 0;
pub const crypto_aead_aes256gcm_NPUBBYTES: u32 = 12;
pub const crypto_aead_aes256gcm_ABYTES: u32 = 16;
pub const crypto_aead_chacha20poly1305_ietf_KEYBYTES: u32 = 32;
pub const crypto_aead_chacha20poly1305_ietf_NSECBYTES: u32 = 0;
pub const crypto_aead_chacha20poly1305_ietf_NPUBBYTES: u32 = 12;
pub const crypto_aead_chacha20poly1305_ietf_ABYTES: u32 = 16;
pub const crypto_aead_chacha20poly1305_KEYBYTES: u32 = 32;
pub const crypto_aead_chacha20poly1305_NSECBYTES: u32 = 0;
pub const crypto_aead_chacha20poly1305_NPUBBYTES: u32 = 8;
pub const crypto_aead_chacha20poly1305_ABYTES: u32 = 16;
pub const crypto_aead_chacha20poly1305_IETF_KEYBYTES: u32 = 32;
pub const crypto_aead_chacha20poly1305_IETF_NSECBYTES: u32 = 0;
pub const crypto_aead_chacha20poly1305_IETF_NPUBBYTES: u32 = 12;
pub const crypto_aead_chacha20poly1305_IETF_ABYTES: u32 = 16;
pub const crypto_aead_xchacha20poly1305_ietf_KEYBYTES: u32 = 32;
pub const crypto_aead_xchacha20poly1305_ietf_NSECBYTES: u32 = 0;
pub const crypto_aead_xchacha20poly1305_ietf_NPUBBYTES: u32 = 24;
pub const crypto_aead_xchacha20poly1305_ietf_ABYTES: u32 = 16;
pub const crypto_aead_xchacha20poly1305_IETF_KEYBYTES: u32 = 32;
pub const crypto_aead_xchacha20poly1305_IETF_NSECBYTES: u32 = 0;
pub const crypto_aead_xchacha20poly1305_IETF_NPUBBYTES: u32 = 24;
pub const crypto_aead_xchacha20poly1305_IETF_ABYTES: u32 = 16;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const crypto_hash_sha512_BYTES: u32 = 64;
pub const crypto_auth_hmacsha512_BYTES: u32 = 64;
pub const crypto_auth_hmacsha512_KEYBYTES: u32 = 32;
pub const crypto_auth_hmacsha512256_BYTES: u32 = 32;
pub const crypto_auth_hmacsha512256_KEYBYTES: u32 = 32;
pub const crypto_auth_BYTES: u32 = 32;
pub const crypto_auth_KEYBYTES: u32 = 32;
pub const crypto_auth_PRIMITIVE: &'static [u8; 14usize] = b"hmacsha512256\0";
pub const crypto_hash_sha256_BYTES: u32 = 32;
pub const crypto_auth_hmacsha256_BYTES: u32 = 32;
pub const crypto_auth_hmacsha256_KEYBYTES: u32 = 32;
pub const crypto_stream_xsalsa20_KEYBYTES: u32 = 32;
pub const crypto_stream_xsalsa20_NONCEBYTES: u32 = 24;
pub const crypto_box_curve25519xsalsa20poly1305_SEEDBYTES: u32 = 32;
pub const crypto_box_curve25519xsalsa20poly1305_PUBLICKEYBYTES: u32 = 32;
pub const crypto_box_curve25519xsalsa20poly1305_SECRETKEYBYTES: u32 = 32;
pub const crypto_box_curve25519xsalsa20poly1305_BEFORENMBYTES: u32 = 32;
pub const crypto_box_curve25519xsalsa20poly1305_NONCEBYTES: u32 = 24;
pub const crypto_box_curve25519xsalsa20poly1305_MACBYTES: u32 = 16;
pub const crypto_box_curve25519xsalsa20poly1305_BOXZEROBYTES: u32 = 16;
pub const crypto_box_curve25519xsalsa20poly1305_ZEROBYTES: u32 = 32;
pub const crypto_box_SEEDBYTES: u32 = 32;
pub const crypto_box_PUBLICKEYBYTES: u32 = 32;
pub const crypto_box_SECRETKEYBYTES: u32 = 32;
pub const crypto_box_NONCEBYTES: u32 = 24;
pub const crypto_box_MACBYTES: u32 = 16;
pub const crypto_box_PRIMITIVE: &'static [u8; 27usize] = b"curve25519xsalsa20poly1305\0";
pub const crypto_box_BEFORENMBYTES: u32 = 32;
pub const crypto_box_SEALBYTES: u32 = 48;
pub const crypto_box_ZEROBYTES: u32 = 32;
pub const crypto_box_BOXZEROBYTES: u32 = 16;
pub const crypto_core_hsalsa20_OUTPUTBYTES: u32 = 32;
pub const crypto_core_hsalsa20_INPUTBYTES: u32 = 16;
pub const crypto_core_hsalsa20_KEYBYTES: u32 = 32;
pub const crypto_core_hsalsa20_CONSTBYTES: u32 = 16;
pub const crypto_core_hchacha20_OUTPUTBYTES: u32 = 32;
pub const crypto_core_hchacha20_INPUTBYTES: u32 = 16;
pub const crypto_core_hchacha20_KEYBYTES: u32 = 32;
pub const crypto_core_hchacha20_CONSTBYTES: u32 = 16;
pub const crypto_core_salsa20_OUTPUTBYTES: u32 = 64;
pub const crypto_core_salsa20_INPUTBYTES: u32 = 16;
pub const crypto_core_salsa20_KEYBYTES: u32 = 32;
pub const crypto_core_salsa20_CONSTBYTES: u32 = 16;
pub const crypto_core_salsa2012_OUTPUTBYTES: u32 = 64;
pub const crypto_core_salsa2012_INPUTBYTES: u32 = 16;
pub const crypto_core_salsa2012_KEYBYTES: u32 = 32;
pub const crypto_core_salsa2012_CONSTBYTES: u32 = 16;
pub const crypto_core_salsa208_OUTPUTBYTES: u32 = 64;
pub const crypto_core_salsa208_INPUTBYTES: u32 = 16;
pub const crypto_core_salsa208_KEYBYTES: u32 = 32;
pub const crypto_core_salsa208_CONSTBYTES: u32 = 16;
pub const crypto_generichash_blake2b_BYTES_MIN: u32 = 16;
pub const crypto_generichash_blake2b_BYTES_MAX: u32 = 64;
pub const crypto_generichash_blake2b_BYTES: u32 = 32;
pub const crypto_generichash_blake2b_KEYBYTES_MIN: u32 = 16;
pub const crypto_generichash_blake2b_KEYBYTES_MAX: u32 = 64;
pub const crypto_generichash_blake2b_KEYBYTES: u32 = 32;
pub const crypto_generichash_blake2b_SALTBYTES: u32 = 16;
pub const crypto_generichash_blake2b_PERSONALBYTES: u32 = 16;
pub const crypto_generichash_BYTES_MIN: u32 = 16;
pub const crypto_generichash_BYTES_MAX: u32 = 64;
pub const crypto_generichash_BYTES: u32 = 32;
pub const crypto_generichash_KEYBYTES_MIN: u32 = 16;
pub const crypto_generichash_KEYBYTES_MAX: u32 = 64;
pub const crypto_generichash_KEYBYTES: u32 = 32;
pub const crypto_generichash_PRIMITIVE: &'static [u8; 8usize] = b"blake2b\0";
pub const crypto_hash_BYTES: u32 = 64;
pub const crypto_hash_PRIMITIVE: &'static [u8; 7usize] = b"sha512\0";
pub const crypto_kdf_blake2b_BYTES_MIN: u32 = 16;
pub const crypto_kdf_blake2b_BYTES_MAX: u32 = 64;
pub const crypto_kdf_blake2b_CONTEXTBYTES: u32 = 8;
pub const crypto_kdf_blake2b_KEYBYTES: u32 = 32;
pub const crypto_kdf_BYTES_MIN: u32 = 16;
pub const crypto_kdf_BYTES_MAX: u32 = 64;
pub const crypto_kdf_CONTEXTBYTES: u32 = 8;
pub const crypto_kdf_KEYBYTES: u32 = 32;
pub const crypto_kdf_PRIMITIVE: &'static [u8; 8usize] = b"blake2b\0";
pub const crypto_kx_PUBLICKEYBYTES: u32 = 32;
pub const crypto_kx_SECRETKEYBYTES: u32 = 32;
pub const crypto_kx_SEEDBYTES: u32 = 32;
pub const crypto_kx_SESSIONKEYBYTES: u32 = 32;
pub const crypto_kx_PRIMITIVE: &'static [u8; 14usize] = b"x25519blake2b\0";
pub const crypto_onetimeauth_poly1305_BYTES: u32 = 16;
pub const crypto_onetimeauth_poly1305_KEYBYTES: u32 = 32;
pub const crypto_onetimeauth_BYTES: u32 = 16;
pub const crypto_onetimeauth_KEYBYTES: u32 = 32;
pub const crypto_onetimeauth_PRIMITIVE: &'static [u8; 9usize] = b"poly1305\0";
pub const crypto_pwhash_argon2i_ALG_ARGON2I13: u32 = 1;
pub const crypto_pwhash_argon2i_BYTES_MIN: u32 = 16;
pub const crypto_pwhash_argon2i_PASSWD_MIN: u32 = 0;
pub const crypto_pwhash_argon2i_PASSWD_MAX: u32 = 4294967295;
pub const crypto_pwhash_argon2i_SALTBYTES: u32 = 16;
pub const crypto_pwhash_argon2i_STRBYTES: u32 = 128;
pub const crypto_pwhash_argon2i_STRPREFIX: &'static [u8; 10usize] = b"$argon2i$\0";
pub const crypto_pwhash_argon2i_OPSLIMIT_MIN: u32 = 3;
pub const crypto_pwhash_argon2i_OPSLIMIT_MAX: u32 = 4294967295;
pub const crypto_pwhash_argon2i_MEMLIMIT_MIN: u32 = 8192;
pub const crypto_pwhash_argon2i_OPSLIMIT_INTERACTIVE: u32 = 4;
pub const crypto_pwhash_argon2i_MEMLIMIT_INTERACTIVE: u32 = 33554432;
pub const crypto_pwhash_argon2i_OPSLIMIT_MODERATE: u32 = 6;
pub const crypto_pwhash_argon2i_MEMLIMIT_MODERATE: u32 = 134217728;
pub const crypto_pwhash_argon2i_OPSLIMIT_SENSITIVE: u32 = 8;
pub const crypto_pwhash_argon2i_MEMLIMIT_SENSITIVE: u32 = 536870912;
pub const crypto_pwhash_argon2id_ALG_ARGON2ID13: u32 = 2;
pub const crypto_pwhash_argon2id_BYTES_MIN: u32 = 16;
pub const crypto_pwhash_argon2id_PASSWD_MIN: u32 = 0;
pub const crypto_pwhash_argon2id_PASSWD_MAX: u32 = 4294967295;
pub const crypto_pwhash_argon2id_SALTBYTES: u32 = 16;
pub const crypto_pwhash_argon2id_STRBYTES: u32 = 128;
pub const crypto_pwhash_argon2id_STRPREFIX: &'static [u8; 11usize] = b"$argon2id$\0";
pub const crypto_pwhash_argon2id_OPSLIMIT_MIN: u32 = 1;
pub const crypto_pwhash_argon2id_OPSLIMIT_MAX: u32 = 4294967295;
pub const crypto_pwhash_argon2id_MEMLIMIT_MIN: u32 = 8192;
pub const crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE: u32 = 2;
pub const crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE: u32 = 67108864;
pub const crypto_pwhash_argon2id_OPSLIMIT_MODERATE: u32 = 3;
pub const crypto_pwhash_argon2id_MEMLIMIT_MODERATE: u32 = 268435456;
pub const crypto_pwhash_argon2id_OPSLIMIT_SENSITIVE: u32 = 4;
pub const crypto_pwhash_argon2id_MEMLIMIT_SENSITIVE: u32 = 1073741824;
pub const crypto_pwhash_ALG_ARGON2I13: u32 = 1;
pub const crypto_pwhash_ALG_ARGON2ID13: u32 = 2;
pub const crypto_pwhash_ALG_DEFAULT: u32 = 2;
pub const crypto_pwhash_BYTES_MIN: u32 = 16;
pub const crypto_pwhash_PASSWD_MIN: u32 = 0;
pub const crypto_pwhash_PASSWD_MAX: u32 = 4294967295;
pub const crypto_pwhash_SALTBYTES: u32 = 16;
pub const crypto_pwhash_STRBYTES: u32 = 128;
pub const crypto_pwhash_STRPREFIX: &'static [u8; 11usize] = b"$argon2id$\0";
pub const crypto_pwhash_OPSLIMIT_MIN: u32 = 1;
pub const crypto_pwhash_OPSLIMIT_MAX: u32 = 4294967295;
pub const crypto_pwhash_MEMLIMIT_MIN: u32 = 8192;
pub const crypto_pwhash_OPSLIMIT_INTERACTIVE: u32 = 2;
pub const crypto_pwhash_MEMLIMIT_INTERACTIVE: u32 = 67108864;
pub const crypto_pwhash_OPSLIMIT_MODERATE: u32 = 3;
pub const crypto_pwhash_MEMLIMIT_MODERATE: u32 = 268435456;
pub const crypto_pwhash_OPSLIMIT_SENSITIVE: u32 = 4;
pub const crypto_pwhash_MEMLIMIT_SENSITIVE: u32 = 1073741824;
pub const crypto_pwhash_PRIMITIVE: &'static [u8; 8usize] = b"argon2i\0";
pub const crypto_scalarmult_curve25519_BYTES: u32 = 32;
pub const crypto_scalarmult_curve25519_SCALARBYTES: u32 = 32;
pub const crypto_scalarmult_BYTES: u32 = 32;
pub const crypto_scalarmult_SCALARBYTES: u32 = 32;
pub const crypto_scalarmult_PRIMITIVE: &'static [u8; 11usize] = b"curve25519\0";
pub const crypto_secretbox_xsalsa20poly1305_KEYBYTES: u32 = 32;
pub const crypto_secretbox_xsalsa20poly1305_NONCEBYTES: u32 = 24;
pub const crypto_secretbox_xsalsa20poly1305_MACBYTES: u32 = 16;
pub const crypto_secretbox_xsalsa20poly1305_BOXZEROBYTES: u32 = 16;
pub const crypto_secretbox_xsalsa20poly1305_ZEROBYTES: u32 = 32;
pub const crypto_secretbox_KEYBYTES: u32 = 32;
pub const crypto_secretbox_NONCEBYTES: u32 = 24;
pub const crypto_secretbox_MACBYTES: u32 = 16;
pub const crypto_secretbox_PRIMITIVE: &'static [u8; 17usize] = b"xsalsa20poly1305\0";
pub const crypto_secretbox_ZEROBYTES: u32 = 32;
pub const crypto_secretbox_BOXZEROBYTES: u32 = 16;
pub const crypto_stream_chacha20_KEYBYTES: u32 = 32;
pub const crypto_stream_chacha20_NONCEBYTES: u32 = 8;
pub const crypto_stream_chacha20_ietf_KEYBYTES: u32 = 32;
pub const crypto_stream_chacha20_ietf_NONCEBYTES: u32 = 12;
pub const crypto_stream_chacha20_IETF_KEYBYTES: u32 = 32;
pub const crypto_stream_chacha20_IETF_NONCEBYTES: u32 = 12;
pub const crypto_secretstream_xchacha20poly1305_ABYTES: u32 = 17;
pub const crypto_secretstream_xchacha20poly1305_HEADERBYTES: u32 = 24;
pub const crypto_secretstream_xchacha20poly1305_KEYBYTES: u32 = 32;
pub const crypto_secretstream_xchacha20poly1305_TAG_MESSAGE: u32 = 0;
pub const crypto_secretstream_xchacha20poly1305_TAG_PUSH: u32 = 1;
pub const crypto_secretstream_xchacha20poly1305_TAG_REKEY: u32 = 2;
pub const crypto_secretstream_xchacha20poly1305_TAG_FINAL: u32 = 3;
pub const crypto_shorthash_siphash24_BYTES: u32 = 8;
pub const crypto_shorthash_siphash24_KEYBYTES: u32 = 16;
pub const crypto_shorthash_siphashx24_BYTES: u32 = 16;
pub const crypto_shorthash_siphashx24_KEYBYTES: u32 = 16;
pub const crypto_shorthash_BYTES: u32 = 8;
pub const crypto_shorthash_KEYBYTES: u32 = 16;
pub const crypto_shorthash_PRIMITIVE: &'static [u8; 10usize] = b"siphash24\0";
pub const crypto_sign_ed25519_BYTES: u32 = 64;
pub const crypto_sign_ed25519_SEEDBYTES: u32 = 32;
pub const crypto_sign_ed25519_PUBLICKEYBYTES: u32 = 32;
pub const crypto_sign_ed25519_SECRETKEYBYTES: u32 = 64;
pub const crypto_sign_BYTES: u32 = 64;
pub const crypto_sign_SEEDBYTES: u32 = 32;
pub const crypto_sign_PUBLICKEYBYTES: u32 = 32;
pub const crypto_sign_SECRETKEYBYTES: u32 = 64;
pub const crypto_sign_PRIMITIVE: &'static [u8; 8usize] = b"ed25519\0";
pub const crypto_stream_KEYBYTES: u32 = 32;
pub const crypto_stream_NONCEBYTES: u32 = 24;
pub const crypto_stream_PRIMITIVE: &'static [u8; 9usize] = b"xsalsa20\0";
pub const crypto_stream_salsa20_KEYBYTES: u32 = 32;
pub const crypto_stream_salsa20_NONCEBYTES: u32 = 8;
pub const crypto_verify_16_BYTES: u32 = 16;
pub const crypto_verify_32_BYTES: u32 = 32;
pub const crypto_verify_64_BYTES: u32 = 64;
pub const randombytes_SEEDBYTES: u32 = 32;
pub const sodium_base64_VARIANT_ORIGINAL: u32 = 1;
pub const sodium_base64_VARIANT_ORIGINAL_NO_PADDING: u32 = 3;
pub const sodium_base64_VARIANT_URLSAFE: u32 = 5;
pub const sodium_base64_VARIANT_URLSAFE_NO_PADDING: u32 = 7;
pub const crypto_stream_xchacha20_KEYBYTES: u32 = 32;
pub const crypto_stream_xchacha20_NONCEBYTES: u32 = 24;
pub const crypto_box_curve25519xchacha20poly1305_SEEDBYTES: u32 = 32;
pub const crypto_box_curve25519xchacha20poly1305_PUBLICKEYBYTES: u32 = 32;
pub const crypto_box_curve25519xchacha20poly1305_SECRETKEYBYTES: u32 = 32;
pub const crypto_box_curve25519xchacha20poly1305_BEFORENMBYTES: u32 = 32;
pub const crypto_box_curve25519xchacha20poly1305_NONCEBYTES: u32 = 24;
pub const crypto_box_curve25519xchacha20poly1305_MACBYTES: u32 = 16;
pub const crypto_box_curve25519xchacha20poly1305_SEALBYTES: u32 = 48;
pub const crypto_core_ed25519_BYTES: u32 = 32;
pub const crypto_core_ed25519_UNIFORMBYTES: u32 = 32;
pub const crypto_core_ed25519_HASHBYTES: u32 = 64;
pub const crypto_core_ed25519_SCALARBYTES: u32 = 32;
pub const crypto_core_ed25519_NONREDUCEDSCALARBYTES: u32 = 64;
pub const crypto_core_ristretto255_BYTES: u32 = 32;
pub const crypto_core_ristretto255_HASHBYTES: u32 = 64;
pub const crypto_core_ristretto255_SCALARBYTES: u32 = 32;
pub const crypto_core_ristretto255_NONREDUCEDSCALARBYTES: u32 = 64;
pub const crypto_scalarmult_ed25519_BYTES: u32 = 32;
pub const crypto_scalarmult_ed25519_SCALARBYTES: u32 = 32;
pub const crypto_scalarmult_ristretto255_BYTES: u32 = 32;
pub const crypto_scalarmult_ristretto255_SCALARBYTES: u32 = 32;
pub const crypto_secretbox_xchacha20poly1305_KEYBYTES: u32 = 32;
pub const crypto_secretbox_xchacha20poly1305_NONCEBYTES: u32 = 24;
pub const crypto_secretbox_xchacha20poly1305_MACBYTES: u32 = 16;
pub const crypto_pwhash_scryptsalsa208sha256_BYTES_MIN: u32 = 16;
pub const crypto_pwhash_scryptsalsa208sha256_PASSWD_MIN: u32 = 0;
pub const crypto_pwhash_scryptsalsa208sha256_SALTBYTES: u32 = 32;
pub const crypto_pwhash_scryptsalsa208sha256_STRBYTES: u32 = 102;
pub const crypto_pwhash_scryptsalsa208sha256_STRPREFIX: &'static [u8; 4usize] = b"$7$\0";
pub const crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MIN: u32 = 32768;
pub const crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_MAX: u32 = 4294967295;
pub const crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_MIN: u32 = 16777216;
pub const crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE: u32 = 524288;
pub const crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE: u32 = 16777216;
pub const crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE: u32 = 33554432;
pub const crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_SENSITIVE: u32 = 1073741824;
pub const crypto_stream_salsa2012_KEYBYTES: u32 = 32;
pub const crypto_stream_salsa2012_NONCEBYTES: u32 = 8;
pub const crypto_stream_salsa208_KEYBYTES: u32 = 32;
pub const crypto_stream_salsa208_NONCEBYTES: u32 = 8;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MAX: u32 = 45;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MAX: u32 = 45;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const __BITS_PER_LONG: u32 = 64;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _BYTESWAP_H: u32 = 1;
pub const GNUNET_UTIL_VERSION: u32 = 655620;
pub const GNUNET_LOG_CALL_STATUS: i32 = -1;
pub const GNUNET_MAX_MALLOC_CHECKED: u32 = 41943040;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const GPG_ERROR_H: u32 = 1;
pub const GPGRT_H: u32 = 1;
pub const GPG_ERROR_VERSION: &'static [u8; 5usize] = b"1.38\0";
pub const GPGRT_VERSION: &'static [u8; 5usize] = b"1.38\0";
pub const GPG_ERROR_VERSION_NUMBER: u32 = 75264;
pub const GPGRT_VERSION_NUMBER: u32 = 75264;
pub const GPG_ERR_SYSTEM_ERROR: u32 = 32768;
pub const GPG_ERR_SOURCE_SHIFT: u32 = 24;
pub const GPGRT_HAVE_MACRO_FUNCTION: u32 = 1;
pub const GPG_ERR_INITIALIZED: u32 = 1;
pub const GPGRT_LOG_WITH_PREFIX: u32 = 1;
pub const GPGRT_LOG_WITH_TIME: u32 = 2;
pub const GPGRT_LOG_WITH_PID: u32 = 4;
pub const GPGRT_LOG_RUN_DETACHED: u32 = 256;
pub const GPGRT_LOG_NO_REGISTRY: u32 = 512;
pub const GPGRT_SPAWN_NONBLOCK: u32 = 16;
pub const GPGRT_SPAWN_RUN_ASFW: u32 = 64;
pub const GPGRT_SPAWN_DETACHED: u32 = 128;
pub const GPGRT_CONFDIR_USER: u32 = 1;
pub const GPGRT_CONFDIR_SYS: u32 = 2;
pub const _SYS_TIME_H: u32 = 1;
pub const GCRYPT_VERSION: &'static [u8; 6usize] = b"1.8.8\0";
pub const GCRYPT_VERSION_NUMBER: u32 = 67592;
pub const GCRY_THREAD_OPTION_DEFAULT: u32 = 0;
pub const GCRY_THREAD_OPTION_USER: u32 = 1;
pub const GCRY_THREAD_OPTION_PTH: u32 = 2;
pub const GCRY_THREAD_OPTION_PTHREAD: u32 = 3;
pub const GCRY_THREAD_OPTION_VERSION: u32 = 1;
pub const GCRY_GCM_BLOCK_LEN: u32 = 16;
pub const GCRY_CCM_BLOCK_LEN: u32 = 16;
pub const GCRY_OCB_BLOCK_LEN: u32 = 16;
pub const GCRY_XTS_BLOCK_LEN: u32 = 16;
pub const GCRY_PK_USAGE_SIGN: u32 = 1;
pub const GCRY_PK_USAGE_ENCR: u32 = 2;
pub const GCRY_PK_USAGE_CERT: u32 = 4;
pub const GCRY_PK_USAGE_AUTH: u32 = 8;
pub const GCRY_PK_USAGE_UNKN: u32 = 128;
pub const GCRY_PK_GET_PUBKEY: u32 = 1;
pub const GCRY_PK_GET_SECKEY: u32 = 2;
pub const GCRY_PRIME_CHECK_AT_FINISH: u32 = 0;
pub const GCRY_PRIME_CHECK_AT_GOT_PRIME: u32 = 1;
pub const GCRY_PRIME_CHECK_AT_MAYBE_PRIME: u32 = 2;
pub const GCRY_PRIME_FLAG_SECRET: u32 = 1;
pub const GCRY_PRIME_FLAG_SPECIAL_FACTOR: u32 = 2;
pub const GNUNET_CRYPTO_ECC_SIGNATURE_DATA_ENCODING_LENGTH: u32 = 126;
pub const GNUNET_CRYPTO_AES_KEY_LENGTH: u32 = 32;
pub const GNUNET_CRYPTO_HASH_LENGTH: u32 = 64;
pub const GNUNET_CRYPTO_PKEY_ASCII_LENGTH: u32 = 52;
pub const GNUNET_CRYPTO_PAILLIER_BITS: u32 = 2048;
pub const EXTRACTOR_VERSION: u32 = 17498112;
pub const EXTRACTOR_METATYPE_GNUNET_ORIGINAL_FILENAME: u32 = 180;
pub const GNUNET_MQ_PREFERENCE_COUNT: u32 = 4;
pub const GNUNET_MESSAGE_TYPE_TEST: u32 = 0;
pub const GNUNET_MESSAGE_TYPE_REQUEST_AGPL: u32 = 1;
pub const GNUNET_MESSAGE_TYPE_RESPONSE_AGPL: u32 = 2;
pub const GNUNET_MESSAGE_TYPE_RESOLVER_REQUEST: u32 = 4;
pub const GNUNET_MESSAGE_TYPE_RESOLVER_RESPONSE: u32 = 5;
pub const GNUNET_MESSAGE_TYPE_DUMMY: u32 = 6;
pub const GNUNET_MESSAGE_TYPE_DUMMY2: u32 = 7;
pub const GNUNET_MESSAGE_TYPE_ARM_START: u32 = 8;
pub const GNUNET_MESSAGE_TYPE_ARM_STOP: u32 = 9;
pub const GNUNET_MESSAGE_TYPE_ARM_RESULT: u32 = 10;
pub const GNUNET_MESSAGE_TYPE_ARM_STATUS: u32 = 11;
pub const GNUNET_MESSAGE_TYPE_ARM_LIST: u32 = 12;
pub const GNUNET_MESSAGE_TYPE_ARM_LIST_RESULT: u32 = 13;
pub const GNUNET_MESSAGE_TYPE_ARM_MONITOR: u32 = 14;
pub const GNUNET_MESSAGE_TYPE_ARM_TEST: u32 = 15;
pub const GNUNET_MESSAGE_TYPE_HELLO_LEGACY: u32 = 16;
pub const GNUNET_MESSAGE_TYPE_HELLO: u32 = 17;
pub const GNUNET_MESSAGE_TYPE_FRAGMENT: u32 = 18;
pub const GNUNET_MESSAGE_TYPE_FRAGMENT_ACK: u32 = 19;
pub const GNUNET_MESSAGE_TYPE_WLAN_DATA_TO_HELPER: u32 = 39;
pub const GNUNET_MESSAGE_TYPE_WLAN_DATA_FROM_HELPER: u32 = 40;
pub const GNUNET_MESSAGE_TYPE_WLAN_HELPER_CONTROL: u32 = 41;
pub const GNUNET_MESSAGE_TYPE_WLAN_ADVERTISEMENT: u32 = 42;
pub const GNUNET_MESSAGE_TYPE_WLAN_DATA: u32 = 43;
pub const GNUNET_MESSAGE_TYPE_DV_RECV: u32 = 44;
pub const GNUNET_MESSAGE_TYPE_DV_SEND: u32 = 45;
pub const GNUNET_MESSAGE_TYPE_DV_SEND_ACK: u32 = 46;
pub const GNUNET_MESSAGE_TYPE_DV_ROUTE: u32 = 47;
pub const GNUNET_MESSAGE_TYPE_DV_START: u32 = 48;
pub const GNUNET_MESSAGE_TYPE_DV_CONNECT: u32 = 49;
pub const GNUNET_MESSAGE_TYPE_DV_DISCONNECT: u32 = 50;
pub const GNUNET_MESSAGE_TYPE_DV_SEND_NACK: u32 = 51;
pub const GNUNET_MESSAGE_TYPE_DV_DISTANCE_CHANGED: u32 = 52;
pub const GNUNET_MESSAGE_TYPE_DV_BOX: u32 = 53;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_XU_MESSAGE: u32 = 55;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_UDP_MESSAGE: u32 = 56;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_UDP_ACK: u32 = 57;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_TCP_NAT_PROBE: u32 = 60;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_TCP_WELCOME: u32 = 61;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_ATS: u32 = 62;
pub const GNUNET_MESSAGE_TYPE_NAT_TEST: u32 = 63;
pub const GNUNET_MESSAGE_TYPE_CORE_INIT: u32 = 64;
pub const GNUNET_MESSAGE_TYPE_CORE_INIT_REPLY: u32 = 65;
pub const GNUNET_MESSAGE_TYPE_CORE_NOTIFY_CONNECT: u32 = 67;
pub const GNUNET_MESSAGE_TYPE_CORE_NOTIFY_DISCONNECT: u32 = 68;
pub const GNUNET_MESSAGE_TYPE_CORE_NOTIFY_STATUS_CHANGE: u32 = 69;
pub const GNUNET_MESSAGE_TYPE_CORE_NOTIFY_INBOUND: u32 = 70;
pub const GNUNET_MESSAGE_TYPE_CORE_NOTIFY_OUTBOUND: u32 = 71;
pub const GNUNET_MESSAGE_TYPE_CORE_SEND_REQUEST: u32 = 74;
pub const GNUNET_MESSAGE_TYPE_CORE_SEND_READY: u32 = 75;
pub const GNUNET_MESSAGE_TYPE_CORE_SEND: u32 = 76;
pub const GNUNET_MESSAGE_TYPE_CORE_MONITOR_PEERS: u32 = 78;
pub const GNUNET_MESSAGE_TYPE_CORE_MONITOR_NOTIFY: u32 = 79;
pub const GNUNET_MESSAGE_TYPE_CORE_ENCRYPTED_MESSAGE: u32 = 82;
pub const GNUNET_MESSAGE_TYPE_CORE_PING: u32 = 83;
pub const GNUNET_MESSAGE_TYPE_CORE_PONG: u32 = 84;
pub const GNUNET_MESSAGE_TYPE_CORE_HANGUP: u32 = 85;
pub const GNUNET_MESSAGE_TYPE_CORE_COMPRESSED_TYPE_MAP: u32 = 86;
pub const GNUNET_MESSAGE_TYPE_CORE_BINARY_TYPE_MAP: u32 = 87;
pub const GNUNET_MESSAGE_TYPE_CORE_EPHEMERAL_KEY: u32 = 88;
pub const GNUNET_MESSAGE_TYPE_CORE_CONFIRM_TYPE_MAP: u32 = 89;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_RESERVE: u32 = 92;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_RELEASE_RESERVE: u32 = 93;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_STATUS: u32 = 94;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_PUT: u32 = 95;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_GET: u32 = 97;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_GET_REPLICATION: u32 = 98;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_GET_ZERO_ANONYMITY: u32 = 99;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_DATA: u32 = 100;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_DATA_END: u32 = 101;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_REMOVE: u32 = 102;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_DROP: u32 = 103;
pub const GNUNET_MESSAGE_TYPE_DATASTORE_GET_KEY: u32 = 104;
pub const GNUNET_MESSAGE_TYPE_FS_REQUEST_LOC_SIGN: u32 = 126;
pub const GNUNET_MESSAGE_TYPE_FS_REQUEST_LOC_SIGNATURE: u32 = 127;
pub const GNUNET_MESSAGE_TYPE_FS_INDEX_START: u32 = 128;
pub const GNUNET_MESSAGE_TYPE_FS_INDEX_START_OK: u32 = 129;
pub const GNUNET_MESSAGE_TYPE_FS_INDEX_START_FAILED: u32 = 130;
pub const GNUNET_MESSAGE_TYPE_FS_INDEX_LIST_GET: u32 = 131;
pub const GNUNET_MESSAGE_TYPE_FS_INDEX_LIST_ENTRY: u32 = 132;
pub const GNUNET_MESSAGE_TYPE_FS_INDEX_LIST_END: u32 = 133;
pub const GNUNET_MESSAGE_TYPE_FS_UNINDEX: u32 = 134;
pub const GNUNET_MESSAGE_TYPE_FS_UNINDEX_OK: u32 = 135;
pub const GNUNET_MESSAGE_TYPE_FS_START_SEARCH: u32 = 136;
pub const GNUNET_MESSAGE_TYPE_FS_GET: u32 = 137;
pub const GNUNET_MESSAGE_TYPE_FS_PUT: u32 = 138;
pub const GNUNET_MESSAGE_TYPE_FS_MIGRATION_STOP: u32 = 139;
pub const GNUNET_MESSAGE_TYPE_FS_CADET_QUERY: u32 = 140;
pub const GNUNET_MESSAGE_TYPE_FS_CADET_REPLY: u32 = 141;
pub const GNUNET_MESSAGE_TYPE_DHT_CLIENT_PUT: u32 = 142;
pub const GNUNET_MESSAGE_TYPE_DHT_CLIENT_GET: u32 = 143;
pub const GNUNET_MESSAGE_TYPE_DHT_CLIENT_GET_STOP: u32 = 144;
pub const GNUNET_MESSAGE_TYPE_DHT_CLIENT_RESULT: u32 = 145;
pub const GNUNET_MESSAGE_TYPE_DHT_P2P_PUT: u32 = 146;
pub const GNUNET_MESSAGE_TYPE_DHT_P2P_GET: u32 = 147;
pub const GNUNET_MESSAGE_TYPE_DHT_P2P_RESULT: u32 = 148;
pub const GNUNET_MESSAGE_TYPE_DHT_MONITOR_GET: u32 = 149;
pub const GNUNET_MESSAGE_TYPE_DHT_MONITOR_GET_RESP: u32 = 150;
pub const GNUNET_MESSAGE_TYPE_DHT_MONITOR_PUT: u32 = 151;
pub const GNUNET_MESSAGE_TYPE_DHT_MONITOR_PUT_RESP: u32 = 152;
pub const GNUNET_MESSAGE_TYPE_DHT_MONITOR_START: u32 = 153;
pub const GNUNET_MESSAGE_TYPE_DHT_MONITOR_STOP: u32 = 154;
pub const GNUNET_MESSAGE_TYPE_DHT_CLIENT_GET_RESULTS_KNOWN: u32 = 156;
pub const GNUNET_MESSAGE_TYPE_HOSTLIST_ADVERTISEMENT: u32 = 160;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_SET: u32 = 168;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_GET: u32 = 169;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_VALUE: u32 = 170;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_END: u32 = 171;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_WATCH: u32 = 172;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_WATCH_VALUE: u32 = 173;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_DISCONNECT: u32 = 174;
pub const GNUNET_MESSAGE_TYPE_STATISTICS_DISCONNECT_CONFIRM: u32 = 175;
pub const GNUNET_MESSAGE_TYPE_VPN_HELPER: u32 = 185;
pub const GNUNET_MESSAGE_TYPE_VPN_ICMP_TO_SERVICE: u32 = 190;
pub const GNUNET_MESSAGE_TYPE_VPN_ICMP_TO_INTERNET: u32 = 191;
pub const GNUNET_MESSAGE_TYPE_VPN_ICMP_TO_VPN: u32 = 192;
pub const GNUNET_MESSAGE_TYPE_VPN_DNS_TO_INTERNET: u32 = 193;
pub const GNUNET_MESSAGE_TYPE_VPN_DNS_FROM_INTERNET: u32 = 194;
pub const GNUNET_MESSAGE_TYPE_VPN_TCP_TO_SERVICE_START: u32 = 195;
pub const GNUNET_MESSAGE_TYPE_VPN_TCP_TO_INTERNET_START: u32 = 196;
pub const GNUNET_MESSAGE_TYPE_VPN_TCP_DATA_TO_EXIT: u32 = 197;
pub const GNUNET_MESSAGE_TYPE_VPN_TCP_DATA_TO_VPN: u32 = 198;
pub const GNUNET_MESSAGE_TYPE_VPN_UDP_TO_SERVICE: u32 = 199;
pub const GNUNET_MESSAGE_TYPE_VPN_UDP_TO_INTERNET: u32 = 200;
pub const GNUNET_MESSAGE_TYPE_VPN_UDP_REPLY: u32 = 201;
pub const GNUNET_MESSAGE_TYPE_VPN_CLIENT_REDIRECT_TO_IP: u32 = 202;
pub const GNUNET_MESSAGE_TYPE_VPN_CLIENT_REDIRECT_TO_SERVICE: u32 = 203;
pub const GNUNET_MESSAGE_TYPE_VPN_CLIENT_USE_IP: u32 = 204;
pub const GNUNET_MESSAGE_TYPE_DNS_CLIENT_INIT: u32 = 211;
pub const GNUNET_MESSAGE_TYPE_DNS_CLIENT_REQUEST: u32 = 212;
pub const GNUNET_MESSAGE_TYPE_DNS_CLIENT_RESPONSE: u32 = 213;
pub const GNUNET_MESSAGE_TYPE_DNS_HELPER: u32 = 214;
pub const GNUNET_MESSAGE_TYPE_CHAT_JOIN_REQUEST: u32 = 300;
pub const GNUNET_MESSAGE_TYPE_CHAT_JOIN_NOTIFICATION: u32 = 301;
pub const GNUNET_MESSAGE_TYPE_CHAT_LEAVE_NOTIFICATION: u32 = 302;
pub const GNUNET_MESSAGE_TYPE_CHAT_MESSAGE_NOTIFICATION: u32 = 303;
pub const GNUNET_MESSAGE_TYPE_CHAT_TRANSMIT_REQUEST: u32 = 304;
pub const GNUNET_MESSAGE_TYPE_CHAT_CONFIRMATION_RECEIPT: u32 = 305;
pub const GNUNET_MESSAGE_TYPE_CHAT_CONFIRMATION_NOTIFICATION: u32 = 306;
pub const GNUNET_MESSAGE_TYPE_CHAT_P2P_JOIN_NOTIFICATION: u32 = 307;
pub const GNUNET_MESSAGE_TYPE_CHAT_P2P_LEAVE_NOTIFICATION: u32 = 308;
pub const GNUNET_MESSAGE_TYPE_CHAT_P2P_SYNC_REQUEST: u32 = 309;
pub const GNUNET_MESSAGE_TYPE_CHAT_P2P_MESSAGE_NOTIFICATION: u32 = 310;
pub const GNUNET_MESSAGE_TYPE_CHAT_P2P_CONFIRMATION_RECEIPT: u32 = 311;
pub const GNUNET_MESSAGE_TYPE_NSE_START: u32 = 321;
pub const GNUNET_MESSAGE_TYPE_NSE_P2P_FLOOD: u32 = 322;
pub const GNUNET_MESSAGE_TYPE_NSE_ESTIMATE: u32 = 323;
pub const GNUNET_MESSAGE_TYPE_PEERINFO_GET: u32 = 330;
pub const GNUNET_MESSAGE_TYPE_PEERINFO_GET_ALL: u32 = 331;
pub const GNUNET_MESSAGE_TYPE_PEERINFO_INFO: u32 = 332;
pub const GNUNET_MESSAGE_TYPE_PEERINFO_INFO_END: u32 = 333;
pub const GNUNET_MESSAGE_TYPE_PEERINFO_NOTIFY: u32 = 334;
pub const GNUNET_MESSAGE_TYPE_ATS_START: u32 = 340;
pub const GNUNET_MESSAGE_TYPE_ATS_REQUEST_ADDRESS: u32 = 341;
pub const GNUNET_MESSAGE_TYPE_ATS_REQUEST_ADDRESS_CANCEL: u32 = 342;
pub const GNUNET_MESSAGE_TYPE_ATS_ADDRESS_UPDATE: u32 = 343;
pub const GNUNET_MESSAGE_TYPE_ATS_ADDRESS_DESTROYED: u32 = 344;
pub const GNUNET_MESSAGE_TYPE_ATS_ADDRESS_SUGGESTION: u32 = 345;
pub const GNUNET_MESSAGE_TYPE_ATS_PEER_INFORMATION: u32 = 346;
pub const GNUNET_MESSAGE_TYPE_ATS_RESERVATION_REQUEST: u32 = 347;
pub const GNUNET_MESSAGE_TYPE_ATS_RESERVATION_RESULT: u32 = 348;
pub const GNUNET_MESSAGE_TYPE_ATS_PREFERENCE_CHANGE: u32 = 349;
pub const GNUNET_MESSAGE_TYPE_ATS_SESSION_RELEASE: u32 = 350;
pub const GNUNET_MESSAGE_TYPE_ATS_ADDRESS_ADD: u32 = 353;
pub const GNUNET_MESSAGE_TYPE_ATS_ADDRESSLIST_REQUEST: u32 = 354;
pub const GNUNET_MESSAGE_TYPE_ATS_ADDRESSLIST_RESPONSE: u32 = 355;
pub const GNUNET_MESSAGE_TYPE_ATS_PREFERENCE_FEEDBACK: u32 = 356;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_START: u32 = 360;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_CONNECT: u32 = 361;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_DISCONNECT: u32 = 362;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SEND: u32 = 363;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SEND_OK: u32 = 364;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_RECV: u32 = 365;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SET_QUOTA: u32 = 366;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_RECV_OK: u32 = 366;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_ADDRESS_TO_STRING: u32 = 367;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_ADDRESS_TO_STRING_REPLY: u32 = 368;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_BLACKLIST_INIT: u32 = 369;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_BLACKLIST_QUERY: u32 = 370;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_BLACKLIST_REPLY: u32 = 371;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_PING: u32 = 372;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_PONG: u32 = 373;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_SYN: u32 = 375;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_SYN_ACK: u32 = 376;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_ACK: u32 = 377;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_DISCONNECT: u32 = 378;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_QUOTA: u32 = 379;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_PEER_REQUEST: u32 = 380;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_KEEPALIVE: u32 = 381;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SESSION_KEEPALIVE_RESPONSE: u32 = 382;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_PEER_RESPONSE: u32 = 383;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_BROADCAST_BEACON: u32 = 384;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_TRAFFIC_METRIC: u32 = 385;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_PLUGIN_START: u32 = 388;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_PLUGIN_EVENT: u32 = 389;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_PLUGIN_SYNC: u32 = 390;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_PEER_RESPONSE_END: u32 = 391;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_PROGRESS_FILE: u32 = 420;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_PROGRESS_DIRECTORY: u32 = 421;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_ERROR: u32 = 422;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_SKIP_FILE: u32 = 423;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_COUNTING_DONE: u32 = 424;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_META_DATA: u32 = 425;
pub const GNUNET_MESSAGE_TYPE_FS_PUBLISH_HELPER_FINISHED: u32 = 426;
pub const GNUNET_MESSAGE_TYPE_NAMECACHE_LOOKUP_BLOCK: u32 = 431;
pub const GNUNET_MESSAGE_TYPE_NAMECACHE_LOOKUP_BLOCK_RESPONSE: u32 = 432;
pub const GNUNET_MESSAGE_TYPE_NAMECACHE_BLOCK_CACHE: u32 = 433;
pub const GNUNET_MESSAGE_TYPE_NAMECACHE_BLOCK_CACHE_RESPONSE: u32 = 434;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_RECORD_STORE: u32 = 435;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_RECORD_STORE_RESPONSE: u32 = 436;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_RECORD_LOOKUP: u32 = 437;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_RECORD_LOOKUP_RESPONSE: u32 = 438;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_ZONE_TO_NAME: u32 = 439;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_ZONE_TO_NAME_RESPONSE: u32 = 440;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_MONITOR_START: u32 = 441;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_MONITOR_SYNC: u32 = 442;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_RECORD_RESULT: u32 = 443;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_MONITOR_NEXT: u32 = 444;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_ZONE_ITERATION_START: u32 = 445;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_ZONE_ITERATION_NEXT: u32 = 447;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_ZONE_ITERATION_STOP: u32 = 448;
pub const GNUNET_MESSAGE_TYPE_NAMESTORE_RECORD_RESULT_END: u32 = 449;
pub const GNUNET_MESSAGE_TYPE_LOCKMANAGER_ACQUIRE: u32 = 450;
pub const GNUNET_MESSAGE_TYPE_LOCKMANAGER_RELEASE: u32 = 451;
pub const GNUNET_MESSAGE_TYPE_LOCKMANAGER_SUCCESS: u32 = 452;
pub const GNUNET_MESSAGE_TYPE_TESTBED_INIT: u32 = 460;
pub const GNUNET_MESSAGE_TYPE_TESTBED_ADD_HOST: u32 = 461;
pub const GNUNET_MESSAGE_TYPE_TESTBED_ADD_HOST_SUCCESS: u32 = 462;
pub const GNUNET_MESSAGE_TYPE_TESTBED_LINK_CONTROLLERS: u32 = 463;
pub const GNUNET_MESSAGE_TYPE_TESTBED_CREATE_PEER: u32 = 464;
pub const GNUNET_MESSAGE_TYPE_TESTBED_RECONFIGURE_PEER: u32 = 465;
pub const GNUNET_MESSAGE_TYPE_TESTBED_START_PEER: u32 = 466;
pub const GNUNET_MESSAGE_TYPE_TESTBED_STOP_PEER: u32 = 467;
pub const GNUNET_MESSAGE_TYPE_TESTBED_DESTROY_PEER: u32 = 468;
pub const GNUNET_MESSAGE_TYPE_TESTBED_CONFIGURE_UNDERLAY_LINK: u32 = 469;
pub const GNUNET_MESSAGE_TYPE_TESTBED_OVERLAY_CONNECT: u32 = 470;
pub const GNUNET_MESSAGE_TYPE_TESTBED_PEER_EVENT: u32 = 471;
pub const GNUNET_MESSAGE_TYPE_TESTBED_PEER_CONNECT_EVENT: u32 = 472;
pub const GNUNET_MESSAGE_TYPE_TESTBED_OPERATION_FAIL_EVENT: u32 = 473;
pub const GNUNET_MESSAGE_TYPE_TESTBED_CREATE_PEER_SUCCESS: u32 = 474;
pub const GNUNET_MESSAGE_TYPE_TESTBED_GENERIC_OPERATION_SUCCESS: u32 = 475;
pub const GNUNET_MESSAGE_TYPE_TESTBED_GET_PEER_INFORMATION: u32 = 476;
pub const GNUNET_MESSAGE_TYPE_TESTBED_PEER_INFORMATION: u32 = 477;
pub const GNUNET_MESSAGE_TYPE_TESTBED_REMOTE_OVERLAY_CONNECT: u32 = 478;
pub const GNUNET_MESSAGE_TYPE_TESTBED_GET_SLAVE_CONFIGURATION: u32 = 479;
pub const GNUNET_MESSAGE_TYPE_TESTBED_SLAVE_CONFIGURATION: u32 = 480;
pub const GNUNET_MESSAGE_TYPE_TESTBED_LINK_CONTROLLERS_RESULT: u32 = 481;
pub const GNUNET_MESSAGE_TYPE_TESTBED_SHUTDOWN_PEERS: u32 = 482;
pub const GNUNET_MESSAGE_TYPE_TESTBED_MANAGE_PEER_SERVICE: u32 = 483;
pub const GNUNET_MESSAGE_TYPE_TESTBED_BARRIER_INIT: u32 = 484;
pub const GNUNET_MESSAGE_TYPE_TESTBED_BARRIER_CANCEL: u32 = 485;
pub const GNUNET_MESSAGE_TYPE_TESTBED_BARRIER_STATUS: u32 = 486;
pub const GNUNET_MESSAGE_TYPE_TESTBED_BARRIER_WAIT: u32 = 487;
pub const GNUNET_MESSAGE_TYPE_TESTBED_MAX: u32 = 488;
pub const GNUNET_MESSAGE_TYPE_TESTBED_HELPER_INIT: u32 = 495;
pub const GNUNET_MESSAGE_TYPE_TESTBED_HELPER_REPLY: u32 = 496;
pub const GNUNET_MESSAGE_TYPE_GNS_LOOKUP: u32 = 500;
pub const GNUNET_MESSAGE_TYPE_GNS_LOOKUP_RESULT: u32 = 501;
pub const GNUNET_MESSAGE_TYPE_GNS_REVERSE_LOOKUP: u32 = 503;
pub const GNUNET_MESSAGE_TYPE_GNS_REVERSE_LOOKUP_RESULT: u32 = 504;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_JOIN: u32 = 520;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_INSERT: u32 = 521;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_BEGIN: u32 = 522;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_RECEIVED_ELEMENT: u32 = 523;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_CONCLUDE: u32 = 524;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_CONCLUDE_DONE: u32 = 525;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_CLIENT_ACK: u32 = 540;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_P2P_DELTA_ESTIMATE: u32 = 541;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_P2P_DIFFERENCE_DIGEST: u32 = 542;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_P2P_ELEMENTS: u32 = 543;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_P2P_ELEMENTS_REQUEST: u32 = 544;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_P2P_ELEMENTS_REPORT: u32 = 545;
pub const GNUNET_MESSAGE_TYPE_CONSENSUS_P2P_ROUND_CONTEXT: u32 = 547;
pub const GNUNET_MESSAGE_TYPE_SETU_CANCEL: u32 = 550;
pub const GNUNET_MESSAGE_TYPE_SETU_ADD: u32 = 551;
pub const GNUNET_MESSAGE_TYPE_SETU_CREATE: u32 = 552;
pub const GNUNET_MESSAGE_TYPE_SETU_RESULT: u32 = 553;
pub const GNUNET_MESSAGE_TYPE_SETU_EVALUATE: u32 = 554;
pub const GNUNET_MESSAGE_TYPE_SETU_LISTEN: u32 = 555;
pub const GNUNET_MESSAGE_TYPE_SETU_REJECT: u32 = 556;
pub const GNUNET_MESSAGE_TYPE_SETU_ACCEPT: u32 = 557;
pub const GNUNET_MESSAGE_TYPE_SETU_REQUEST: u32 = 558;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_REQUEST_FULL: u32 = 559;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_DEMAND: u32 = 560;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_INQUIRY: u32 = 561;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_OFFER: u32 = 562;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_OPERATION_REQUEST: u32 = 563;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_SE: u32 = 564;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_IBF: u32 = 565;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_ELEMENTS: u32 = 566;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_DONE: u32 = 568;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_SEC: u32 = 569;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_FULL_DONE: u32 = 570;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_FULL_ELEMENT: u32 = 571;
pub const GNUNET_MESSAGE_TYPE_SETU_P2P_OVER: u32 = 572;
pub const GNUNET_MESSAGE_TYPE_SETI_CANCEL: u32 = 580;
pub const GNUNET_MESSAGE_TYPE_SETI_ADD: u32 = 581;
pub const GNUNET_MESSAGE_TYPE_SETI_CREATE: u32 = 582;
pub const GNUNET_MESSAGE_TYPE_SETI_RESULT: u32 = 583;
pub const GNUNET_MESSAGE_TYPE_SETI_EVALUATE: u32 = 584;
pub const GNUNET_MESSAGE_TYPE_SETI_LISTEN: u32 = 585;
pub const GNUNET_MESSAGE_TYPE_SETI_REJECT: u32 = 586;
pub const GNUNET_MESSAGE_TYPE_SETI_ACCEPT: u32 = 587;
pub const GNUNET_MESSAGE_TYPE_SETI_REQUEST: u32 = 588;
pub const GNUNET_MESSAGE_TYPE_SETI_P2P_ELEMENT_INFO: u32 = 591;
pub const GNUNET_MESSAGE_TYPE_SETI_P2P_BF: u32 = 592;
pub const GNUNET_MESSAGE_TYPE_SETI_P2P_DONE: u32 = 593;
pub const GNUNET_MESSAGE_TYPE_SETI_P2P_OPERATION_REQUEST: u32 = 594;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_REQUEST_FULL: u32 = 565;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_DEMAND: u32 = 566;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_INQUIRY: u32 = 567;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_OFFER: u32 = 568;
pub const GNUNET_MESSAGE_TYPE_SET_REJECT: u32 = 569;
pub const GNUNET_MESSAGE_TYPE_SET_CANCEL: u32 = 570;
pub const GNUNET_MESSAGE_TYPE_SET_ITER_ACK: u32 = 571;
pub const GNUNET_MESSAGE_TYPE_SET_RESULT: u32 = 572;
pub const GNUNET_MESSAGE_TYPE_SET_ADD: u32 = 573;
pub const GNUNET_MESSAGE_TYPE_SET_REMOVE: u32 = 574;
pub const GNUNET_MESSAGE_TYPE_SET_LISTEN: u32 = 575;
pub const GNUNET_MESSAGE_TYPE_SET_ACCEPT: u32 = 576;
pub const GNUNET_MESSAGE_TYPE_SET_EVALUATE: u32 = 577;
pub const GNUNET_MESSAGE_TYPE_SET_CONCLUDE: u32 = 578;
pub const GNUNET_MESSAGE_TYPE_SET_REQUEST: u32 = 579;
pub const GNUNET_MESSAGE_TYPE_SET_CREATE: u32 = 580;
pub const GNUNET_MESSAGE_TYPE_SET_P2P_OPERATION_REQUEST: u32 = 581;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_SE: u32 = 582;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_IBF: u32 = 583;
pub const GNUNET_MESSAGE_TYPE_SET_P2P_ELEMENTS: u32 = 584;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_DONE: u32 = 586;
pub const GNUNET_MESSAGE_TYPE_SET_ITER_REQUEST: u32 = 587;
pub const GNUNET_MESSAGE_TYPE_SET_ITER_ELEMENT: u32 = 588;
pub const GNUNET_MESSAGE_TYPE_SET_ITER_DONE: u32 = 589;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_SEC: u32 = 590;
pub const GNUNET_MESSAGE_TYPE_SET_INTERSECTION_P2P_ELEMENT_INFO: u32 = 591;
pub const GNUNET_MESSAGE_TYPE_SET_INTERSECTION_P2P_BF: u32 = 592;
pub const GNUNET_MESSAGE_TYPE_SET_INTERSECTION_P2P_DONE: u32 = 593;
pub const GNUNET_MESSAGE_TYPE_SET_COPY_LAZY_PREPARE: u32 = 594;
pub const GNUNET_MESSAGE_TYPE_SET_COPY_LAZY_RESPONSE: u32 = 595;
pub const GNUNET_MESSAGE_TYPE_SET_COPY_LAZY_CONNECT: u32 = 596;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_FULL_DONE: u32 = 597;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_FULL_ELEMENT: u32 = 598;
pub const GNUNET_MESSAGE_TYPE_SET_UNION_P2P_OVER: u32 = 599;
pub const GNUNET_MESSAGE_TYPE_TESTBED_LOGGER_MSG: u32 = 600;
pub const GNUNET_MESSAGE_TYPE_TESTBED_LOGGER_ACK: u32 = 601;
pub const GNUNET_MESSAGE_TYPE_REGEX_ANNOUNCE: u32 = 620;
pub const GNUNET_MESSAGE_TYPE_REGEX_SEARCH: u32 = 621;
pub const GNUNET_MESSAGE_TYPE_REGEX_RESULT: u32 = 622;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_START: u32 = 624;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_RESULT_CODE: u32 = 625;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_UPDATE: u32 = 626;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_GET_DEFAULT: u32 = 627;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_SET_DEFAULT: u32 = 628;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_CREATE: u32 = 629;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_RENAME: u32 = 630;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_DELETE: u32 = 631;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_LOOKUP: u32 = 632;
pub const GNUNET_MESSAGE_TYPE_IDENTITY_LOOKUP_BY_SUFFIX: u32 = 633;
pub const GNUNET_MESSAGE_TYPE_REVOCATION_QUERY: u32 = 636;
pub const GNUNET_MESSAGE_TYPE_REVOCATION_QUERY_RESPONSE: u32 = 637;
pub const GNUNET_MESSAGE_TYPE_REVOCATION_REVOKE: u32 = 638;
pub const GNUNET_MESSAGE_TYPE_REVOCATION_REVOKE_RESPONSE: u32 = 639;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_CLIENT_TO_ALICE: u32 = 640;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_CLIENT_TO_BOB: u32 = 641;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_CLIENT_MULTIPART_ALICE: u32 = 642;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_CLIENT_MULTIPART_BOB: u32 = 643;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_SESSION_INITIALIZATION: u32 = 644;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_ALICE_CRYPTODATA: u32 = 645;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_BOB_CRYPTODATA: u32 = 647;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_BOB_CRYPTODATA_MULTIPART: u32 = 648;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_RESULT: u32 = 649;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_ECC_SESSION_INITIALIZATION: u32 = 650;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_ECC_ALICE_CRYPTODATA: u32 = 651;
pub const GNUNET_MESSAGE_TYPE_SCALARPRODUCT_ECC_BOB_CRYPTODATA: u32 = 652;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_MEMBERSHIP_STORE: u32 = 660;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_MEMBERSHIP_TEST: u32 = 661;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_FRAGMENT_STORE: u32 = 662;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_FRAGMENT_GET: u32 = 663;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_MESSAGE_GET: u32 = 664;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_MESSAGE_GET_FRAGMENT: u32 = 665;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_COUNTERS_GET: u32 = 666;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_STATE_MODIFY: u32 = 668;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_STATE_SYNC: u32 = 669;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_STATE_RESET: u32 = 670;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_STATE_HASH_UPDATE: u32 = 671;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_STATE_GET: u32 = 672;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_STATE_GET_PREFIX: u32 = 673;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_RESULT_CODE: u32 = 674;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_RESULT_FRAGMENT: u32 = 675;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_RESULT_COUNTERS: u32 = 676;
pub const GNUNET_MESSAGE_TYPE_PSYCSTORE_RESULT_STATE: u32 = 677;
pub const GNUNET_MESSAGE_TYPE_PSYC_RESULT_CODE: u32 = 680;
pub const GNUNET_MESSAGE_TYPE_PSYC_MASTER_START: u32 = 681;
pub const GNUNET_MESSAGE_TYPE_PSYC_MASTER_START_ACK: u32 = 682;
pub const GNUNET_MESSAGE_TYPE_PSYC_SLAVE_JOIN: u32 = 683;
pub const GNUNET_MESSAGE_TYPE_PSYC_SLAVE_JOIN_ACK: u32 = 684;
pub const GNUNET_MESSAGE_TYPE_PSYC_PART_REQUEST: u32 = 685;
pub const GNUNET_MESSAGE_TYPE_PSYC_PART_ACK: u32 = 686;
pub const GNUNET_MESSAGE_TYPE_PSYC_JOIN_REQUEST: u32 = 687;
pub const GNUNET_MESSAGE_TYPE_PSYC_JOIN_DECISION: u32 = 688;
pub const GNUNET_MESSAGE_TYPE_PSYC_CHANNEL_MEMBERSHIP_STORE: u32 = 689;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE: u32 = 691;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_HEADER: u32 = 692;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_METHOD: u32 = 693;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_MODIFIER: u32 = 694;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_MOD_CONT: u32 = 695;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_DATA: u32 = 696;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_END: u32 = 697;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_CANCEL: u32 = 698;
pub const GNUNET_MESSAGE_TYPE_PSYC_MESSAGE_ACK: u32 = 699;
pub const GNUNET_MESSAGE_TYPE_PSYC_HISTORY_REPLAY: u32 = 701;
pub const GNUNET_MESSAGE_TYPE_PSYC_HISTORY_RESULT: u32 = 702;
pub const GNUNET_MESSAGE_TYPE_PSYC_STATE_GET: u32 = 703;
pub const GNUNET_MESSAGE_TYPE_PSYC_STATE_GET_PREFIX: u32 = 704;
pub const GNUNET_MESSAGE_TYPE_PSYC_STATE_RESULT: u32 = 705;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_AUDIO: u32 = 730;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_REGISTER: u32 = 731;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_PICK_UP: u32 = 732;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_HANG_UP: u32 = 733;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_CALL: u32 = 734;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_RING: u32 = 735;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_SUSPEND: u32 = 736;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_RESUME: u32 = 737;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_PHONE_PICKED_UP: u32 = 738;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CS_AUDIO: u32 = 739;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CADET_PHONE_RING: u32 = 740;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CADET_PHONE_HANG_UP: u32 = 741;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CADET_PHONE_PICK_UP: u32 = 742;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CADET_PHONE_SUSPEND: u32 = 743;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CADET_PHONE_RESUME: u32 = 744;
pub const GNUNET_MESSAGE_TYPE_CONVERSATION_CADET_AUDIO: u32 = 745;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_ORIGIN_START: u32 = 750;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_MEMBER_JOIN: u32 = 751;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_JOIN_REQUEST: u32 = 752;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_JOIN_DECISION: u32 = 753;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_PART_REQUEST: u32 = 754;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_PART_ACK: u32 = 755;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_GROUP_END: u32 = 756;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_MESSAGE: u32 = 757;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_REQUEST: u32 = 758;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_FRAGMENT_ACK: u32 = 759;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_REPLAY_REQUEST: u32 = 760;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_REPLAY_RESPONSE: u32 = 761;
pub const GNUNET_MESSAGE_TYPE_MULTICAST_REPLAY_RESPONSE_END: u32 = 762;
pub const GNUNET_MESSAGE_TYPE_SECRETSHARING_CLIENT_GENERATE: u32 = 780;
pub const GNUNET_MESSAGE_TYPE_SECRETSHARING_CLIENT_DECRYPT: u32 = 781;
pub const GNUNET_MESSAGE_TYPE_SECRETSHARING_CLIENT_DECRYPT_DONE: u32 = 782;
pub const GNUNET_MESSAGE_TYPE_SECRETSHARING_CLIENT_SECRET_READY: u32 = 783;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_STORE: u32 = 820;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_ITERATE: u32 = 821;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_ITERATE_RECORD: u32 = 822;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_ITERATE_END: u32 = 823;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_WATCH: u32 = 824;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_WATCH_RECORD: u32 = 825;
pub const GNUNET_MESSAGE_TYPE_PEERSTORE_WATCH_CANCEL: u32 = 826;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_RESULT_CODE: u32 = 840;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_HOST_ENTER: u32 = 841;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_HOST_ENTER_ACK: u32 = 842;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_GUEST_ENTER: u32 = 843;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_GUEST_ENTER_BY_NAME: u32 = 844;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_GUEST_ENTER_ACK: u32 = 845;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_ENTRY_REQUEST: u32 = 846;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_ENTRY_DECISION: u32 = 847;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_PLACE_LEAVE: u32 = 848;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_PLACE_LEAVE_ACK: u32 = 849;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_ZONE_ADD_PLACE: u32 = 850;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_ZONE_ADD_NYM: u32 = 851;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_APP_CONNECT: u32 = 852;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_APP_DETACH: u32 = 853;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_APP_EGO: u32 = 854;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_APP_EGO_END: u32 = 855;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_APP_PLACE: u32 = 856;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_APP_PLACE_END: u32 = 857;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_MSG_PROC_SET: u32 = 858;
pub const GNUNET_MESSAGE_TYPE_SOCIAL_MSG_PROC_CLEAR: u32 = 859;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_TRAIL_SETUP: u32 = 880;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_TRAIL_SETUP_RESULT: u32 = 881;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_VERIFY_SUCCESSOR: u32 = 882;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_NOTIFY_NEW_SUCCESSOR: u32 = 883;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_VERIFY_SUCCESSOR_RESULT: u32 = 884;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_GET_RESULT: u32 = 885;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_TRAIL_SETUP_REJECTION: u32 = 886;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_TRAIL_TEARDOWN: u32 = 887;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_ADD_TRAIL: u32 = 888;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_PUT: u32 = 890;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_GET: u32 = 891;
pub const GNUNET_MESSAGE_TYPE_XDHT_P2P_NOTIFY_SUCCESSOR_CONFIRMATION: u32 = 892;
pub const GNUNET_MESSAGE_TYPE_WDHT_RANDOM_WALK: u32 = 910;
pub const GNUNET_MESSAGE_TYPE_WDHT_RANDOM_WALK_RESPONSE: u32 = 911;
pub const GNUNET_MESSAGE_TYPE_WDHT_TRAIL_DESTROY: u32 = 912;
pub const GNUNET_MESSAGE_TYPE_WDHT_TRAIL_ROUTE: u32 = 913;
pub const GNUNET_MESSAGE_TYPE_WDHT_SUCCESSOR_FIND: u32 = 914;
pub const GNUNET_MESSAGE_TYPE_WDHT_GET: u32 = 915;
pub const GNUNET_MESSAGE_TYPE_WDHT_PUT: u32 = 916;
pub const GNUNET_MESSAGE_TYPE_WDHT_GET_RESULT: u32 = 917;
pub const GNUNET_MESSAGE_TYPE_RPS_PP_CHECK_LIVE: u32 = 950;
pub const GNUNET_MESSAGE_TYPE_RPS_PP_PUSH: u32 = 951;
pub const GNUNET_MESSAGE_TYPE_RPS_PP_PULL_REQUEST: u32 = 952;
pub const GNUNET_MESSAGE_TYPE_RPS_PP_PULL_REPLY: u32 = 953;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_SEED: u32 = 954;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_SUB_START: u32 = 956;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_SUB_STOP: u32 = 957;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ATTRIBUTE_STORE: u32 = 961;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_SUCCESS_RESPONSE: u32 = 962;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ATTRIBUTE_ITERATION_START: u32 = 963;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ATTRIBUTE_ITERATION_STOP: u32 = 964;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ATTRIBUTE_ITERATION_NEXT: u32 = 965;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ATTRIBUTE_RESULT: u32 = 966;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ISSUE_TICKET: u32 = 967;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_TICKET_RESULT: u32 = 968;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_REVOKE_TICKET: u32 = 969;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_REVOKE_TICKET_RESULT: u32 = 970;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CONSUME_TICKET: u32 = 971;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CONSUME_TICKET_RESULT: u32 = 972;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_TICKET_ITERATION_START: u32 = 973;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_TICKET_ITERATION_STOP: u32 = 974;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_TICKET_ITERATION_NEXT: u32 = 975;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_ATTRIBUTE_DELETE: u32 = 976;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CREDENTIAL_STORE: u32 = 977;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CREDENTIAL_DELETE: u32 = 978;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CREDENTIAL_RESULT: u32 = 979;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CREDENTIAL_ITERATION_START: u32 = 980;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CREDENTIAL_ITERATION_STOP: u32 = 981;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_CREDENTIAL_ITERATION_NEXT: u32 = 982;
pub const GNUNET_MESSAGE_TYPE_ABD_VERIFY: u32 = 991;
pub const GNUNET_MESSAGE_TYPE_ABD_VERIFY_RESULT: u32 = 992;
pub const GNUNET_MESSAGE_TYPE_ABD_COLLECT: u32 = 993;
pub const GNUNET_MESSAGE_TYPE_ABD_COLLECT_RESULT: u32 = 994;
pub const GNUNET_MESSAGE_TYPE_ABD_INTERMEDIATE_RESULT: u32 = 995;
pub const GNUNET_MESSAGE_TYPE_CADET_CONNECTION_CREATE: u32 = 1000;
pub const GNUNET_MESSAGE_TYPE_CADET_CONNECTION_CREATE_ACK: u32 = 1001;
pub const GNUNET_MESSAGE_TYPE_CADET_CONNECTION_BROKEN: u32 = 1002;
pub const GNUNET_MESSAGE_TYPE_CADET_CONNECTION_DESTROY: u32 = 1003;
pub const GNUNET_MESSAGE_TYPE_CADET_CONNECTION_PATH_CHANGED_UNIMPLEMENTED: u32 = 1004;
pub const GNUNET_MESSAGE_TYPE_CADET_CONNECTION_HOP_BY_HOP_ENCRYPTED_ACK: u32 = 1005;
pub const GNUNET_MESSAGE_TYPE_CADET_TUNNEL_ENCRYPTED_POLL: u32 = 1006;
pub const GNUNET_MESSAGE_TYPE_CADET_TUNNEL_KX: u32 = 1007;
pub const GNUNET_MESSAGE_TYPE_CADET_TUNNEL_ENCRYPTED: u32 = 1008;
pub const GNUNET_MESSAGE_TYPE_CADET_TUNNEL_KX_AUTH: u32 = 1009;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_APP_DATA: u32 = 1010;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_APP_DATA_ACK: u32 = 1011;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_KEEPALIVE: u32 = 1012;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_OPEN: u32 = 1013;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_DESTROY: u32 = 1014;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_OPEN_ACK: u32 = 1015;
pub const GNUNET_MESSAGE_TYPE_CADET_CHANNEL_OPEN_NACK_DEPRECATED: u32 = 1016;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_DATA: u32 = 1020;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_ACK: u32 = 1021;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_PORT_OPEN: u32 = 1022;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_PORT_CLOSE: u32 = 1023;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_CHANNEL_CREATE: u32 = 1024;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_CHANNEL_DESTROY: u32 = 1025;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_REQUEST_INFO_CHANNEL: u32 = 1030;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_CHANNEL: u32 = 1031;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_CHANNEL_END: u32 = 1032;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_REQUEST_INFO_PEERS: u32 = 1033;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_PEERS: u32 = 1034;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_PEERS_END: u32 = 1035;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_REQUEST_INFO_PATH: u32 = 1036;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_PATH: u32 = 1037;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_PATH_END: u32 = 1038;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_REQUEST_INFO_TUNNELS: u32 = 1039;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_TUNNELS: u32 = 1040;
pub const GNUNET_MESSAGE_TYPE_CADET_LOCAL_INFO_TUNNELS_END: u32 = 1041;
pub const GNUNET_MESSAGE_TYPE_CADET_DROP_CADET_MESSAGE: u32 = 1042;
pub const GNUNET_MESSAGE_TYPE_CADET_CLI: u32 = 1059;
pub const GNUNET_MESSAGE_TYPE_NAT_REGISTER: u32 = 1060;
pub const GNUNET_MESSAGE_TYPE_NAT_HANDLE_STUN: u32 = 1061;
pub const GNUNET_MESSAGE_TYPE_NAT_REQUEST_CONNECTION_REVERSAL: u32 = 1062;
pub const GNUNET_MESSAGE_TYPE_NAT_CONNECTION_REVERSAL_REQUESTED: u32 = 1063;
pub const GNUNET_MESSAGE_TYPE_NAT_ADDRESS_CHANGE: u32 = 1064;
pub const GNUNET_MESSAGE_TYPE_NAT_AUTO_REQUEST_CFG: u32 = 1067;
pub const GNUNET_MESSAGE_TYPE_NAT_AUTO_CFG_RESULT: u32 = 1068;
pub const GNUNET_MESSAGE_TYPE_AUCTION_CLIENT_CREATE: u32 = 1110;
pub const GNUNET_MESSAGE_TYPE_AUCTION_CLIENT_JOIN: u32 = 1111;
pub const GNUNET_MESSAGE_TYPE_AUCTION_CLIENT_OUTCOME: u32 = 1112;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_DEBUG_VIEW_REQUEST: u32 = 1130;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_DEBUG_VIEW_REPLY: u32 = 1131;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_DEBUG_VIEW_CANCEL: u32 = 1132;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_DEBUG_STREAM_REQUEST: u32 = 1133;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_DEBUG_STREAM_REPLY: u32 = 1134;
pub const GNUNET_MESSAGE_TYPE_RPS_CS_DEBUG_STREAM_CANCEL: u32 = 1135;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_ADD_ADDRESS: u32 = 1200;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_DEL_ADDRESS: u32 = 1201;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_INCOMING_MSG: u32 = 1202;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_INCOMING_MSG_ACK: u32 = 1203;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_QUEUE_SETUP: u32 = 1204;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_QUEUE_TEARDOWN: u32 = 1205;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_QUEUE_CREATE: u32 = 1206;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_QUEUE_CREATE_OK: u32 = 1207;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_QUEUE_CREATE_FAIL: u32 = 1208;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SEND_MSG: u32 = 1209;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SEND_MSG_ACK: u32 = 1210;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_NEW_COMMUNICATOR: u32 = 1211;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_COMMUNICATOR_BACKCHANNEL: u32 = 1212;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_BACKCHANNEL_ENCAPSULATION: u32 = 1213;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_FRAGMENT: u32 = 1214;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_RELIABILITY_BOX: u32 = 1216;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_RELIABILITY_ACK: u32 = 1217;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_DV_LEARN: u32 = 1218;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_DV_BOX: u32 = 1219;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_COMMUNICATOR_BACKCHANNEL_INCOMING: u32 = 1220;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_FLOW_CONTROL: u32 = 1221;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_QUEUE_UPDATE: u32 = 1222;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_START: u32 = 1250;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_DATA: u32 = 1251;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_MONITOR_END: u32 = 1252;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_COMMUNICATOR_KX_CONFIRMATION: u32 = 1275;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_COMMUNICATOR_FC_LIMITS: u32 = 1276;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SUGGEST: u32 = 1300;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_SUGGEST_CANCEL: u32 = 1301;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_REQUEST_HELLO_VALIDATION: u32 = 1302;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_ADDRESS_VALIDATION_CHALLENGE: u32 = 1303;
pub const GNUNET_MESSAGE_TYPE_TRANSPORT_ADDRESS_VALIDATION_RESPONSE: u32 = 1304;
pub const GNUNET_MESSAGE_TYPE_ATS_SUGGEST: u32 = 1400;
pub const GNUNET_MESSAGE_TYPE_ATS_SUGGEST_CANCEL: u32 = 1401;
pub const GNUNET_MESSAGE_TYPE_ATS_SESSION_ADD: u32 = 1402;
pub const GNUNET_MESSAGE_TYPE_ATS_SESSION_ADD_INBOUND_ONLY: u32 = 1403;
pub const GNUNET_MESSAGE_TYPE_ATS_SESSION_UPDATE: u32 = 1404;
pub const GNUNET_MESSAGE_TYPE_ATS_SESSION_DEL: u32 = 1405;
pub const GNUNET_MESSAGE_TYPE_ATS_SESSION_ALLOCATION: u32 = 1406;
pub const GNUNET_MESSAGE_TYPE_COMMUNICATOR_TCP_REKEY: u32 = 1450;
pub const GNUNET_MESSAGE_TYPE_COMMUNICATOR_TCP_BOX: u32 = 1451;
pub const GNUNET_MESSAGE_TYPE_COMMUNICATOR_TCP_FINISH: u32 = 1452;
pub const GNUNET_MESSAGE_TYPE_COMMUNICATOR_TCP_CONFIRMATION_ACK: u32 = 1453;
pub const GNUNET_MESSAGE_TYPE_COMMUNICATOR_UDP_ACK: u32 = 1460;
pub const GNUNET_MESSAGE_TYPE_COMMUNICATOR_UDP_PAD: u32 = 1461;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_REFERENCE_DELETE: u32 = 1500;
pub const GNUNET_MESSAGE_TYPE_RECLAIM_REFERENCE_RESULT: u32 = 1501;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_CREATE: u32 = 1600;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_UPDATE: u32 = 1601;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_DESTROY: u32 = 1602;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_GET_NAME: u32 = 1603;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_SET_NAME: u32 = 1604;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_GET_KEY: u32 = 1605;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_CONNECTION_MEMBER_ID: u32 = 1606;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_ROOM_OPEN: u32 = 1610;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_ROOM_ENTRY: u32 = 1611;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_ROOM_CLOSE: u32 = 1612;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_ROOM_SEND_MESSAGE: u32 = 1614;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_ROOM_RECV_MESSAGE: u32 = 1615;
pub const GNUNET_MESSAGE_TYPE_MESSENGER_ROOM_GET_MESSAGE: u32 = 1616;
pub const GNUNET_MESSAGE_TYPE_ALL: u32 = 65535;
pub const __NETINET_IP_H: u32 = 1;
pub const IP_RF: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFMASK: u32 = 8191;
pub const IPVERSION: u32 = 4;
pub const IP_MAXPACKET: u32 = 65535;
pub const IPTOS_ECN_MASK: u32 = 3;
pub const IPTOS_ECN_NOT_ECT: u32 = 0;
pub const IPTOS_ECN_ECT1: u32 = 1;
pub const IPTOS_ECN_ECT0: u32 = 2;
pub const IPTOS_ECN_CE: u32 = 3;
pub const IPTOS_DSCP_MASK: u32 = 252;
pub const IPTOS_DSCP_AF11: u32 = 40;
pub const IPTOS_DSCP_AF12: u32 = 48;
pub const IPTOS_DSCP_AF13: u32 = 56;
pub const IPTOS_DSCP_AF21: u32 = 72;
pub const IPTOS_DSCP_AF22: u32 = 80;
pub const IPTOS_DSCP_AF23: u32 = 88;
pub const IPTOS_DSCP_AF31: u32 = 104;
pub const IPTOS_DSCP_AF32: u32 = 112;
pub const IPTOS_DSCP_AF33: u32 = 120;
pub const IPTOS_DSCP_AF41: u32 = 136;
pub const IPTOS_DSCP_AF42: u32 = 144;
pub const IPTOS_DSCP_AF43: u32 = 152;
pub const IPTOS_DSCP_EF: u32 = 184;
pub const IPTOS_CLASS_MASK: u32 = 224;
pub const IPTOS_CLASS_CS0: u32 = 0;
pub const IPTOS_CLASS_CS1: u32 = 32;
pub const IPTOS_CLASS_CS2: u32 = 64;
pub const IPTOS_CLASS_CS3: u32 = 96;
pub const IPTOS_CLASS_CS4: u32 = 128;
pub const IPTOS_CLASS_CS5: u32 = 160;
pub const IPTOS_CLASS_CS6: u32 = 192;
pub const IPTOS_CLASS_CS7: u32 = 224;
pub const IPTOS_CLASS_DEFAULT: u32 = 0;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_LOWCOST: u32 = 2;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IPOPT_COPY: u32 = 128;
pub const IPOPT_CLASS_MASK: u32 = 96;
pub const IPOPT_NUMBER_MASK: u32 = 31;
pub const IPOPT_CONTROL: u32 = 0;
pub const IPOPT_RESERVED1: u32 = 32;
pub const IPOPT_DEBMEAS: u32 = 64;
pub const IPOPT_MEASUREMENT: u32 = 64;
pub const IPOPT_RESERVED2: u32 = 96;
pub const IPOPT_EOL: u32 = 0;
pub const IPOPT_END: u32 = 0;
pub const IPOPT_NOP: u32 = 1;
pub const IPOPT_NOOP: u32 = 1;
pub const IPOPT_RR: u32 = 7;
pub const IPOPT_TS: u32 = 68;
pub const IPOPT_TIMESTAMP: u32 = 68;
pub const IPOPT_SECURITY: u32 = 130;
pub const IPOPT_SEC: u32 = 130;
pub const IPOPT_LSRR: u32 = 131;
pub const IPOPT_SATID: u32 = 136;
pub const IPOPT_SID: u32 = 136;
pub const IPOPT_SSRR: u32 = 137;
pub const IPOPT_RA: u32 = 148;
pub const IPOPT_OPTVAL: u32 = 0;
pub const IPOPT_OLEN: u32 = 1;
pub const IPOPT_OFFSET: u32 = 2;
pub const IPOPT_MINOFF: u32 = 4;
pub const MAX_IPOPTLEN: u32 = 40;
pub const IPOPT_TS_TSONLY: u32 = 0;
pub const IPOPT_TS_TSANDADDR: u32 = 1;
pub const IPOPT_TS_PRESPEC: u32 = 3;
pub const IPOPT_SECUR_UNCLASS: u32 = 0;
pub const IPOPT_SECUR_CONFID: u32 = 61749;
pub const IPOPT_SECUR_EFTO: u32 = 30874;
pub const IPOPT_SECUR_MMMM: u32 = 48205;
pub const IPOPT_SECUR_RESTR: u32 = 44819;
pub const IPOPT_SECUR_SECRET: u32 = 55176;
pub const IPOPT_SECUR_TOPSECRET: u32 = 27589;
pub const MAXTTL: u32 = 255;
pub const IPDEFTTL: u32 = 64;
pub const IPFRAGTTL: u32 = 60;
pub const IPTTLDEC: u32 = 1;
pub const IP_MSS: u32 = 576;
pub const ETH_P_IPV4: u32 = 2048;
pub const ETH_P_IPV6: u32 = 34525;
pub const GNUNET_TUN_IPV4_REGEXLEN: u32 = 16;
pub const GNUNET_TUN_IPV6_REGEXLEN: u32 = 40;
pub const GNUNET_TUN_TCP_FLAGS_FIN: u32 = 1;
pub const GNUNET_TUN_TCP_FLAGS_SYN: u32 = 2;
pub const GNUNET_TUN_TCP_FLAGS_RST: u32 = 4;
pub const GNUNET_TUN_TCP_FLAGS_PSH: u32 = 8;
pub const GNUNET_TUN_TCP_FLAGS_ACK: u32 = 16;
pub const GNUNET_TUN_TCP_FLAGS_URG: u32 = 32;
pub const GNUNET_TUN_TCP_FLAGS_ECE: u32 = 64;
pub const GNUNET_TUN_TCP_FLAGS_CWR: u32 = 128;
pub const GNUNET_TUN_DNS_CLASS_INTERNET: u32 = 1;
pub const GNUNET_TUN_DNS_CLASS_CHAOS: u32 = 3;
pub const GNUNET_TUN_DNS_CLASS_HESIOD: u32 = 4;
pub const GNUNET_TUN_DNS_OPCODE_QUERY: u32 = 0;
pub const GNUNET_TUN_DNS_OPCODE_INVERSE_QUERY: u32 = 1;
pub const GNUNET_TUN_DNS_OPCODE_STATUS: u32 = 2;
pub const GNUNET_TUN_DNS_RETURN_CODE_NO_ERROR: u32 = 0;
pub const GNUNET_TUN_DNS_RETURN_CODE_FORMAT_ERROR: u32 = 1;
pub const GNUNET_TUN_DNS_RETURN_CODE_SERVER_FAILURE: u32 = 2;
pub const GNUNET_TUN_DNS_RETURN_CODE_NAME_ERROR: u32 = 3;
pub const GNUNET_TUN_DNS_RETURN_CODE_NOT_IMPLEMENTED: u32 = 4;
pub const GNUNET_TUN_DNS_RETURN_CODE_REFUSED: u32 = 5;
pub const GNUNET_TUN_DNS_RETURN_CODE_YXDOMAIN: u32 = 6;
pub const GNUNET_TUN_DNS_RETURN_CODE_YXRRSET: u32 = 7;
pub const GNUNET_TUN_DNS_RETURN_CODE_NXRRSET: u32 = 8;
pub const GNUNET_TUN_DNS_RETURN_CODE_NOT_AUTH: u32 = 9;
pub const GNUNET_TUN_DNS_RETURN_CODE_NOT_ZONE: u32 = 10;
pub const GNUNET_TUN_ICMPTYPE_ECHO_REPLY: u32 = 0;
pub const GNUNET_TUN_ICMPTYPE_DESTINATION_UNREACHABLE: u32 = 3;
pub const GNUNET_TUN_ICMPTYPE_SOURCE_QUENCH: u32 = 4;
pub const GNUNET_TUN_ICMPTYPE_REDIRECT_MESSAGE: u32 = 5;
pub const GNUNET_TUN_ICMPTYPE_ECHO_REQUEST: u32 = 8;
pub const GNUNET_TUN_ICMPTYPE_ROUTER_ADVERTISEMENT: u32 = 9;
pub const GNUNET_TUN_ICMPTYPE_ROUTER_SOLICITATION: u32 = 10;
pub const GNUNET_TUN_ICMPTYPE_TIME_EXCEEDED: u32 = 11;
pub const GNUNET_TUN_ICMPTYPE6_DESTINATION_UNREACHABLE: u32 = 1;
pub const GNUNET_TUN_ICMPTYPE6_PACKET_TOO_BIG: u32 = 2;
pub const GNUNET_TUN_ICMPTYPE6_TIME_EXCEEDED: u32 = 3;
pub const GNUNET_TUN_ICMPTYPE6_PARAMETER_PROBLEM: u32 = 4;
pub const GNUNET_TUN_ICMPTYPE6_ECHO_REQUEST: u32 = 128;
pub const GNUNET_TUN_ICMPTYPE6_ECHO_REPLY: u32 = 129;
pub const GNUNET_DNSPARSER_MAX_LABEL_LENGTH: u32 = 63;
pub const GNUNET_DNSPARSER_MAX_NAME_LENGTH: u32 = 253;
pub const GNUNET_DNSPARSER_TYPE_ANY: u32 = 0;
pub const GNUNET_DNSPARSER_TYPE_A: u32 = 1;
pub const GNUNET_DNSPARSER_TYPE_NS: u32 = 2;
pub const GNUNET_DNSPARSER_TYPE_CNAME: u32 = 5;
pub const GNUNET_DNSPARSER_TYPE_SOA: u32 = 6;
pub const GNUNET_DNSPARSER_TYPE_PTR: u32 = 12;
pub const GNUNET_DNSPARSER_TYPE_MX: u32 = 15;
pub const GNUNET_DNSPARSER_TYPE_TXT: u32 = 16;
pub const GNUNET_DNSPARSER_TYPE_RP: u32 = 17;
pub const GNUNET_DNSPARSER_TYPE_AFSDB: u32 = 18;
pub const GNUNET_DNSPARSER_TYPE_SIG: u32 = 24;
pub const GNUNET_DNSPARSER_TYPE_KEY: u32 = 25;
pub const GNUNET_DNSPARSER_TYPE_AAAA: u32 = 28;
pub const GNUNET_DNSPARSER_TYPE_LOC: u32 = 29;
pub const GNUNET_DNSPARSER_TYPE_SRV: u32 = 33;
pub const GNUNET_DNSPARSER_TYPE_NAPTR: u32 = 35;
pub const GNUNET_DNSPARSER_TYPE_KX: u32 = 36;
pub const GNUNET_DNSPARSER_TYPE_CERT: u32 = 37;
pub const GNUNET_DNSPARSER_TYPE_DNAME: u32 = 39;
pub const GNUNET_DNSPARSER_TYPE_APL: u32 = 42;
pub const GNUNET_DNSPARSER_TYPE_DS: u32 = 43;
pub const GNUNET_DNSPARSER_TYPE_SSHFP: u32 = 44;
pub const GNUNET_DNSPARSER_TYPE_IPSECKEY: u32 = 45;
pub const GNUNET_DNSPARSER_TYPE_RRSIG: u32 = 46;
pub const GNUNET_DNSPARSER_TYPE_NSEC: u32 = 47;
pub const GNUNET_DNSPARSER_TYPE_DNSKEY: u32 = 48;
pub const GNUNET_DNSPARSER_TYPE_DHCID: u32 = 49;
pub const GNUNET_DNSPARSER_TYPE_NSEC3: u32 = 50;
pub const GNUNET_DNSPARSER_TYPE_NSEC3PARAM: u32 = 51;
pub const GNUNET_DNSPARSER_TYPE_TLSA: u32 = 52;
pub const GNUNET_DNSPARSER_TYPE_HIP: u32 = 55;
pub const GNUNET_DNSPARSER_TYPE_CDS: u32 = 59;
pub const GNUNET_DNSPARSER_TYPE_CDNSKEY: u32 = 60;
pub const GNUNET_DNSPARSER_TYPE_OPENPGPKEY: u32 = 61;
pub const GNUNET_DNSPARSER_TYPE_TKEY: u32 = 249;
pub const GNUNET_DNSPARSER_TYPE_TSIG: u32 = 250;
pub const GNUNET_DNSPARSER_TYPE_ALL: u32 = 255;
pub const GNUNET_DNSPARSER_TYPE_URI: u32 = 256;
pub const GNUNET_DNSPARSER_TYPE_CAA: u32 = 257;
pub const GNUNET_DNSPARSER_TYPE_TA: u32 = 32768;
pub const GNUNET_HELLO_URI_PREFIX: &'static [u8; 16usize] = b"gnunet://hello/\0";
pub const GNUNET_FRIEND_HELLO_URI_PREFIX: &'static [u8; 23usize] = b"gnunet://friend-hello/\0";
pub const GNUNET_HELLO_URI_SEP: u8 = 43u8;
pub const GNUNET_NT_COUNT: u32 = 6;
pub const GNUNET_ATS_DefaultBandwidth: u32 = 65536;
pub const GNUNET_ATS_VALUE_UNDEFINED: u32 = 4294967295;
pub const GNUNET_ATS_VALUE_UNDEFINED_STR: &'static [u8; 10usize] = b"undefined\0";
pub const GNUNET_ATS_MaxBandwidth: u32 = 4294967295;
pub const GNUNET_ATS_MaxBandwidthString: &'static [u8; 10usize] = b"unlimited\0";
pub const GNUNET_SIGNATURE_PURPOSE_TEST: u32 = 0;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_PONG_OWN: u32 = 1;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_DISCONNECT: u32 = 2;
pub const GNUNET_SIGNATURE_PURPOSE_REVOCATION: u32 = 3;
pub const GNUNET_SIGNATURE_PURPOSE_NAMESPACE_ADVERTISEMENT: u32 = 4;
pub const GNUNET_SIGNATURE_PURPOSE_PEER_PLACEMENT: u32 = 5;
pub const GNUNET_SIGNATURE_PURPOSE_FS_KBLOCK: u32 = 6;
pub const GNUNET_SIGNATURE_PURPOSE_FS_SBLOCK: u32 = 7;
pub const GNUNET_SIGNATURE_PURPOSE_FS_NBLOCK: u32 = 8;
pub const GNUNET_SIGNATURE_PURPOSE_FS_NBLOCK_KSIG: u32 = 9;
pub const GNUNET_SIGNATURE_PURPOSE_RESOLVER_RESPONSE: u32 = 10;
pub const GNUNET_SIGNATURE_PURPOSE_DNS_RECORD: u32 = 11;
pub const GNUNET_SIGNATURE_PURPOSE_CHAT_MESSAGE: u32 = 12;
pub const GNUNET_SIGNATURE_PURPOSE_CHAT_RECEIPT: u32 = 13;
pub const GNUNET_SIGNATURE_PURPOSE_NSE_SEND: u32 = 14;
pub const GNUNET_SIGNATURE_PURPOSE_GNS_RECORD_SIGN: u32 = 15;
pub const GNUNET_SIGNATURE_PURPOSE_SET_ECC_KEY: u32 = 16;
pub const GNUNET_SIGNATURE_PURPOSE_FS_UBLOCK: u32 = 17;
pub const GNUNET_SIGNATURE_PURPOSE_REGEX_ACCEPT: u32 = 18;
pub const GNUNET_SIGNATURE_PURPOSE_MULTICAST_MESSAGE: u32 = 19;
pub const GNUNET_SIGNATURE_PURPOSE_CONVERSATION_RING: u32 = 20;
pub const GNUNET_SIGNATURE_PURPOSE_SECRETSHARING_DKG1: u32 = 21;
pub const GNUNET_SIGNATURE_PURPOSE_SECRETSHARING_DKG2: u32 = 22;
pub const GNUNET_SIGNATURE_PURPOSE_SECRETSHARING_DECRYPTION: u32 = 23;
pub const GNUNET_SIGNATURE_PURPOSE_MULTICAST_REQUEST: u32 = 24;
pub const GNUNET_SIGNATURE_PURPOSE_SENSOR_ANOMALY_REPORT: u32 = 25;
pub const GNUNET_SIGNATURE_PURPOSE_GNUID_TOKEN: u32 = 26;
pub const GNUNET_SIGNATURE_PURPOSE_RECLAIM_CODE_SIGN: u32 = 27;
pub const GNUNET_SIGNATURE_PURPOSE_DELEGATE: u32 = 28;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_ADDRESS: u32 = 29;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_EPHEMERAL: u32 = 30;
pub const GNUNET_SIGNATURE_COMMUNICATOR_TCP_HANDSHAKE: u32 = 31;
pub const GNUNET_SIGNATURE_COMMUNICATOR_TCP_REKEY: u32 = 32;
pub const GNUNET_SIGNATURE_COMMUNICATOR_UDP_HANDSHAKE: u32 = 33;
pub const GNUNET_SIGNATURE_COMMUNICATOR_UDP_BROADCAST: u32 = 34;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_CHALLENGE: u32 = 35;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_DV_HOP: u32 = 36;
pub const GNUNET_SIGNATURE_PURPOSE_TRANSPORT_DV_INITIATOR: u32 = 37;
pub const GNUNET_SIGNATURE_PURPOSE_CADET_CONNECTION_INITIATOR: u32 = 38;
pub const GNUNET_SIGNATURE_COMMUNICATOR_TCP_HANDSHAKE_ACK: u32 = 39;
pub const GNUNET_TRANSPORT_VERSION: u32 = 3;
pub const GNUNET_CORE_VERSION: u32 = 1;
pub const GNUNET_IDENTITY_VERSION: u32 = 256;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn sodium_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn sodium_library_version_major() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_library_version_minor() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_library_minimal() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_set_misuse_handler(
        handler: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_misuse();
}
extern "C" {
    pub fn crypto_aead_aes256gcm_is_available() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_nsecbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_npubbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_abytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_messagebytes_max() -> usize;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct crypto_aead_aes256gcm_state_ {
    pub opaque: [::std::os::raw::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_crypto_aead_aes256gcm_state_() {
    assert_eq!(
        ::std::mem::size_of::<crypto_aead_aes256gcm_state_>(),
        512usize,
        concat!("Size of: ", stringify!(crypto_aead_aes256gcm_state_))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_aead_aes256gcm_state_>(),
        16usize,
        concat!("Alignment of ", stringify!(crypto_aead_aes256gcm_state_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_aead_aes256gcm_state_>())).opaque as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_aead_aes256gcm_state_),
            "::",
            stringify!(opaque)
        )
    );
}
pub type crypto_aead_aes256gcm_state = crypto_aead_aes256gcm_state_;
extern "C" {
    pub fn crypto_aead_aes256gcm_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_encrypt(
        c: *mut ::std::os::raw::c_uchar,
        clen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_decrypt(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_encrypt_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        maclen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_decrypt_detached(
        m: *mut ::std::os::raw::c_uchar,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        mac: *const ::std::os::raw::c_uchar,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_beforenm(
        ctx_: *mut crypto_aead_aes256gcm_state,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_encrypt_afternm(
        c: *mut ::std::os::raw::c_uchar,
        clen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        ctx_: *const crypto_aead_aes256gcm_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_decrypt_afternm(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        ctx_: *const crypto_aead_aes256gcm_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_encrypt_detached_afternm(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        maclen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        ctx_: *const crypto_aead_aes256gcm_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_decrypt_detached_afternm(
        m: *mut ::std::os::raw::c_uchar,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        mac: *const ::std::os::raw::c_uchar,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        ctx_: *const crypto_aead_aes256gcm_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_aes256gcm_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_nsecbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_npubbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_abytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_encrypt(
        c: *mut ::std::os::raw::c_uchar,
        clen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_decrypt(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_encrypt_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        maclen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_decrypt_detached(
        m: *mut ::std::os::raw::c_uchar,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        mac: *const ::std::os::raw::c_uchar,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_ietf_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_nsecbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_npubbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_abytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_encrypt(
        c: *mut ::std::os::raw::c_uchar,
        clen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_decrypt(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_encrypt_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        maclen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_decrypt_detached(
        m: *mut ::std::os::raw::c_uchar,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        mac: *const ::std::os::raw::c_uchar,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_chacha20poly1305_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_nsecbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_npubbytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_abytes() -> usize;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_encrypt(
        c: *mut ::std::os::raw::c_uchar,
        clen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_decrypt(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_encrypt_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        maclen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        nsec: *const ::std::os::raw::c_uchar,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_decrypt_detached(
        m: *mut ::std::os::raw::c_uchar,
        nsec: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        mac: *const ::std::os::raw::c_uchar,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        npub: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_aead_xchacha20poly1305_ietf_keygen(k: *mut ::std::os::raw::c_uchar);
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtof32(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> _Float64x;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strfromd(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfroml(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: u128,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf32(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf64(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf32x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float32x,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfromf64x(
        __dest: *mut ::std::os::raw::c_char,
        __size: usize,
        __format: *const ::std::os::raw::c_char,
        __f: _Float64x,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
        __loc: locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtof_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtold_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> u128;
}
extern "C" {
    pub fn strtof32_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32;
}
extern "C" {
    pub fn strtof64_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64;
}
extern "C" {
    pub fn strtof32x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float32x;
}
extern "C" {
    pub fn strtof64x_l(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> _Float64x;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp64(
        __template: *mut ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(
        __name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_hash_sha512_state {
    pub state: [u64; 8usize],
    pub count: [u64; 2usize],
    pub buf: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_crypto_hash_sha512_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_hash_sha512_state>(),
        208usize,
        concat!("Size of: ", stringify!(crypto_hash_sha512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_hash_sha512_state>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_hash_sha512_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_hash_sha512_state>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_hash_sha512_state),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_hash_sha512_state>())).count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_hash_sha512_state),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_hash_sha512_state>())).buf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_hash_sha512_state),
            "::",
            stringify!(buf)
        )
    );
}
extern "C" {
    pub fn crypto_hash_sha512_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_hash_sha512_bytes() -> usize;
}
extern "C" {
    pub fn crypto_hash_sha512(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_sha512_init(state: *mut crypto_hash_sha512_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_sha512_update(
        state: *mut crypto_hash_sha512_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_sha512_final(
        state: *mut crypto_hash_sha512_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_bytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha512(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_verify(
        h: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_auth_hmacsha512_state {
    pub ictx: crypto_hash_sha512_state,
    pub octx: crypto_hash_sha512_state,
}
#[test]
fn bindgen_test_layout_crypto_auth_hmacsha512_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_auth_hmacsha512_state>(),
        416usize,
        concat!("Size of: ", stringify!(crypto_auth_hmacsha512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_auth_hmacsha512_state>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_auth_hmacsha512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_auth_hmacsha512_state>())).ictx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_auth_hmacsha512_state),
            "::",
            stringify!(ictx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_auth_hmacsha512_state>())).octx as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_auth_hmacsha512_state),
            "::",
            stringify!(octx)
        )
    );
}
extern "C" {
    pub fn crypto_auth_hmacsha512_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_init(
        state: *mut crypto_auth_hmacsha512_state,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_update(
        state: *mut crypto_auth_hmacsha512_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_final(
        state: *mut crypto_auth_hmacsha512_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_bytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_verify(
        h: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
pub type crypto_auth_hmacsha512256_state = crypto_auth_hmacsha512_state;
extern "C" {
    pub fn crypto_auth_hmacsha512256_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_init(
        state: *mut crypto_auth_hmacsha512256_state,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_update(
        state: *mut crypto_auth_hmacsha512256_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_final(
        state: *mut crypto_auth_hmacsha512256_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha512256_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_auth_bytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_auth(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_verify(
        h: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_keygen(k: *mut ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_hash_sha256_state {
    pub state: [u32; 8usize],
    pub count: u64,
    pub buf: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_crypto_hash_sha256_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_hash_sha256_state>(),
        104usize,
        concat!("Size of: ", stringify!(crypto_hash_sha256_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_hash_sha256_state>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_hash_sha256_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_hash_sha256_state>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_hash_sha256_state),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_hash_sha256_state>())).count as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_hash_sha256_state),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_hash_sha256_state>())).buf as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_hash_sha256_state),
            "::",
            stringify!(buf)
        )
    );
}
extern "C" {
    pub fn crypto_hash_sha256_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_hash_sha256_bytes() -> usize;
}
extern "C" {
    pub fn crypto_hash_sha256(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_sha256_init(state: *mut crypto_hash_sha256_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_sha256_update(
        state: *mut crypto_hash_sha256_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_sha256_final(
        state: *mut crypto_hash_sha256_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_bytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha256(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_verify(
        h: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_auth_hmacsha256_state {
    pub ictx: crypto_hash_sha256_state,
    pub octx: crypto_hash_sha256_state,
}
#[test]
fn bindgen_test_layout_crypto_auth_hmacsha256_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_auth_hmacsha256_state>(),
        208usize,
        concat!("Size of: ", stringify!(crypto_auth_hmacsha256_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_auth_hmacsha256_state>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_auth_hmacsha256_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_auth_hmacsha256_state>())).ictx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_auth_hmacsha256_state),
            "::",
            stringify!(ictx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_auth_hmacsha256_state>())).octx as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_auth_hmacsha256_state),
            "::",
            stringify!(octx)
        )
    );
}
extern "C" {
    pub fn crypto_auth_hmacsha256_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_init(
        state: *mut crypto_auth_hmacsha256_state,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_update(
        state: *mut crypto_auth_hmacsha256_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_final(
        state: *mut crypto_auth_hmacsha256_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_auth_hmacsha256_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_stream_xsalsa20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_xsalsa20_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_xsalsa20_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_xsalsa20(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xsalsa20_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xsalsa20_xor_ic(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        ic: u64,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xsalsa20_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_seedbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_publickeybytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_secretkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_beforenmbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_macbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_seed_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
        seed: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_beforenm(
        k: *mut ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_boxzerobytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_zerobytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_open(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_afternm(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xsalsa20poly1305_open_afternm(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_seedbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_publickeybytes() -> usize;
}
extern "C" {
    pub fn crypto_box_secretkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_box_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_box_macbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_box_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_box_seed_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
        seed: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_easy(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_open_easy(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_open_detached(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        mac: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_beforenmbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_beforenm(
        k: *mut ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_easy_afternm(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_open_easy_afternm(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_detached_afternm(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_open_detached_afternm(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        mac: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_sealbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_seal(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_seal_open(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_zerobytes() -> usize;
}
extern "C" {
    pub fn crypto_box_boxzerobytes() -> usize;
}
extern "C" {
    pub fn crypto_box(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_open(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_afternm(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_open_afternm(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_hsalsa20_outputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hsalsa20_inputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hsalsa20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hsalsa20_constbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hsalsa20(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_hchacha20_outputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hchacha20_inputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hchacha20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hchacha20_constbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_hchacha20(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_salsa20_outputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa20_inputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa20_constbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa20(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_salsa2012_outputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa2012_inputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa2012_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa2012_constbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa2012(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_salsa208_outputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa208_inputbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa208_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa208_constbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_salsa208(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct crypto_generichash_blake2b_state {
    pub opaque: [::std::os::raw::c_uchar; 384usize],
}
#[test]
fn bindgen_test_layout_crypto_generichash_blake2b_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_generichash_blake2b_state>(),
        384usize,
        concat!("Size of: ", stringify!(crypto_generichash_blake2b_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_generichash_blake2b_state>(),
        64usize,
        concat!(
            "Alignment of ",
            stringify!(crypto_generichash_blake2b_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_generichash_blake2b_state>())).opaque as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_generichash_blake2b_state),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    pub fn crypto_generichash_blake2b_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_bytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_keybytes_min() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_keybytes_max() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_saltbytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_personalbytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_blake2b(
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_blake2b_salt_personal(
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
        salt: *const ::std::os::raw::c_uchar,
        personal: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_blake2b_init(
        state: *mut crypto_generichash_blake2b_state,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_blake2b_init_salt_personal(
        state: *mut crypto_generichash_blake2b_state,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
        outlen: usize,
        salt: *const ::std::os::raw::c_uchar,
        personal: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_blake2b_update(
        state: *mut crypto_generichash_blake2b_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_blake2b_final(
        state: *mut crypto_generichash_blake2b_state,
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_blake2b_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_generichash_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_generichash_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_generichash_bytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_keybytes_min() -> usize;
}
extern "C" {
    pub fn crypto_generichash_keybytes_max() -> usize;
}
extern "C" {
    pub fn crypto_generichash_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash_primitive() -> *const ::std::os::raw::c_char;
}
pub type crypto_generichash_state = crypto_generichash_blake2b_state;
extern "C" {
    pub fn crypto_generichash_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_generichash(
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_init(
        state: *mut crypto_generichash_state,
        key: *const ::std::os::raw::c_uchar,
        keylen: usize,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_update(
        state: *mut crypto_generichash_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_final(
        state: *mut crypto_generichash_state,
        out: *mut ::std::os::raw::c_uchar,
        outlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_generichash_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_hash_bytes() -> usize;
}
extern "C" {
    pub fn crypto_hash(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_hash_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_kdf_blake2b_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_kdf_blake2b_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_kdf_blake2b_contextbytes() -> usize;
}
extern "C" {
    pub fn crypto_kdf_blake2b_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_kdf_blake2b_derive_from_key(
        subkey: *mut ::std::os::raw::c_uchar,
        subkey_len: usize,
        subkey_id: u64,
        ctx: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_kdf_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_kdf_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_kdf_contextbytes() -> usize;
}
extern "C" {
    pub fn crypto_kdf_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_kdf_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_kdf_derive_from_key(
        subkey: *mut ::std::os::raw::c_uchar,
        subkey_len: usize,
        subkey_id: u64,
        ctx: *const ::std::os::raw::c_char,
        key: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_kdf_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_kx_publickeybytes() -> usize;
}
extern "C" {
    pub fn crypto_kx_secretkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_kx_seedbytes() -> usize;
}
extern "C" {
    pub fn crypto_kx_sessionkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_kx_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_kx_seed_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
        seed: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_kx_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_kx_client_session_keys(
        rx: *mut ::std::os::raw::c_uchar,
        tx: *mut ::std::os::raw::c_uchar,
        client_pk: *const ::std::os::raw::c_uchar,
        client_sk: *const ::std::os::raw::c_uchar,
        server_pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_kx_server_session_keys(
        rx: *mut ::std::os::raw::c_uchar,
        tx: *mut ::std::os::raw::c_uchar,
        server_pk: *const ::std::os::raw::c_uchar,
        server_sk: *const ::std::os::raw::c_uchar,
        client_pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct crypto_onetimeauth_poly1305_state {
    pub opaque: [::std::os::raw::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_crypto_onetimeauth_poly1305_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_onetimeauth_poly1305_state>(),
        256usize,
        concat!("Size of: ", stringify!(crypto_onetimeauth_poly1305_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_onetimeauth_poly1305_state>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(crypto_onetimeauth_poly1305_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_onetimeauth_poly1305_state>())).opaque as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_onetimeauth_poly1305_state),
            "::",
            stringify!(opaque)
        )
    );
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_bytes() -> usize;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_verify(
        h: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_init(
        state: *mut crypto_onetimeauth_poly1305_state,
        key: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_update(
        state: *mut crypto_onetimeauth_poly1305_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_final(
        state: *mut crypto_onetimeauth_poly1305_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_poly1305_keygen(k: *mut ::std::os::raw::c_uchar);
}
pub type crypto_onetimeauth_state = crypto_onetimeauth_poly1305_state;
extern "C" {
    pub fn crypto_onetimeauth_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_onetimeauth_bytes() -> usize;
}
extern "C" {
    pub fn crypto_onetimeauth_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_onetimeauth_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_onetimeauth(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_verify(
        h: *const ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_init(
        state: *mut crypto_onetimeauth_state,
        key: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_update(
        state: *mut crypto_onetimeauth_state,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_final(
        state: *mut crypto_onetimeauth_state,
        out: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_onetimeauth_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_pwhash_argon2i_alg_argon2i13() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_passwd_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_passwd_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_saltbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_strbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_strprefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_opslimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_opslimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_memlimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_memlimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_opslimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_memlimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_opslimit_moderate() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_memlimit_moderate() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_opslimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_memlimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2i(
        out: *mut ::std::os::raw::c_uchar,
        outlen: ::std::os::raw::c_ulonglong,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        salt: *const ::std::os::raw::c_uchar,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
        alg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_str(
        out: *mut ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_str_verify(
        str_: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2i_str_needs_rehash(
        str_: *const ::std::os::raw::c_char,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_alg_argon2id13() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_passwd_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_passwd_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_saltbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_strbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_strprefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_opslimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_opslimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_memlimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_memlimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_opslimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_memlimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_opslimit_moderate() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_memlimit_moderate() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_opslimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_memlimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_argon2id(
        out: *mut ::std::os::raw::c_uchar,
        outlen: ::std::os::raw::c_ulonglong,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        salt: *const ::std::os::raw::c_uchar,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
        alg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_str(
        out: *mut ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_str_verify(
        str_: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_argon2id_str_needs_rehash(
        str_: *const ::std::os::raw::c_char,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_alg_argon2i13() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_alg_argon2id13() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_alg_default() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_passwd_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_passwd_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_saltbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_strbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_strprefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_pwhash_opslimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_opslimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_memlimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_memlimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_opslimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_memlimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_opslimit_moderate() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_memlimit_moderate() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_opslimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_memlimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash(
        out: *mut ::std::os::raw::c_uchar,
        outlen: ::std::os::raw::c_ulonglong,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        salt: *const ::std::os::raw::c_uchar,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
        alg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_str(
        out: *mut ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_str_alg(
        out: *mut ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
        alg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_str_verify(
        str_: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_str_needs_rehash(
        str_: *const ::std::os::raw::c_char,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_scalarmult_curve25519_bytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_curve25519_scalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_curve25519(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_curve25519_base(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_bytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_scalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_scalarmult_base(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_macbytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_open(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_boxzerobytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xsalsa20poly1305_zerobytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_macbytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_secretbox_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_easy(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_open_easy(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_open_detached(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        mac: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_secretbox_zerobytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_boxzerobytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_open(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_chacha20_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_chacha20_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_chacha20(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_xor_ic(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        ic: u64,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf_xor_ic(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        ic: u32,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_chacha20_ietf_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_abytes() -> usize;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_headerbytes() -> usize;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_tag_message() -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_tag_push() -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_tag_rekey() -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_tag_final() -> ::std::os::raw::c_uchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_secretstream_xchacha20poly1305_state {
    pub k: [::std::os::raw::c_uchar; 32usize],
    pub nonce: [::std::os::raw::c_uchar; 12usize],
    pub _pad: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_crypto_secretstream_xchacha20poly1305_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_secretstream_xchacha20poly1305_state>(),
        52usize,
        concat!(
            "Size of: ",
            stringify!(crypto_secretstream_xchacha20poly1305_state)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_secretstream_xchacha20poly1305_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(crypto_secretstream_xchacha20poly1305_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_secretstream_xchacha20poly1305_state>())).k as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_secretstream_xchacha20poly1305_state),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_secretstream_xchacha20poly1305_state>())).nonce
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_secretstream_xchacha20poly1305_state),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crypto_secretstream_xchacha20poly1305_state>()))._pad as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_secretstream_xchacha20poly1305_state),
            "::",
            stringify!(_pad)
        )
    );
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_init_push(
        state: *mut crypto_secretstream_xchacha20poly1305_state,
        header: *mut ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_push(
        state: *mut crypto_secretstream_xchacha20poly1305_state,
        c: *mut ::std::os::raw::c_uchar,
        clen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
        tag: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_init_pull(
        state: *mut crypto_secretstream_xchacha20poly1305_state,
        header: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_pull(
        state: *mut crypto_secretstream_xchacha20poly1305_state,
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        tag_p: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        ad: *const ::std::os::raw::c_uchar,
        adlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretstream_xchacha20poly1305_rekey(
        state: *mut crypto_secretstream_xchacha20poly1305_state,
    );
}
extern "C" {
    pub fn crypto_shorthash_siphash24_bytes() -> usize;
}
extern "C" {
    pub fn crypto_shorthash_siphash24_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_shorthash_siphash24(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_shorthash_siphashx24_bytes() -> usize;
}
extern "C" {
    pub fn crypto_shorthash_siphashx24_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_shorthash_siphashx24(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_shorthash_bytes() -> usize;
}
extern "C" {
    pub fn crypto_shorthash_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_shorthash_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_shorthash(
        out: *mut ::std::os::raw::c_uchar,
        in_: *const ::std::os::raw::c_uchar,
        inlen: ::std::os::raw::c_ulonglong,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_shorthash_keygen(k: *mut ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct crypto_sign_ed25519ph_state {
    pub hs: crypto_hash_sha512_state,
}
#[test]
fn bindgen_test_layout_crypto_sign_ed25519ph_state() {
    assert_eq!(
        ::std::mem::size_of::<crypto_sign_ed25519ph_state>(),
        208usize,
        concat!("Size of: ", stringify!(crypto_sign_ed25519ph_state))
    );
    assert_eq!(
        ::std::mem::align_of::<crypto_sign_ed25519ph_state>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_sign_ed25519ph_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crypto_sign_ed25519ph_state>())).hs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_sign_ed25519ph_state),
            "::",
            stringify!(hs)
        )
    );
}
extern "C" {
    pub fn crypto_sign_ed25519ph_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_ed25519_bytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_ed25519_seedbytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_ed25519_publickeybytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_ed25519_secretkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_ed25519_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_sign_ed25519(
        sm: *mut ::std::os::raw::c_uchar,
        smlen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_open(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        sm: *const ::std::os::raw::c_uchar,
        smlen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_detached(
        sig: *mut ::std::os::raw::c_uchar,
        siglen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_verify_detached(
        sig: *const ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_seed_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
        seed: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_pk_to_curve25519(
        curve25519_pk: *mut ::std::os::raw::c_uchar,
        ed25519_pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_sk_to_curve25519(
        curve25519_sk: *mut ::std::os::raw::c_uchar,
        ed25519_sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_sk_to_seed(
        seed: *mut ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519_sk_to_pk(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519ph_init(
        state: *mut crypto_sign_ed25519ph_state,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519ph_update(
        state: *mut crypto_sign_ed25519ph_state,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519ph_final_create(
        state: *mut crypto_sign_ed25519ph_state,
        sig: *mut ::std::os::raw::c_uchar,
        siglen_p: *mut ::std::os::raw::c_ulonglong,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_ed25519ph_final_verify(
        state: *mut crypto_sign_ed25519ph_state,
        sig: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
pub type crypto_sign_state = crypto_sign_ed25519ph_state;
extern "C" {
    pub fn crypto_sign_statebytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_bytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_seedbytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_publickeybytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_secretkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_sign_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_sign_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_sign_seed_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
        seed: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign(
        sm: *mut ::std::os::raw::c_uchar,
        smlen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_open(
        m: *mut ::std::os::raw::c_uchar,
        mlen_p: *mut ::std::os::raw::c_ulonglong,
        sm: *const ::std::os::raw::c_uchar,
        smlen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_detached(
        sig: *mut ::std::os::raw::c_uchar,
        siglen_p: *mut ::std::os::raw::c_ulonglong,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_verify_detached(
        sig: *const ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_init(state: *mut crypto_sign_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_update(
        state: *mut crypto_sign_state,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_final_create(
        state: *mut crypto_sign_state,
        sig: *mut ::std::os::raw::c_uchar,
        siglen_p: *mut ::std::os::raw::c_ulonglong,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_sign_final_verify(
        state: *mut crypto_sign_state,
        sig: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_primitive() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_stream(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_stream_salsa20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa20_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa20_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa20(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa20_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa20_xor_ic(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        ic: u64,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa20_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_verify_16_bytes() -> usize;
}
extern "C" {
    pub fn crypto_verify_16(
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_verify_32_bytes() -> usize;
}
extern "C" {
    pub fn crypto_verify_32(
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_verify_64_bytes() -> usize;
}
extern "C" {
    pub fn crypto_verify_64(
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct randombytes_implementation {
    pub implementation_name:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    pub random: ::std::option::Option<unsafe extern "C" fn() -> u32>,
    pub stir: ::std::option::Option<unsafe extern "C" fn()>,
    pub uniform: ::std::option::Option<unsafe extern "C" fn(upper_bound: u32) -> u32>,
    pub buf:
        ::std::option::Option<unsafe extern "C" fn(buf: *mut ::std::os::raw::c_void, size: usize)>,
    pub close: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_randombytes_implementation() {
    assert_eq!(
        ::std::mem::size_of::<randombytes_implementation>(),
        48usize,
        concat!("Size of: ", stringify!(randombytes_implementation))
    );
    assert_eq!(
        ::std::mem::align_of::<randombytes_implementation>(),
        8usize,
        concat!("Alignment of ", stringify!(randombytes_implementation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<randombytes_implementation>())).implementation_name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(randombytes_implementation),
            "::",
            stringify!(implementation_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<randombytes_implementation>())).random as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(randombytes_implementation),
            "::",
            stringify!(random)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<randombytes_implementation>())).stir as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(randombytes_implementation),
            "::",
            stringify!(stir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<randombytes_implementation>())).uniform as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(randombytes_implementation),
            "::",
            stringify!(uniform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<randombytes_implementation>())).buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(randombytes_implementation),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<randombytes_implementation>())).close as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(randombytes_implementation),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    pub fn randombytes_seedbytes() -> usize;
}
extern "C" {
    pub fn randombytes_buf(buf: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn randombytes_buf_deterministic(
        buf: *mut ::std::os::raw::c_void,
        size: usize,
        seed: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn randombytes_random() -> u32;
}
extern "C" {
    pub fn randombytes_uniform(upper_bound: u32) -> u32;
}
extern "C" {
    pub fn randombytes_stir();
}
extern "C" {
    pub fn randombytes_close() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn randombytes_set_implementation(
        impl_: *mut randombytes_implementation,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn randombytes_implementation_name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn randombytes(buf: *mut ::std::os::raw::c_uchar, buf_len: ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub static mut randombytes_internal_implementation: randombytes_implementation;
}
extern "C" {
    pub static mut randombytes_sysrandom_implementation: randombytes_implementation;
}
extern "C" {
    pub fn sodium_runtime_has_neon() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_sse2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_sse3() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_ssse3() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_sse41() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_avx() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_avx2() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_avx512f() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_pclmul() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_aesni() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_runtime_has_rdrand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sodium_runtime_get_cpu_features() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_memzero(pnt: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn sodium_stackzero(len: usize);
}
extern "C" {
    pub fn sodium_memcmp(
        b1_: *const ::std::os::raw::c_void,
        b2_: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_compare(
        b1_: *const ::std::os::raw::c_uchar,
        b2_: *const ::std::os::raw::c_uchar,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_is_zero(n: *const ::std::os::raw::c_uchar, nlen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_increment(n: *mut ::std::os::raw::c_uchar, nlen: usize);
}
extern "C" {
    pub fn sodium_add(
        a: *mut ::std::os::raw::c_uchar,
        b: *const ::std::os::raw::c_uchar,
        len: usize,
    );
}
extern "C" {
    pub fn sodium_sub(
        a: *mut ::std::os::raw::c_uchar,
        b: *const ::std::os::raw::c_uchar,
        len: usize,
    );
}
extern "C" {
    pub fn sodium_bin2hex(
        hex: *mut ::std::os::raw::c_char,
        hex_maxlen: usize,
        bin: *const ::std::os::raw::c_uchar,
        bin_len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sodium_hex2bin(
        bin: *mut ::std::os::raw::c_uchar,
        bin_maxlen: usize,
        hex: *const ::std::os::raw::c_char,
        hex_len: usize,
        ignore: *const ::std::os::raw::c_char,
        bin_len: *mut usize,
        hex_end: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_base64_encoded_len(bin_len: usize, variant: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn sodium_bin2base64(
        b64: *mut ::std::os::raw::c_char,
        b64_maxlen: usize,
        bin: *const ::std::os::raw::c_uchar,
        bin_len: usize,
        variant: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sodium_base642bin(
        bin: *mut ::std::os::raw::c_uchar,
        bin_maxlen: usize,
        b64: *const ::std::os::raw::c_char,
        b64_len: usize,
        ignore: *const ::std::os::raw::c_char,
        bin_len: *mut usize,
        b64_end: *mut *const ::std::os::raw::c_char,
        variant: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_mlock(addr: *mut ::std::os::raw::c_void, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_munlock(addr: *mut ::std::os::raw::c_void, len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sodium_allocarray(count: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn sodium_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sodium_mprotect_noaccess(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_mprotect_readonly(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_mprotect_readwrite(ptr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_pad(
        padded_buflen_p: *mut usize,
        buf: *mut ::std::os::raw::c_uchar,
        unpadded_buflen: usize,
        blocksize: usize,
        max_buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sodium_unpad(
        unpadded_buflen_p: *mut usize,
        buf: *const ::std::os::raw::c_uchar,
        padded_buflen: usize,
        blocksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sodium_alloc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xchacha20_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_xchacha20_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_xchacha20_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_xchacha20(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xchacha20_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xchacha20_xor_ic(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        ic: u64,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_xchacha20_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_seedbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_publickeybytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_secretkeybytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_beforenmbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_macbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_seed_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
        seed: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_keypair(
        pk: *mut ::std::os::raw::c_uchar,
        sk: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_easy(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_open_easy(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_open_detached(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        mac: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_beforenm(
        k: *mut ::std::os::raw::c_uchar,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_easy_afternm(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_open_easy_afternm(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_detached_afternm(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_open_detached_afternm(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        mac: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_sealbytes() -> usize;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_seal(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_box_curve25519xchacha20poly1305_seal_open(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        pk: *const ::std::os::raw::c_uchar,
        sk: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_bytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ed25519_uniformbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ed25519_hashbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ed25519_scalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ed25519_nonreducedscalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ed25519_is_valid_point(
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_add(
        r: *mut ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
        q: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_sub(
        r: *mut ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
        q: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_from_uniform(
        p: *mut ::std::os::raw::c_uchar,
        r: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_from_hash(
        p: *mut ::std::os::raw::c_uchar,
        h: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_random(p: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_random(r: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_invert(
        recip: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_negate(
        neg: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_complement(
        comp: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_add(
        z: *mut ::std::os::raw::c_uchar,
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_sub(
        z: *mut ::std::os::raw::c_uchar,
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_mul(
        z: *mut ::std::os::raw::c_uchar,
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ed25519_scalar_reduce(
        r: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ristretto255_bytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ristretto255_hashbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ristretto255_scalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ristretto255_nonreducedscalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_core_ristretto255_is_valid_point(
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ristretto255_add(
        r: *mut ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
        q: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ristretto255_sub(
        r: *mut ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
        q: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ristretto255_from_hash(
        p: *mut ::std::os::raw::c_uchar,
        r: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ristretto255_random(p: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_random(r: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_invert(
        recip: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_negate(
        neg: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_complement(
        comp: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_add(
        z: *mut ::std::os::raw::c_uchar,
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_sub(
        z: *mut ::std::os::raw::c_uchar,
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_mul(
        z: *mut ::std::os::raw::c_uchar,
        x: *const ::std::os::raw::c_uchar,
        y: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_core_ristretto255_scalar_reduce(
        r: *mut ::std::os::raw::c_uchar,
        s: *const ::std::os::raw::c_uchar,
    );
}
extern "C" {
    pub fn crypto_scalarmult_ed25519_bytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_ed25519_scalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_ed25519(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_ed25519_noclamp(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_ed25519_base(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_ed25519_base_noclamp(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_ristretto255_bytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_ristretto255_scalarbytes() -> usize;
}
extern "C" {
    pub fn crypto_scalarmult_ristretto255(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
        p: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_scalarmult_ristretto255_base(
        q: *mut ::std::os::raw::c_uchar,
        n: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_macbytes() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_easy(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_open_easy(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_detached(
        c: *mut ::std::os::raw::c_uchar,
        mac: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_secretbox_xchacha20poly1305_open_detached(
        m: *mut ::std::os::raw::c_uchar,
        c: *const ::std::os::raw::c_uchar,
        mac: *const ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_bytes_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_bytes_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_passwd_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_passwd_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_saltbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_strbytes() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_strprefix() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_opslimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_opslimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_memlimit_min() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_memlimit_max() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_opslimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_memlimit_interactive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_opslimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_memlimit_sensitive() -> usize;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256(
        out: *mut ::std::os::raw::c_uchar,
        outlen: ::std::os::raw::c_ulonglong,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        salt: *const ::std::os::raw::c_uchar,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_str(
        out: *mut ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_str_verify(
        str_: *const ::std::os::raw::c_char,
        passwd: *const ::std::os::raw::c_char,
        passwdlen: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_ll(
        passwd: *const u8,
        passwdlen: usize,
        salt: *const u8,
        saltlen: usize,
        N: u64,
        r: u32,
        p: u32,
        buf: *mut u8,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_pwhash_scryptsalsa208sha256_str_needs_rehash(
        str_: *const ::std::os::raw::c_char,
        opslimit: ::std::os::raw::c_ulonglong,
        memlimit: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa2012_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa2012_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa2012_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa2012(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa2012_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa2012_keygen(k: *mut ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn crypto_stream_salsa208_keybytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa208_noncebytes() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa208_messagebytes_max() -> usize;
}
extern "C" {
    pub fn crypto_stream_salsa208(
        c: *mut ::std::os::raw::c_uchar,
        clen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa208_xor(
        c: *mut ::std::os::raw::c_uchar,
        m: *const ::std::os::raw::c_uchar,
        mlen: ::std::os::raw::c_ulonglong,
        n: *const ::std::os::raw::c_uchar,
        k: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypto_stream_salsa208_keygen(k: *mut ::std::os::raw::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type socklen_t = __socklen_t;
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = ::std::os::raw::c_uint;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
pub const MSG_OOB: ::std::os::raw::c_uint = 1;
pub const MSG_PEEK: ::std::os::raw::c_uint = 2;
pub const MSG_DONTROUTE: ::std::os::raw::c_uint = 4;
pub const MSG_TRYHARD: ::std::os::raw::c_uint = 4;
pub const MSG_CTRUNC: ::std::os::raw::c_uint = 8;
pub const MSG_PROXY: ::std::os::raw::c_uint = 16;
pub const MSG_TRUNC: ::std::os::raw::c_uint = 32;
pub const MSG_DONTWAIT: ::std::os::raw::c_uint = 64;
pub const MSG_EOR: ::std::os::raw::c_uint = 128;
pub const MSG_WAITALL: ::std::os::raw::c_uint = 256;
pub const MSG_FIN: ::std::os::raw::c_uint = 512;
pub const MSG_SYN: ::std::os::raw::c_uint = 1024;
pub const MSG_CONFIRM: ::std::os::raw::c_uint = 2048;
pub const MSG_RST: ::std::os::raw::c_uint = 4096;
pub const MSG_ERRQUEUE: ::std::os::raw::c_uint = 8192;
pub const MSG_NOSIGNAL: ::std::os::raw::c_uint = 16384;
pub const MSG_MORE: ::std::os::raw::c_uint = 32768;
pub const MSG_WAITFORONE: ::std::os::raw::c_uint = 65536;
pub const MSG_BATCH: ::std::os::raw::c_uint = 262144;
pub const MSG_ZEROCOPY: ::std::os::raw::c_uint = 67108864;
pub const MSG_FASTOPEN: ::std::os::raw::c_uint = 536870912;
pub const MSG_CMSG_CLOEXEC: ::std::os::raw::c_uint = 1073741824;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).__cmsg_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
}
pub const SCM_RIGHTS: ::std::os::raw::c_uint = 1;
pub const SCM_CREDENTIALS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[test]
fn bindgen_test_layout_ucred() {
    assert_eq!(
        ::std::mem::size_of::<ucred>(),
        12usize,
        concat!("Size of: ", stringify!(ucred))
    );
    assert_eq!(
        ::std::mem::align_of::<ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(ucred))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucred>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucred>())).uid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ucred>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(
        ::std::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: ::std::os::raw::c_uint = 0;
pub const SHUT_WR: ::std::os::raw::c_uint = 1;
pub const SHUT_RDWR: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___SOCKADDR_ARG() {
    assert_eq!(
        ::std::mem::size_of::<__SOCKADDR_ARG>(),
        8usize,
        concat!("Size of: ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        ::std::mem::align_of::<__SOCKADDR_ARG>(),
        8usize,
        concat!("Alignment of ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_at__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_ax25__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_dl__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_eon__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_in__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_in6__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_inarp__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_ipx__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_iso__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_ns__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_un__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__SOCKADDR_ARG>())).__sockaddr_x25__ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___CONST_SOCKADDR_ARG() {
    assert_eq!(
        ::std::mem::size_of::<__CONST_SOCKADDR_ARG>(),
        8usize,
        concat!("Size of: ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        ::std::mem::align_of::<__CONST_SOCKADDR_ARG>(),
        8usize,
        concat!("Alignment of ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_at__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_ax25__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_dl__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_eon__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_in__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_in6__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_inarp__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_ipx__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_iso__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_ns__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_un__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__CONST_SOCKADDR_ARG>())).__sockaddr_x25__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmsghdr>())).msg_hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mmsghdr>())).msg_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
extern "C" {
    pub fn socket(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        __domain: ::std::os::raw::c_int,
        __type: ::std::os::raw::c_int,
        __protocol: ::std::os::raw::c_int,
        __fds: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        __fd: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        __fd: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recv(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __n: usize,
        __flags: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn sendmsg(
        __fd: ::std::os::raw::c_int,
        __message: *const msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendmmsg(
        __fd: ::std::os::raw::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recvmsg(
        __fd: ::std::os::raw::c_int,
        __message: *mut msghdr,
        __flags: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvmmsg(
        __fd: ::std::os::raw::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: ::std::os::raw::c_uint,
        __flags: ::std::os::raw::c_int,
        __tmo: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *mut ::std::os::raw::c_void,
        __optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(
        __fd: ::std::os::raw::c_int,
        __level: ::std::os::raw::c_int,
        __optname: ::std::os::raw::c_int,
        __optval: *const ::std::os::raw::c_void,
        __optlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept4(
        __fd: ::std::os::raw::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        __fd: ::std::os::raw::c_int,
        __how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(
        __fd: ::std::os::raw::c_int,
        __fdtype: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: ::std::os::raw::c_uint = 0;
pub const IPPROTO_ICMP: ::std::os::raw::c_uint = 1;
pub const IPPROTO_IGMP: ::std::os::raw::c_uint = 2;
pub const IPPROTO_IPIP: ::std::os::raw::c_uint = 4;
pub const IPPROTO_TCP: ::std::os::raw::c_uint = 6;
pub const IPPROTO_EGP: ::std::os::raw::c_uint = 8;
pub const IPPROTO_PUP: ::std::os::raw::c_uint = 12;
pub const IPPROTO_UDP: ::std::os::raw::c_uint = 17;
pub const IPPROTO_IDP: ::std::os::raw::c_uint = 22;
pub const IPPROTO_TP: ::std::os::raw::c_uint = 29;
pub const IPPROTO_DCCP: ::std::os::raw::c_uint = 33;
pub const IPPROTO_IPV6: ::std::os::raw::c_uint = 41;
pub const IPPROTO_RSVP: ::std::os::raw::c_uint = 46;
pub const IPPROTO_GRE: ::std::os::raw::c_uint = 47;
pub const IPPROTO_ESP: ::std::os::raw::c_uint = 50;
pub const IPPROTO_AH: ::std::os::raw::c_uint = 51;
pub const IPPROTO_MTP: ::std::os::raw::c_uint = 92;
pub const IPPROTO_BEETPH: ::std::os::raw::c_uint = 94;
pub const IPPROTO_ENCAP: ::std::os::raw::c_uint = 98;
pub const IPPROTO_PIM: ::std::os::raw::c_uint = 103;
pub const IPPROTO_COMP: ::std::os::raw::c_uint = 108;
pub const IPPROTO_SCTP: ::std::os::raw::c_uint = 132;
pub const IPPROTO_UDPLITE: ::std::os::raw::c_uint = 136;
pub const IPPROTO_MPLS: ::std::os::raw::c_uint = 137;
pub const IPPROTO_RAW: ::std::os::raw::c_uint = 255;
pub const IPPROTO_MAX: ::std::os::raw::c_uint = 256;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const IPPROTO_HOPOPTS: ::std::os::raw::c_uint = 0;
pub const IPPROTO_ROUTING: ::std::os::raw::c_uint = 43;
pub const IPPROTO_FRAGMENT: ::std::os::raw::c_uint = 44;
pub const IPPROTO_ICMPV6: ::std::os::raw::c_uint = 58;
pub const IPPROTO_NONE: ::std::os::raw::c_uint = 59;
pub const IPPROTO_DSTOPTS: ::std::os::raw::c_uint = 60;
pub const IPPROTO_MH: ::std::os::raw::c_uint = 135;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: ::std::os::raw::c_uint = 7;
pub const IPPORT_DISCARD: ::std::os::raw::c_uint = 9;
pub const IPPORT_SYSTAT: ::std::os::raw::c_uint = 11;
pub const IPPORT_DAYTIME: ::std::os::raw::c_uint = 13;
pub const IPPORT_NETSTAT: ::std::os::raw::c_uint = 15;
pub const IPPORT_FTP: ::std::os::raw::c_uint = 21;
pub const IPPORT_TELNET: ::std::os::raw::c_uint = 23;
pub const IPPORT_SMTP: ::std::os::raw::c_uint = 25;
pub const IPPORT_TIMESERVER: ::std::os::raw::c_uint = 37;
pub const IPPORT_NAMESERVER: ::std::os::raw::c_uint = 42;
pub const IPPORT_WHOIS: ::std::os::raw::c_uint = 43;
pub const IPPORT_MTP: ::std::os::raw::c_uint = 57;
pub const IPPORT_TFTP: ::std::os::raw::c_uint = 69;
pub const IPPORT_RJE: ::std::os::raw::c_uint = 77;
pub const IPPORT_FINGER: ::std::os::raw::c_uint = 79;
pub const IPPORT_TTYLINK: ::std::os::raw::c_uint = 87;
pub const IPPORT_SUPDUP: ::std::os::raw::c_uint = 95;
pub const IPPORT_EXECSERVER: ::std::os::raw::c_uint = 512;
pub const IPPORT_LOGINSERVER: ::std::os::raw::c_uint = 513;
pub const IPPORT_CMDSERVER: ::std::os::raw::c_uint = 514;
pub const IPPORT_EFSSERVER: ::std::os::raw::c_uint = 520;
pub const IPPORT_BIFFUDP: ::std::os::raw::c_uint = 512;
pub const IPPORT_WHOSERVER: ::std::os::raw::c_uint = 513;
pub const IPPORT_ROUTESERVER: ::std::os::raw::c_uint = 520;
pub const IPPORT_RESERVED: ::std::os::raw::c_uint = 1024;
pub const IPPORT_USERRESERVED: ::std::os::raw::c_uint = 5000;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(
        ::std::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(
        ::std::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(
        __sockfd: ::std::os::raw::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_ifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_mtu as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    pub fn inet6_option_space(__nbytes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        __bp: *mut ::std::os::raw::c_void,
        __cmsgp: *mut *mut cmsghdr,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        __cmsg: *mut cmsghdr,
        __typep: *const u8,
        __multx: ::std::os::raw::c_int,
        __plusy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        __cmsg: *mut cmsghdr,
        __datalen: ::std::os::raw::c_int,
        __multx: ::std::os::raw::c_int,
        __plusy: ::std::os::raw::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn inet6_option_next(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __type: u8,
        __len: socklen_t,
        __align: u8,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        __databuf: *mut ::std::os::raw::c_void,
        __offset: ::std::os::raw::c_int,
        __val: *mut ::std::os::raw::c_void,
        __vallen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __typep: *mut u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        __extbuf: *mut ::std::os::raw::c_void,
        __extlen: socklen_t,
        __offset: ::std::os::raw::c_int,
        __type: u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        __databuf: *mut ::std::os::raw::c_void,
        __offset: ::std::os::raw::c_int,
        __val: *mut ::std::os::raw::c_void,
        __vallen: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(
        __type: ::std::os::raw::c_int,
        __segments: ::std::os::raw::c_int,
    ) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        __bp: *mut ::std::os::raw::c_void,
        __bp_len: socklen_t,
        __type: ::std::os::raw::c_int,
        __segments: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        __bp: *mut ::std::os::raw::c_void,
        __addr: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        __in: *const ::std::os::raw::c_void,
        __out: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(__bp: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        __bp: *const ::std::os::raw::c_void,
        __index: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn getipv4sourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setipv4sourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        __s: ::std::os::raw::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
pub const GNUNET_GenericReturnValue_GNUNET_SYSERR: GNUNET_GenericReturnValue = -1;
pub const GNUNET_GenericReturnValue_GNUNET_NO: GNUNET_GenericReturnValue = 0;
pub const GNUNET_GenericReturnValue_GNUNET_OK: GNUNET_GenericReturnValue = 1;
pub const GNUNET_GenericReturnValue_GNUNET_YES: GNUNET_GenericReturnValue = 1;
#[doc = " Named constants for return values.  The following invariants hold:"]
#[doc = " `GNUNET_NO == 0` (to allow `if (GNUNET_NO)`) `GNUNET_OK !="]
#[doc = " GNUNET_SYSERR`, `GNUNET_OK != GNUNET_NO`, `GNUNET_NO !="]
#[doc = " GNUNET_SYSERR` and finally `GNUNET_YES != GNUNET_NO`."]
pub type GNUNET_GenericReturnValue = ::std::os::raw::c_int;
#[doc = " @brief A 512-bit hashcode.  These are the default length for GNUnet, using SHA-512."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_HashCode {
    pub bits: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_GNUNET_HashCode() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_HashCode>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_HashCode))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_HashCode>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_HashCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_HashCode>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HashCode),
            "::",
            stringify!(bits)
        )
    );
}
#[doc = " @brief A 256-bit hashcode.  Used under special conditions, like when space"]
#[doc = " is critical and security is not impacted by it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ShortHashCode {
    pub bits: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_GNUNET_ShortHashCode() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_ShortHashCode>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_ShortHashCode))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_ShortHashCode>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_ShortHashCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_ShortHashCode>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ShortHashCode),
            "::",
            stringify!(bits)
        )
    );
}
#[doc = " A UUID, a 128 bit \"random\" value.  We OFTEN use"]
#[doc = " timeflakes (see: https://github.com/anthonynsimon/timeflake),"]
#[doc = " where only 80 bits are random and the rest encodes"]
#[doc = " a timestamp to improve database access."]
#[doc = ""]
#[doc = " See #GNUNET_CRYPTO_random_timeflake()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_Uuid {
    #[doc = " 128 random bits."]
    pub value: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_GNUNET_Uuid() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_Uuid>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_Uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_Uuid>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_Uuid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_Uuid>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_Uuid),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Header for all communications."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_MessageHeader {
    #[doc = " The length of the struct (in bytes, including the length field itself),"]
    #[doc = " in big-endian format."]
    pub size: u16,
    #[doc = " The type of the message (GNUNET_MESSAGE_TYPE_XXXX), in big-endian format."]
    pub type_: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_MessageHeader() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_MessageHeader>(),
        4usize,
        concat!("Size of: ", stringify!(GNUNET_MessageHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_MessageHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_MessageHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_MessageHeader>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MessageHeader),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_MessageHeader>())).type_ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MessageHeader),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " Answer from service to client about last operation."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_OperationResultMessage {
    pub header: GNUNET_MessageHeader,
    pub reserved: u32,
    #[doc = " Operation ID."]
    pub op_id: u64,
    #[doc = " Status code for the operation."]
    pub result_code: u64,
}
#[test]
fn bindgen_test_layout_GNUNET_OperationResultMessage() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_OperationResultMessage>(),
        24usize,
        concat!("Size of: ", stringify!(GNUNET_OperationResultMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_OperationResultMessage>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_OperationResultMessage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OperationResultMessage>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OperationResultMessage),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OperationResultMessage>())).reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OperationResultMessage),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OperationResultMessage>())).op_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OperationResultMessage),
            "::",
            stringify!(op_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OperationResultMessage>())).result_code as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OperationResultMessage),
            "::",
            stringify!(result_code)
        )
    );
}
#[doc = " Identifier for an asynchronous execution context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_AsyncScopeId {
    pub bits: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_GNUNET_AsyncScopeId() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_AsyncScopeId>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_AsyncScopeId))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_AsyncScopeId>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_AsyncScopeId))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_AsyncScopeId>())).bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_AsyncScopeId),
            "::",
            stringify!(bits)
        )
    );
}
#[doc = " Saved async scope identifier or root scope."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_AsyncScopeSave {
    #[doc = " Saved scope.  Unused if 'have_scope==GNUNET_NO'."]
    pub scope_id: GNUNET_AsyncScopeId,
    #[doc = " GNUNET_YES unless this saved scope is the unnamed root scope."]
    pub have_scope: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GNUNET_AsyncScopeSave() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_AsyncScopeSave>(),
        20usize,
        concat!("Size of: ", stringify!(GNUNET_AsyncScopeSave))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_AsyncScopeSave>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_AsyncScopeSave))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_AsyncScopeSave>())).scope_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_AsyncScopeSave),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_AsyncScopeSave>())).have_scope as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_AsyncScopeSave),
            "::",
            stringify!(have_scope)
        )
    );
}
#[doc = " Function called with a filename."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param filename complete filename (absolute path)"]
#[doc = " @return #GNUNET_OK to continue to iterate,"]
#[doc = "  #GNUNET_NO to stop iteration with no error,"]
#[doc = "  #GNUNET_SYSERR to abort iteration with error!"]
pub type GNUNET_FileNameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue,
>;
#[doc = " Generic continuation callback."]
#[doc = ""]
#[doc = " @param cls  Closure."]
pub type GNUNET_ContinuationCallback =
    ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void)>;
#[doc = " Function called with the result of an asynchronous operation."]
#[doc = ""]
#[doc = " @param cls"]
#[doc = "        Closure."]
#[doc = " @param result_code"]
#[doc = "        Result code for the operation."]
#[doc = " @param data"]
#[doc = "        Data result for the operation."]
#[doc = " @param data_size"]
#[doc = "        Size of @a data."]
pub type GNUNET_ResultCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        result_code: i64,
        data: *const ::std::os::raw::c_void,
        data_size: u16,
    ),
>;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_UNSPECIFIED: GNUNET_ErrorType = -1;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_NONE: GNUNET_ErrorType = 0;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_ERROR: GNUNET_ErrorType = 1;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_WARNING: GNUNET_ErrorType = 2;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_MESSAGE: GNUNET_ErrorType = 4;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_INFO: GNUNET_ErrorType = 8;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_DEBUG: GNUNET_ErrorType = 16;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_INVALID: GNUNET_ErrorType = 32;
pub const GNUNET_ErrorType_GNUNET_ERROR_TYPE_BULK: GNUNET_ErrorType = 64;
#[doc = " @ingroup logging"]
#[doc = " Types of errors."]
pub type GNUNET_ErrorType = ::std::os::raw::c_int;
#[doc = " @ingroup logging"]
#[doc = " User-defined handler for log messages."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param kind severeity"]
#[doc = " @param component what component is issuing the message?"]
#[doc = " @param date when was the message logged?"]
#[doc = " @param message what is the message"]
pub type GNUNET_Logger = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        kind: GNUNET_ErrorType,
        component: *const ::std::os::raw::c_char,
        date: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Get the number of log calls that are going to be skipped"]
    #[doc = ""]
    #[doc = " @return number of log calls to be ignored"]
    pub fn GNUNET_get_log_skip() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GNUNET_get_log_call_status(
        caller_level: ::std::os::raw::c_int,
        comp: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        function: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Main log function."]
    #[doc = ""]
    #[doc = " @param kind how serious is the error?"]
    #[doc = " @param message what is the message (format string)"]
    #[doc = " @param ... arguments for format string"]
    pub fn GNUNET_log_nocheck(kind: GNUNET_ErrorType, message: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Log function that specifies an alternative component."]
    #[doc = " This function should be used by plugins."]
    #[doc = ""]
    #[doc = " @param kind how serious is the error?"]
    #[doc = " @param comp component responsible for generating the message"]
    #[doc = " @param message what is the message (format string)"]
    #[doc = " @param ... arguments for format string"]
    pub fn GNUNET_log_from_nocheck(
        kind: GNUNET_ErrorType,
        comp: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Log error message about missing configuration option."]
    #[doc = ""]
    #[doc = " @param kind log level"]
    #[doc = " @param section section with missing option"]
    #[doc = " @param option name of missing option"]
    pub fn GNUNET_log_config_missing(
        kind: GNUNET_ErrorType,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Log error message about invalid configuration option value."]
    #[doc = ""]
    #[doc = " @param kind log level"]
    #[doc = " @param section section with invalid option"]
    #[doc = " @param option name of invalid option"]
    #[doc = " @param required what is required that is invalid about the option"]
    pub fn GNUNET_log_config_invalid(
        kind: GNUNET_ErrorType,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        required: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Abort the process, generate a core dump if possible."]
    #[doc = " Most code should use `GNUNET_assert (0)` instead to"]
    #[doc = " first log the location of the failure."]
    pub fn GNUNET_abort_();
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Ignore the next @a n calls to the log function."]
    #[doc = ""]
    #[doc = " @param n number of log calls to ignore (could be negative)"]
    #[doc = " @param check_reset #GNUNET_YES to assert that the log skip counter is currently zero"]
    pub fn GNUNET_log_skip(n: ::std::os::raw::c_int, check_reset: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Setup logging."]
    #[doc = ""]
    #[doc = " @param comp default component to use"]
    #[doc = " @param loglevel what types of messages should be logged"]
    #[doc = " @param logfile change logging to logfile (use NULL to keep stderr)"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if logfile could not be opened"]
    pub fn GNUNET_log_setup(
        comp: *const ::std::os::raw::c_char,
        loglevel: *const ::std::os::raw::c_char,
        logfile: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Add a custom logger.  Note that installing any custom logger"]
    #[doc = " will disable the standard logger.  When multiple custom loggers"]
    #[doc = " are installed, all will be called.  The standard logger will"]
    #[doc = " only be used if no custom loggers are present."]
    #[doc = ""]
    #[doc = " @param logger log function"]
    #[doc = " @param logger_cls closure for @a logger"]
    pub fn GNUNET_logger_add(logger: GNUNET_Logger, logger_cls: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Remove a custom logger."]
    #[doc = ""]
    #[doc = " @param logger log function"]
    #[doc = " @param logger_cls closure for @a logger"]
    pub fn GNUNET_logger_remove(logger: GNUNET_Logger, logger_cls: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a short hash value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param shc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_sh2s(shc: *const GNUNET_ShortHashCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a UUID to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param uuid the UUID"]
    #[doc = " @return string"]
    pub fn GNUNET_uuid2s(uuid: *const GNUNET_Uuid) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a hash value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_h2s(hc: *const GNUNET_HashCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a hash value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant! Identical to #GNUNET_h2s(), except that another"]
    #[doc = " buffer is used so both #GNUNET_h2s() and #GNUNET_h2s2() can be"]
    #[doc = " used within the same log statement."]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_h2s2(hc: *const GNUNET_HashCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a hash value to a string (for printing debug messages)."]
    #[doc = " This prints all 104 characters of a hashcode!"]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_h2s_full(hc: *const GNUNET_HashCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a public key value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_p2s(p: *const GNUNET_CRYPTO_EddsaPublicKey) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a public key value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_p2s2(p: *const GNUNET_CRYPTO_EddsaPublicKey) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a public key value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_e2s(p: *const GNUNET_CRYPTO_EcdhePublicKey) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a public key value to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param hc the hash code"]
    #[doc = " @return string"]
    pub fn GNUNET_e2s2(p: *const GNUNET_CRYPTO_EcdhePublicKey) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a peer identity to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param pid the peer identity"]
    #[doc = " @return string form of the pid; will be overwritten by next"]
    #[doc = "         call to #GNUNET_i2s()."]
    pub fn GNUNET_i2s(pid: *const GNUNET_PeerIdentity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a peer identity to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!  Identical to #GNUNET_i2s(), except that another"]
    #[doc = " buffer is used so both #GNUNET_i2s() and #GNUNET_i2s2() can be"]
    #[doc = " used within the same log statement."]
    #[doc = ""]
    #[doc = " @param pid the peer identity"]
    #[doc = " @return string form of the pid; will be overwritten by next"]
    #[doc = "         call to #GNUNET_i2s()."]
    pub fn GNUNET_i2s2(pid: *const GNUNET_PeerIdentity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a peer identity to a string (for printing debug messages)."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param pid the peer identity"]
    #[doc = " @return string form of the pid; will be overwritten by next"]
    #[doc = "         call to #GNUNET_i2s_full()."]
    pub fn GNUNET_i2s_full(pid: *const GNUNET_PeerIdentity) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert a \"struct sockaddr*\" (IPv4 or IPv6 address) to a string"]
    #[doc = " (for printing debug messages).  This is one of the very few calls"]
    #[doc = " in the entire API that is NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param addr the address"]
    #[doc = " @param addrlen the length of the @a addr"]
    #[doc = " @return nicely formatted string for the address"]
    #[doc = "  will be overwritten by next call to #GNUNET_a2s()."]
    pub fn GNUNET_a2s(addr: *const sockaddr, addrlen: socklen_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup logging"]
    #[doc = " Convert error type to string."]
    #[doc = ""]
    #[doc = " @param kind type to convert"]
    #[doc = " @return string corresponding to the type"]
    pub fn GNUNET_error_type_to_string(kind: GNUNET_ErrorType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert unsigned 64-bit integer to network byte order."]
    #[doc = ""]
    #[doc = " @param n"]
    #[doc = "        The value in host byte order."]
    #[doc = ""]
    #[doc = " @return The same value in network byte order."]
    pub fn GNUNET_htonll(n: u64) -> u64;
}
extern "C" {
    #[doc = " Convert double to network byte order."]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "        The value in host byte order."]
    #[doc = ""]
    #[doc = " @return The same value in network byte order."]
    pub fn GNUNET_hton_double(d: f64) -> f64;
}
extern "C" {
    #[doc = " Convert double to host byte order"]
    #[doc = ""]
    #[doc = " @param d"]
    #[doc = "        The value in network byte order."]
    #[doc = ""]
    #[doc = " @return The same value in host byte order."]
    pub fn GNUNET_ntoh_double(d: f64) -> f64;
}
extern "C" {
    #[doc = " Compare memory in @a b1 and @a b2 in constant time, suitable for private"]
    #[doc = " data."]
    #[doc = ""]
    #[doc = " @param b1 some buffer of size @a len"]
    #[doc = " @param b2 another buffer of size @a len"]
    #[doc = " @param len number of bytes in @a b1 and @a b2"]
    #[doc = " @return 0 if buffers are equal,"]
    pub fn GNUNET_memcmp_ct_(
        b1: *const ::std::os::raw::c_void,
        b2: *const ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check that memory in @a a is all zeros. @a a must be a pointer."]
    #[doc = ""]
    #[doc = " @param a pointer to @a n bytes which should be tested for the"]
    #[doc = "          entire memory being zero'ed out."]
    #[doc = " @param n number of bytes in @a to be tested"]
    #[doc = " @return GNUNET_YES if a is zero, GNUNET_NO otherwise"]
    pub fn GNUNET_is_zero_(a: *const ::std::os::raw::c_void, n: usize)
        -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup memory"]
    #[doc = " Like snprintf, just aborts if the buffer is of insufficient size."]
    #[doc = ""]
    #[doc = " @param buf pointer to buffer that is written to"]
    #[doc = " @param size number of bytes in @a buf"]
    #[doc = " @param format format strings"]
    #[doc = " @param ... data for format string"]
    #[doc = " @return number of bytes written to buf or negative value on error"]
    pub fn GNUNET_snprintf(
        buf: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup memory"]
    #[doc = " Like asprintf, just portable."]
    #[doc = ""]
    #[doc = " @param buf set to a buffer of sufficient size (allocated, caller must free)"]
    #[doc = " @param format format string (see printf, fprintf, etc.)"]
    #[doc = " @param ... data for format string"]
    #[doc = " @return number of bytes in \"*buf\" excluding 0-termination"]
    pub fn GNUNET_asprintf(
        buf: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate memory. Checks the return value, aborts if no more"]
    #[doc = " memory is available.  Don't use GNUNET_xmalloc_ directly. Use the"]
    #[doc = " #GNUNET_malloc macro."]
    #[doc = " The memory will be zero'ed out."]
    #[doc = ""]
    #[doc = " @param size number of bytes to allocate"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return allocated memory, never NULL"]
    pub fn GNUNET_xmalloc_(
        size: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate memory for a two dimensional array in one block"]
    #[doc = " and set up pointers. Aborts if no more memory is available."]
    #[doc = " Don't use GNUNET_xnew_array_2d_ directly. Use the"]
    #[doc = " #GNUNET_new_array_2d macro."]
    #[doc = " The memory of the elements will be zero'ed out."]
    #[doc = ""]
    #[doc = " @param n size of the first dimension"]
    #[doc = " @param m size of the second dimension"]
    #[doc = " @param elementSize size of a single element in bytes"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return allocated memory, never NULL"]
    pub fn GNUNET_xnew_array_2d_(
        n: usize,
        m: usize,
        elementSize: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate memory for a three dimensional array in one block"]
    #[doc = " and set up pointers. Aborts if no more memory is available."]
    #[doc = " Don't use GNUNET_xnew_array_3d_ directly. Use the"]
    #[doc = " #GNUNET_new_array_3d macro."]
    #[doc = " The memory of the elements will be zero'ed out."]
    #[doc = ""]
    #[doc = " @param n size of the first dimension"]
    #[doc = " @param m size of the second dimension"]
    #[doc = " @param o size of the third dimension"]
    #[doc = " @param elementSize size of a single element in bytes"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return allocated memory, never NULL"]
    pub fn GNUNET_xnew_array_3d_(
        n: usize,
        m: usize,
        o: usize,
        elementSize: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate and initialize memory. Checks the return value, aborts if no more"]
    #[doc = " memory is available.  Don't use GNUNET_xmemdup_ directly. Use the"]
    #[doc = " #GNUNET_memdup macro."]
    #[doc = ""]
    #[doc = " @param buf buffer to initialize from (must contain size bytes)"]
    #[doc = " @param size number of bytes to allocate"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return allocated memory, never NULL"]
    pub fn GNUNET_xmemdup_(
        buf: *const ::std::os::raw::c_void,
        size: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate memory.  This function does not check if the allocation"]
    #[doc = " request is within reasonable bounds, allowing allocations larger"]
    #[doc = " than 40 MB.  If you don't expect the possibility of very large"]
    #[doc = " allocations, use #GNUNET_malloc instead.  The memory will be zero'ed"]
    #[doc = " out."]
    #[doc = ""]
    #[doc = " @param size number of bytes to allocate"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return pointer to size bytes of memory, NULL if we do not have enough memory"]
    pub fn GNUNET_xmalloc_unchecked_(
        size: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Reallocate memory. Checks the return value, aborts if no more"]
    #[doc = " memory is available."]
    pub fn GNUNET_xrealloc_(
        ptr: *mut ::std::os::raw::c_void,
        n: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free memory. Merely a wrapper for the case that we"]
    #[doc = " want to keep track of allocations.  Don't use GNUNET_xfree_"]
    #[doc = " directly. Use the #GNUNET_free macro."]
    #[doc = ""]
    #[doc = " @param ptr pointer to memory to free"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    pub fn GNUNET_xfree_(
        ptr: *mut ::std::os::raw::c_void,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Dup a string. Don't call GNUNET_xstrdup_ directly. Use the #GNUNET_strdup macro."]
    #[doc = " @param str string to duplicate"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return the duplicated string"]
    pub fn GNUNET_xstrdup_(
        str_: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Dup partially a string. Don't call GNUNET_xstrndup_ directly. Use the #GNUNET_strndup macro."]
    #[doc = ""]
    #[doc = " @param str string to duplicate"]
    #[doc = " @param len length of the string to duplicate"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    #[doc = " @return the duplicated string"]
    pub fn GNUNET_xstrndup_(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Grow an array, the new elements are zeroed out."]
    #[doc = " Grows old by (*oldCount-newCount)*elementSize"]
    #[doc = " bytes and sets *oldCount to newCount."]
    #[doc = ""]
    #[doc = " Don't call GNUNET_xgrow_ directly. Use the #GNUNET_array_grow macro."]
    #[doc = ""]
    #[doc = " @param old address of the pointer to the array"]
    #[doc = "        *old may be NULL"]
    #[doc = " @param elementSize the size of the elements of the array"]
    #[doc = " @param oldCount address of the number of elements in the *old array"]
    #[doc = " @param newCount number of elements in the new array, may be 0 (then *old will be NULL afterwards)"]
    #[doc = " @param filename where is this call being made (for debugging)"]
    #[doc = " @param linenumber line where this call is being made (for debugging)"]
    pub fn GNUNET_xgrow_(
        old: *mut *mut ::std::os::raw::c_void,
        elementSize: usize,
        oldCount: *mut ::std::os::raw::c_uint,
        newCount: ::std::os::raw::c_uint,
        filename: *const ::std::os::raw::c_char,
        linenumber: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @ingroup memory"]
    #[doc = " Create a copy of the given message."]
    #[doc = ""]
    #[doc = " @param msg message to copy"]
    #[doc = " @return duplicate of the message"]
    pub fn GNUNET_copy_message(msg: *const GNUNET_MessageHeader) -> *mut GNUNET_MessageHeader;
}
extern "C" {
    #[doc = " Set the async scope for the current thread."]
    #[doc = ""]
    #[doc = " @param aid the async scope identifier"]
    #[doc = " @param old_scope[out] location to save the old scope"]
    pub fn GNUNET_async_scope_enter(
        aid: *const GNUNET_AsyncScopeId,
        old_scope: *mut GNUNET_AsyncScopeSave,
    );
}
extern "C" {
    #[doc = " Clear the current thread's async scope."]
    #[doc = ""]
    #[doc = " @param old_scope scope to restore"]
    pub fn GNUNET_async_scope_restore(old_scope: *mut GNUNET_AsyncScopeSave);
}
extern "C" {
    #[doc = " Get the current async scope."]
    #[doc = ""]
    #[doc = " @param[out] scope_ret pointer to where the result is stored"]
    pub fn GNUNET_async_scope_get(scope_ret: *mut GNUNET_AsyncScopeSave);
}
extern "C" {
    #[doc = " Generate a fresh async scope identifier."]
    #[doc = ""]
    #[doc = " @param[out] aid_ret pointer to where the result is stored"]
    pub fn GNUNET_async_scope_fresh(aid_ret: *mut GNUNET_AsyncScopeId);
}
#[doc = " Run with the same priority as the current job."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_KEEP: GNUNET_SCHEDULER_Priority = 0;
#[doc = " Run when otherwise idle."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_IDLE: GNUNET_SCHEDULER_Priority = 1;
#[doc = " Run as background job (higher than idle,"]
#[doc = " lower than default)."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_BACKGROUND:
    GNUNET_SCHEDULER_Priority = 2;
#[doc = " Run with the default priority (normal"]
#[doc = " P2P operations).  Any task that is scheduled"]
#[doc = " without an explicit priority being specified"]
#[doc = " will run with this priority."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_DEFAULT: GNUNET_SCHEDULER_Priority =
    3;
#[doc = " Run with high priority (important requests)."]
#[doc = " Higher than DEFAULT."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_HIGH: GNUNET_SCHEDULER_Priority = 4;
#[doc = " Run with priority for interactive tasks."]
#[doc = " Higher than \"HIGH\"."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_UI: GNUNET_SCHEDULER_Priority = 5;
#[doc = " Run with priority for urgent tasks.  Use"]
#[doc = " for things like aborts and shutdowns that"]
#[doc = " need to preempt \"UI\"-level tasks."]
#[doc = " Higher than \"UI\"."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_URGENT: GNUNET_SCHEDULER_Priority = 6;
#[doc = " This is an internal priority level that is only used for tasks"]
#[doc = " that are being triggered due to shutdown (they have automatically"]
#[doc = " highest priority).  User code must not use this priority level"]
#[doc = " directly.  Tasks run with this priority level that internally"]
#[doc = " schedule other tasks will see their original priority level"]
#[doc = " be inherited (unless otherwise specified)."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_SHUTDOWN: GNUNET_SCHEDULER_Priority =
    7;
#[doc = " Number of priorities (must be the last priority)."]
#[doc = " This priority must not be used by clients."]
pub const GNUNET_SCHEDULER_Priority_GNUNET_SCHEDULER_PRIORITY_COUNT: GNUNET_SCHEDULER_Priority = 8;
#[doc = " Valid task priorities.  Use these, do not pass random integers!"]
#[doc = " For various reasons (#3862 -- building with QT Creator, and"]
#[doc = " our restricted cross-compilation with emscripten) this cannot"]
#[doc = " be in gnunet_scheduler_lib.h, but it works if we declare it here."]
#[doc = " Naturally, logically this is part of the scheduler."]
pub type GNUNET_SCHEDULER_Priority = ::std::os::raw::c_uint;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub const gpg_err_source_t_GPG_ERR_SOURCE_UNKNOWN: gpg_err_source_t = 0;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GCRYPT: gpg_err_source_t = 1;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPG: gpg_err_source_t = 2;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPGSM: gpg_err_source_t = 3;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPGAGENT: gpg_err_source_t = 4;
pub const gpg_err_source_t_GPG_ERR_SOURCE_PINENTRY: gpg_err_source_t = 5;
pub const gpg_err_source_t_GPG_ERR_SOURCE_SCD: gpg_err_source_t = 6;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPGME: gpg_err_source_t = 7;
pub const gpg_err_source_t_GPG_ERR_SOURCE_KEYBOX: gpg_err_source_t = 8;
pub const gpg_err_source_t_GPG_ERR_SOURCE_KSBA: gpg_err_source_t = 9;
pub const gpg_err_source_t_GPG_ERR_SOURCE_DIRMNGR: gpg_err_source_t = 10;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GSTI: gpg_err_source_t = 11;
pub const gpg_err_source_t_GPG_ERR_SOURCE_GPA: gpg_err_source_t = 12;
pub const gpg_err_source_t_GPG_ERR_SOURCE_KLEO: gpg_err_source_t = 13;
pub const gpg_err_source_t_GPG_ERR_SOURCE_G13: gpg_err_source_t = 14;
pub const gpg_err_source_t_GPG_ERR_SOURCE_ASSUAN: gpg_err_source_t = 15;
pub const gpg_err_source_t_GPG_ERR_SOURCE_TLS: gpg_err_source_t = 17;
pub const gpg_err_source_t_GPG_ERR_SOURCE_ANY: gpg_err_source_t = 31;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_1: gpg_err_source_t = 32;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_2: gpg_err_source_t = 33;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_3: gpg_err_source_t = 34;
pub const gpg_err_source_t_GPG_ERR_SOURCE_USER_4: gpg_err_source_t = 35;
pub const gpg_err_source_t_GPG_ERR_SOURCE_DIM: gpg_err_source_t = 128;
pub type gpg_err_source_t = ::std::os::raw::c_uint;
pub const gpg_err_code_t_GPG_ERR_NO_ERROR: gpg_err_code_t = 0;
pub const gpg_err_code_t_GPG_ERR_GENERAL: gpg_err_code_t = 1;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_PACKET: gpg_err_code_t = 2;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_VERSION: gpg_err_code_t = 3;
pub const gpg_err_code_t_GPG_ERR_PUBKEY_ALGO: gpg_err_code_t = 4;
pub const gpg_err_code_t_GPG_ERR_DIGEST_ALGO: gpg_err_code_t = 5;
pub const gpg_err_code_t_GPG_ERR_BAD_PUBKEY: gpg_err_code_t = 6;
pub const gpg_err_code_t_GPG_ERR_BAD_SECKEY: gpg_err_code_t = 7;
pub const gpg_err_code_t_GPG_ERR_BAD_SIGNATURE: gpg_err_code_t = 8;
pub const gpg_err_code_t_GPG_ERR_NO_PUBKEY: gpg_err_code_t = 9;
pub const gpg_err_code_t_GPG_ERR_CHECKSUM: gpg_err_code_t = 10;
pub const gpg_err_code_t_GPG_ERR_BAD_PASSPHRASE: gpg_err_code_t = 11;
pub const gpg_err_code_t_GPG_ERR_CIPHER_ALGO: gpg_err_code_t = 12;
pub const gpg_err_code_t_GPG_ERR_KEYRING_OPEN: gpg_err_code_t = 13;
pub const gpg_err_code_t_GPG_ERR_INV_PACKET: gpg_err_code_t = 14;
pub const gpg_err_code_t_GPG_ERR_INV_ARMOR: gpg_err_code_t = 15;
pub const gpg_err_code_t_GPG_ERR_NO_USER_ID: gpg_err_code_t = 16;
pub const gpg_err_code_t_GPG_ERR_NO_SECKEY: gpg_err_code_t = 17;
pub const gpg_err_code_t_GPG_ERR_WRONG_SECKEY: gpg_err_code_t = 18;
pub const gpg_err_code_t_GPG_ERR_BAD_KEY: gpg_err_code_t = 19;
pub const gpg_err_code_t_GPG_ERR_COMPR_ALGO: gpg_err_code_t = 20;
pub const gpg_err_code_t_GPG_ERR_NO_PRIME: gpg_err_code_t = 21;
pub const gpg_err_code_t_GPG_ERR_NO_ENCODING_METHOD: gpg_err_code_t = 22;
pub const gpg_err_code_t_GPG_ERR_NO_ENCRYPTION_SCHEME: gpg_err_code_t = 23;
pub const gpg_err_code_t_GPG_ERR_NO_SIGNATURE_SCHEME: gpg_err_code_t = 24;
pub const gpg_err_code_t_GPG_ERR_INV_ATTR: gpg_err_code_t = 25;
pub const gpg_err_code_t_GPG_ERR_NO_VALUE: gpg_err_code_t = 26;
pub const gpg_err_code_t_GPG_ERR_NOT_FOUND: gpg_err_code_t = 27;
pub const gpg_err_code_t_GPG_ERR_VALUE_NOT_FOUND: gpg_err_code_t = 28;
pub const gpg_err_code_t_GPG_ERR_SYNTAX: gpg_err_code_t = 29;
pub const gpg_err_code_t_GPG_ERR_BAD_MPI: gpg_err_code_t = 30;
pub const gpg_err_code_t_GPG_ERR_INV_PASSPHRASE: gpg_err_code_t = 31;
pub const gpg_err_code_t_GPG_ERR_SIG_CLASS: gpg_err_code_t = 32;
pub const gpg_err_code_t_GPG_ERR_RESOURCE_LIMIT: gpg_err_code_t = 33;
pub const gpg_err_code_t_GPG_ERR_INV_KEYRING: gpg_err_code_t = 34;
pub const gpg_err_code_t_GPG_ERR_TRUSTDB: gpg_err_code_t = 35;
pub const gpg_err_code_t_GPG_ERR_BAD_CERT: gpg_err_code_t = 36;
pub const gpg_err_code_t_GPG_ERR_INV_USER_ID: gpg_err_code_t = 37;
pub const gpg_err_code_t_GPG_ERR_UNEXPECTED: gpg_err_code_t = 38;
pub const gpg_err_code_t_GPG_ERR_TIME_CONFLICT: gpg_err_code_t = 39;
pub const gpg_err_code_t_GPG_ERR_KEYSERVER: gpg_err_code_t = 40;
pub const gpg_err_code_t_GPG_ERR_WRONG_PUBKEY_ALGO: gpg_err_code_t = 41;
pub const gpg_err_code_t_GPG_ERR_TRIBUTE_TO_D_A: gpg_err_code_t = 42;
pub const gpg_err_code_t_GPG_ERR_WEAK_KEY: gpg_err_code_t = 43;
pub const gpg_err_code_t_GPG_ERR_INV_KEYLEN: gpg_err_code_t = 44;
pub const gpg_err_code_t_GPG_ERR_INV_ARG: gpg_err_code_t = 45;
pub const gpg_err_code_t_GPG_ERR_BAD_URI: gpg_err_code_t = 46;
pub const gpg_err_code_t_GPG_ERR_INV_URI: gpg_err_code_t = 47;
pub const gpg_err_code_t_GPG_ERR_NETWORK: gpg_err_code_t = 48;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_HOST: gpg_err_code_t = 49;
pub const gpg_err_code_t_GPG_ERR_SELFTEST_FAILED: gpg_err_code_t = 50;
pub const gpg_err_code_t_GPG_ERR_NOT_ENCRYPTED: gpg_err_code_t = 51;
pub const gpg_err_code_t_GPG_ERR_NOT_PROCESSED: gpg_err_code_t = 52;
pub const gpg_err_code_t_GPG_ERR_UNUSABLE_PUBKEY: gpg_err_code_t = 53;
pub const gpg_err_code_t_GPG_ERR_UNUSABLE_SECKEY: gpg_err_code_t = 54;
pub const gpg_err_code_t_GPG_ERR_INV_VALUE: gpg_err_code_t = 55;
pub const gpg_err_code_t_GPG_ERR_BAD_CERT_CHAIN: gpg_err_code_t = 56;
pub const gpg_err_code_t_GPG_ERR_MISSING_CERT: gpg_err_code_t = 57;
pub const gpg_err_code_t_GPG_ERR_NO_DATA: gpg_err_code_t = 58;
pub const gpg_err_code_t_GPG_ERR_BUG: gpg_err_code_t = 59;
pub const gpg_err_code_t_GPG_ERR_NOT_SUPPORTED: gpg_err_code_t = 60;
pub const gpg_err_code_t_GPG_ERR_INV_OP: gpg_err_code_t = 61;
pub const gpg_err_code_t_GPG_ERR_TIMEOUT: gpg_err_code_t = 62;
pub const gpg_err_code_t_GPG_ERR_INTERNAL: gpg_err_code_t = 63;
pub const gpg_err_code_t_GPG_ERR_EOF_GCRYPT: gpg_err_code_t = 64;
pub const gpg_err_code_t_GPG_ERR_INV_OBJ: gpg_err_code_t = 65;
pub const gpg_err_code_t_GPG_ERR_TOO_SHORT: gpg_err_code_t = 66;
pub const gpg_err_code_t_GPG_ERR_TOO_LARGE: gpg_err_code_t = 67;
pub const gpg_err_code_t_GPG_ERR_NO_OBJ: gpg_err_code_t = 68;
pub const gpg_err_code_t_GPG_ERR_NOT_IMPLEMENTED: gpg_err_code_t = 69;
pub const gpg_err_code_t_GPG_ERR_CONFLICT: gpg_err_code_t = 70;
pub const gpg_err_code_t_GPG_ERR_INV_CIPHER_MODE: gpg_err_code_t = 71;
pub const gpg_err_code_t_GPG_ERR_INV_FLAG: gpg_err_code_t = 72;
pub const gpg_err_code_t_GPG_ERR_INV_HANDLE: gpg_err_code_t = 73;
pub const gpg_err_code_t_GPG_ERR_TRUNCATED: gpg_err_code_t = 74;
pub const gpg_err_code_t_GPG_ERR_INCOMPLETE_LINE: gpg_err_code_t = 75;
pub const gpg_err_code_t_GPG_ERR_INV_RESPONSE: gpg_err_code_t = 76;
pub const gpg_err_code_t_GPG_ERR_NO_AGENT: gpg_err_code_t = 77;
pub const gpg_err_code_t_GPG_ERR_AGENT: gpg_err_code_t = 78;
pub const gpg_err_code_t_GPG_ERR_INV_DATA: gpg_err_code_t = 79;
pub const gpg_err_code_t_GPG_ERR_ASSUAN_SERVER_FAULT: gpg_err_code_t = 80;
pub const gpg_err_code_t_GPG_ERR_ASSUAN: gpg_err_code_t = 81;
pub const gpg_err_code_t_GPG_ERR_INV_SESSION_KEY: gpg_err_code_t = 82;
pub const gpg_err_code_t_GPG_ERR_INV_SEXP: gpg_err_code_t = 83;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_ALGORITHM: gpg_err_code_t = 84;
pub const gpg_err_code_t_GPG_ERR_NO_PIN_ENTRY: gpg_err_code_t = 85;
pub const gpg_err_code_t_GPG_ERR_PIN_ENTRY: gpg_err_code_t = 86;
pub const gpg_err_code_t_GPG_ERR_BAD_PIN: gpg_err_code_t = 87;
pub const gpg_err_code_t_GPG_ERR_INV_NAME: gpg_err_code_t = 88;
pub const gpg_err_code_t_GPG_ERR_BAD_DATA: gpg_err_code_t = 89;
pub const gpg_err_code_t_GPG_ERR_INV_PARAMETER: gpg_err_code_t = 90;
pub const gpg_err_code_t_GPG_ERR_WRONG_CARD: gpg_err_code_t = 91;
pub const gpg_err_code_t_GPG_ERR_NO_DIRMNGR: gpg_err_code_t = 92;
pub const gpg_err_code_t_GPG_ERR_DIRMNGR: gpg_err_code_t = 93;
pub const gpg_err_code_t_GPG_ERR_CERT_REVOKED: gpg_err_code_t = 94;
pub const gpg_err_code_t_GPG_ERR_NO_CRL_KNOWN: gpg_err_code_t = 95;
pub const gpg_err_code_t_GPG_ERR_CRL_TOO_OLD: gpg_err_code_t = 96;
pub const gpg_err_code_t_GPG_ERR_LINE_TOO_LONG: gpg_err_code_t = 97;
pub const gpg_err_code_t_GPG_ERR_NOT_TRUSTED: gpg_err_code_t = 98;
pub const gpg_err_code_t_GPG_ERR_CANCELED: gpg_err_code_t = 99;
pub const gpg_err_code_t_GPG_ERR_BAD_CA_CERT: gpg_err_code_t = 100;
pub const gpg_err_code_t_GPG_ERR_CERT_EXPIRED: gpg_err_code_t = 101;
pub const gpg_err_code_t_GPG_ERR_CERT_TOO_YOUNG: gpg_err_code_t = 102;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CERT: gpg_err_code_t = 103;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_SEXP: gpg_err_code_t = 104;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_PROTECTION: gpg_err_code_t = 105;
pub const gpg_err_code_t_GPG_ERR_CORRUPTED_PROTECTION: gpg_err_code_t = 106;
pub const gpg_err_code_t_GPG_ERR_AMBIGUOUS_NAME: gpg_err_code_t = 107;
pub const gpg_err_code_t_GPG_ERR_CARD: gpg_err_code_t = 108;
pub const gpg_err_code_t_GPG_ERR_CARD_RESET: gpg_err_code_t = 109;
pub const gpg_err_code_t_GPG_ERR_CARD_REMOVED: gpg_err_code_t = 110;
pub const gpg_err_code_t_GPG_ERR_INV_CARD: gpg_err_code_t = 111;
pub const gpg_err_code_t_GPG_ERR_CARD_NOT_PRESENT: gpg_err_code_t = 112;
pub const gpg_err_code_t_GPG_ERR_NO_PKCS15_APP: gpg_err_code_t = 113;
pub const gpg_err_code_t_GPG_ERR_NOT_CONFIRMED: gpg_err_code_t = 114;
pub const gpg_err_code_t_GPG_ERR_CONFIGURATION: gpg_err_code_t = 115;
pub const gpg_err_code_t_GPG_ERR_NO_POLICY_MATCH: gpg_err_code_t = 116;
pub const gpg_err_code_t_GPG_ERR_INV_INDEX: gpg_err_code_t = 117;
pub const gpg_err_code_t_GPG_ERR_INV_ID: gpg_err_code_t = 118;
pub const gpg_err_code_t_GPG_ERR_NO_SCDAEMON: gpg_err_code_t = 119;
pub const gpg_err_code_t_GPG_ERR_SCDAEMON: gpg_err_code_t = 120;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_PROTOCOL: gpg_err_code_t = 121;
pub const gpg_err_code_t_GPG_ERR_BAD_PIN_METHOD: gpg_err_code_t = 122;
pub const gpg_err_code_t_GPG_ERR_CARD_NOT_INITIALIZED: gpg_err_code_t = 123;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_OPERATION: gpg_err_code_t = 124;
pub const gpg_err_code_t_GPG_ERR_WRONG_KEY_USAGE: gpg_err_code_t = 125;
pub const gpg_err_code_t_GPG_ERR_NOTHING_FOUND: gpg_err_code_t = 126;
pub const gpg_err_code_t_GPG_ERR_WRONG_BLOB_TYPE: gpg_err_code_t = 127;
pub const gpg_err_code_t_GPG_ERR_MISSING_VALUE: gpg_err_code_t = 128;
pub const gpg_err_code_t_GPG_ERR_HARDWARE: gpg_err_code_t = 129;
pub const gpg_err_code_t_GPG_ERR_PIN_BLOCKED: gpg_err_code_t = 130;
pub const gpg_err_code_t_GPG_ERR_USE_CONDITIONS: gpg_err_code_t = 131;
pub const gpg_err_code_t_GPG_ERR_PIN_NOT_SYNCED: gpg_err_code_t = 132;
pub const gpg_err_code_t_GPG_ERR_INV_CRL: gpg_err_code_t = 133;
pub const gpg_err_code_t_GPG_ERR_BAD_BER: gpg_err_code_t = 134;
pub const gpg_err_code_t_GPG_ERR_INV_BER: gpg_err_code_t = 135;
pub const gpg_err_code_t_GPG_ERR_ELEMENT_NOT_FOUND: gpg_err_code_t = 136;
pub const gpg_err_code_t_GPG_ERR_IDENTIFIER_NOT_FOUND: gpg_err_code_t = 137;
pub const gpg_err_code_t_GPG_ERR_INV_TAG: gpg_err_code_t = 138;
pub const gpg_err_code_t_GPG_ERR_INV_LENGTH: gpg_err_code_t = 139;
pub const gpg_err_code_t_GPG_ERR_INV_KEYINFO: gpg_err_code_t = 140;
pub const gpg_err_code_t_GPG_ERR_UNEXPECTED_TAG: gpg_err_code_t = 141;
pub const gpg_err_code_t_GPG_ERR_NOT_DER_ENCODED: gpg_err_code_t = 142;
pub const gpg_err_code_t_GPG_ERR_NO_CMS_OBJ: gpg_err_code_t = 143;
pub const gpg_err_code_t_GPG_ERR_INV_CMS_OBJ: gpg_err_code_t = 144;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_CMS_OBJ: gpg_err_code_t = 145;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CMS_OBJ: gpg_err_code_t = 146;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_ENCODING: gpg_err_code_t = 147;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CMS_VERSION: gpg_err_code_t = 148;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_ALGORITHM: gpg_err_code_t = 149;
pub const gpg_err_code_t_GPG_ERR_INV_ENGINE: gpg_err_code_t = 150;
pub const gpg_err_code_t_GPG_ERR_PUBKEY_NOT_TRUSTED: gpg_err_code_t = 151;
pub const gpg_err_code_t_GPG_ERR_DECRYPT_FAILED: gpg_err_code_t = 152;
pub const gpg_err_code_t_GPG_ERR_KEY_EXPIRED: gpg_err_code_t = 153;
pub const gpg_err_code_t_GPG_ERR_SIG_EXPIRED: gpg_err_code_t = 154;
pub const gpg_err_code_t_GPG_ERR_ENCODING_PROBLEM: gpg_err_code_t = 155;
pub const gpg_err_code_t_GPG_ERR_INV_STATE: gpg_err_code_t = 156;
pub const gpg_err_code_t_GPG_ERR_DUP_VALUE: gpg_err_code_t = 157;
pub const gpg_err_code_t_GPG_ERR_MISSING_ACTION: gpg_err_code_t = 158;
pub const gpg_err_code_t_GPG_ERR_MODULE_NOT_FOUND: gpg_err_code_t = 159;
pub const gpg_err_code_t_GPG_ERR_INV_OID_STRING: gpg_err_code_t = 160;
pub const gpg_err_code_t_GPG_ERR_INV_TIME: gpg_err_code_t = 161;
pub const gpg_err_code_t_GPG_ERR_INV_CRL_OBJ: gpg_err_code_t = 162;
pub const gpg_err_code_t_GPG_ERR_UNSUPPORTED_CRL_VERSION: gpg_err_code_t = 163;
pub const gpg_err_code_t_GPG_ERR_INV_CERT_OBJ: gpg_err_code_t = 164;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_NAME: gpg_err_code_t = 165;
pub const gpg_err_code_t_GPG_ERR_LOCALE_PROBLEM: gpg_err_code_t = 166;
pub const gpg_err_code_t_GPG_ERR_NOT_LOCKED: gpg_err_code_t = 167;
pub const gpg_err_code_t_GPG_ERR_PROTOCOL_VIOLATION: gpg_err_code_t = 168;
pub const gpg_err_code_t_GPG_ERR_INV_MAC: gpg_err_code_t = 169;
pub const gpg_err_code_t_GPG_ERR_INV_REQUEST: gpg_err_code_t = 170;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_EXTN: gpg_err_code_t = 171;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_CRIT_EXTN: gpg_err_code_t = 172;
pub const gpg_err_code_t_GPG_ERR_LOCKED: gpg_err_code_t = 173;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_OPTION: gpg_err_code_t = 174;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_COMMAND: gpg_err_code_t = 175;
pub const gpg_err_code_t_GPG_ERR_NOT_OPERATIONAL: gpg_err_code_t = 176;
pub const gpg_err_code_t_GPG_ERR_NO_PASSPHRASE: gpg_err_code_t = 177;
pub const gpg_err_code_t_GPG_ERR_NO_PIN: gpg_err_code_t = 178;
pub const gpg_err_code_t_GPG_ERR_NOT_ENABLED: gpg_err_code_t = 179;
pub const gpg_err_code_t_GPG_ERR_NO_ENGINE: gpg_err_code_t = 180;
pub const gpg_err_code_t_GPG_ERR_MISSING_KEY: gpg_err_code_t = 181;
pub const gpg_err_code_t_GPG_ERR_TOO_MANY: gpg_err_code_t = 182;
pub const gpg_err_code_t_GPG_ERR_LIMIT_REACHED: gpg_err_code_t = 183;
pub const gpg_err_code_t_GPG_ERR_NOT_INITIALIZED: gpg_err_code_t = 184;
pub const gpg_err_code_t_GPG_ERR_MISSING_ISSUER_CERT: gpg_err_code_t = 185;
pub const gpg_err_code_t_GPG_ERR_NO_KEYSERVER: gpg_err_code_t = 186;
pub const gpg_err_code_t_GPG_ERR_INV_CURVE: gpg_err_code_t = 187;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_CURVE: gpg_err_code_t = 188;
pub const gpg_err_code_t_GPG_ERR_DUP_KEY: gpg_err_code_t = 189;
pub const gpg_err_code_t_GPG_ERR_AMBIGUOUS: gpg_err_code_t = 190;
pub const gpg_err_code_t_GPG_ERR_NO_CRYPT_CTX: gpg_err_code_t = 191;
pub const gpg_err_code_t_GPG_ERR_WRONG_CRYPT_CTX: gpg_err_code_t = 192;
pub const gpg_err_code_t_GPG_ERR_BAD_CRYPT_CTX: gpg_err_code_t = 193;
pub const gpg_err_code_t_GPG_ERR_CRYPT_CTX_CONFLICT: gpg_err_code_t = 194;
pub const gpg_err_code_t_GPG_ERR_BROKEN_PUBKEY: gpg_err_code_t = 195;
pub const gpg_err_code_t_GPG_ERR_BROKEN_SECKEY: gpg_err_code_t = 196;
pub const gpg_err_code_t_GPG_ERR_MAC_ALGO: gpg_err_code_t = 197;
pub const gpg_err_code_t_GPG_ERR_FULLY_CANCELED: gpg_err_code_t = 198;
pub const gpg_err_code_t_GPG_ERR_UNFINISHED: gpg_err_code_t = 199;
pub const gpg_err_code_t_GPG_ERR_BUFFER_TOO_SHORT: gpg_err_code_t = 200;
pub const gpg_err_code_t_GPG_ERR_SEXP_INV_LEN_SPEC: gpg_err_code_t = 201;
pub const gpg_err_code_t_GPG_ERR_SEXP_STRING_TOO_LONG: gpg_err_code_t = 202;
pub const gpg_err_code_t_GPG_ERR_SEXP_UNMATCHED_PAREN: gpg_err_code_t = 203;
pub const gpg_err_code_t_GPG_ERR_SEXP_NOT_CANONICAL: gpg_err_code_t = 204;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_CHARACTER: gpg_err_code_t = 205;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_QUOTATION: gpg_err_code_t = 206;
pub const gpg_err_code_t_GPG_ERR_SEXP_ZERO_PREFIX: gpg_err_code_t = 207;
pub const gpg_err_code_t_GPG_ERR_SEXP_NESTED_DH: gpg_err_code_t = 208;
pub const gpg_err_code_t_GPG_ERR_SEXP_UNMATCHED_DH: gpg_err_code_t = 209;
pub const gpg_err_code_t_GPG_ERR_SEXP_UNEXPECTED_PUNC: gpg_err_code_t = 210;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_HEX_CHAR: gpg_err_code_t = 211;
pub const gpg_err_code_t_GPG_ERR_SEXP_ODD_HEX_NUMBERS: gpg_err_code_t = 212;
pub const gpg_err_code_t_GPG_ERR_SEXP_BAD_OCT_CHAR: gpg_err_code_t = 213;
pub const gpg_err_code_t_GPG_ERR_SUBKEYS_EXP_OR_REV: gpg_err_code_t = 217;
pub const gpg_err_code_t_GPG_ERR_DB_CORRUPTED: gpg_err_code_t = 218;
pub const gpg_err_code_t_GPG_ERR_SERVER_FAILED: gpg_err_code_t = 219;
pub const gpg_err_code_t_GPG_ERR_NO_NAME: gpg_err_code_t = 220;
pub const gpg_err_code_t_GPG_ERR_NO_KEY: gpg_err_code_t = 221;
pub const gpg_err_code_t_GPG_ERR_LEGACY_KEY: gpg_err_code_t = 222;
pub const gpg_err_code_t_GPG_ERR_REQUEST_TOO_SHORT: gpg_err_code_t = 223;
pub const gpg_err_code_t_GPG_ERR_REQUEST_TOO_LONG: gpg_err_code_t = 224;
pub const gpg_err_code_t_GPG_ERR_OBJ_TERM_STATE: gpg_err_code_t = 225;
pub const gpg_err_code_t_GPG_ERR_NO_CERT_CHAIN: gpg_err_code_t = 226;
pub const gpg_err_code_t_GPG_ERR_CERT_TOO_LARGE: gpg_err_code_t = 227;
pub const gpg_err_code_t_GPG_ERR_INV_RECORD: gpg_err_code_t = 228;
pub const gpg_err_code_t_GPG_ERR_BAD_MAC: gpg_err_code_t = 229;
pub const gpg_err_code_t_GPG_ERR_UNEXPECTED_MSG: gpg_err_code_t = 230;
pub const gpg_err_code_t_GPG_ERR_COMPR_FAILED: gpg_err_code_t = 231;
pub const gpg_err_code_t_GPG_ERR_WOULD_WRAP: gpg_err_code_t = 232;
pub const gpg_err_code_t_GPG_ERR_FATAL_ALERT: gpg_err_code_t = 233;
pub const gpg_err_code_t_GPG_ERR_NO_CIPHER: gpg_err_code_t = 234;
pub const gpg_err_code_t_GPG_ERR_MISSING_CLIENT_CERT: gpg_err_code_t = 235;
pub const gpg_err_code_t_GPG_ERR_CLOSE_NOTIFY: gpg_err_code_t = 236;
pub const gpg_err_code_t_GPG_ERR_TICKET_EXPIRED: gpg_err_code_t = 237;
pub const gpg_err_code_t_GPG_ERR_BAD_TICKET: gpg_err_code_t = 238;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_IDENTITY: gpg_err_code_t = 239;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CERT: gpg_err_code_t = 240;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CERT_REQ: gpg_err_code_t = 241;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CERT_VER: gpg_err_code_t = 242;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CHANGE_CIPHER: gpg_err_code_t = 243;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CLIENT_HELLO: gpg_err_code_t = 244;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_SERVER_HELLO: gpg_err_code_t = 245;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_SERVER_HELLO_DONE: gpg_err_code_t = 246;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_FINISHED: gpg_err_code_t = 247;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_SERVER_KEX: gpg_err_code_t = 248;
pub const gpg_err_code_t_GPG_ERR_BAD_HS_CLIENT_KEX: gpg_err_code_t = 249;
pub const gpg_err_code_t_GPG_ERR_BOGUS_STRING: gpg_err_code_t = 250;
pub const gpg_err_code_t_GPG_ERR_FORBIDDEN: gpg_err_code_t = 251;
pub const gpg_err_code_t_GPG_ERR_KEY_DISABLED: gpg_err_code_t = 252;
pub const gpg_err_code_t_GPG_ERR_KEY_ON_CARD: gpg_err_code_t = 253;
pub const gpg_err_code_t_GPG_ERR_INV_LOCK_OBJ: gpg_err_code_t = 254;
pub const gpg_err_code_t_GPG_ERR_TRUE: gpg_err_code_t = 255;
pub const gpg_err_code_t_GPG_ERR_FALSE: gpg_err_code_t = 256;
pub const gpg_err_code_t_GPG_ERR_ASS_GENERAL: gpg_err_code_t = 257;
pub const gpg_err_code_t_GPG_ERR_ASS_ACCEPT_FAILED: gpg_err_code_t = 258;
pub const gpg_err_code_t_GPG_ERR_ASS_CONNECT_FAILED: gpg_err_code_t = 259;
pub const gpg_err_code_t_GPG_ERR_ASS_INV_RESPONSE: gpg_err_code_t = 260;
pub const gpg_err_code_t_GPG_ERR_ASS_INV_VALUE: gpg_err_code_t = 261;
pub const gpg_err_code_t_GPG_ERR_ASS_INCOMPLETE_LINE: gpg_err_code_t = 262;
pub const gpg_err_code_t_GPG_ERR_ASS_LINE_TOO_LONG: gpg_err_code_t = 263;
pub const gpg_err_code_t_GPG_ERR_ASS_NESTED_COMMANDS: gpg_err_code_t = 264;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_DATA_CB: gpg_err_code_t = 265;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_INQUIRE_CB: gpg_err_code_t = 266;
pub const gpg_err_code_t_GPG_ERR_ASS_NOT_A_SERVER: gpg_err_code_t = 267;
pub const gpg_err_code_t_GPG_ERR_ASS_NOT_A_CLIENT: gpg_err_code_t = 268;
pub const gpg_err_code_t_GPG_ERR_ASS_SERVER_START: gpg_err_code_t = 269;
pub const gpg_err_code_t_GPG_ERR_ASS_READ_ERROR: gpg_err_code_t = 270;
pub const gpg_err_code_t_GPG_ERR_ASS_WRITE_ERROR: gpg_err_code_t = 271;
pub const gpg_err_code_t_GPG_ERR_ASS_TOO_MUCH_DATA: gpg_err_code_t = 273;
pub const gpg_err_code_t_GPG_ERR_ASS_UNEXPECTED_CMD: gpg_err_code_t = 274;
pub const gpg_err_code_t_GPG_ERR_ASS_UNKNOWN_CMD: gpg_err_code_t = 275;
pub const gpg_err_code_t_GPG_ERR_ASS_SYNTAX: gpg_err_code_t = 276;
pub const gpg_err_code_t_GPG_ERR_ASS_CANCELED: gpg_err_code_t = 277;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_INPUT: gpg_err_code_t = 278;
pub const gpg_err_code_t_GPG_ERR_ASS_NO_OUTPUT: gpg_err_code_t = 279;
pub const gpg_err_code_t_GPG_ERR_ASS_PARAMETER: gpg_err_code_t = 280;
pub const gpg_err_code_t_GPG_ERR_ASS_UNKNOWN_INQUIRE: gpg_err_code_t = 281;
pub const gpg_err_code_t_GPG_ERR_ENGINE_TOO_OLD: gpg_err_code_t = 300;
pub const gpg_err_code_t_GPG_ERR_WINDOW_TOO_SMALL: gpg_err_code_t = 301;
pub const gpg_err_code_t_GPG_ERR_WINDOW_TOO_LARGE: gpg_err_code_t = 302;
pub const gpg_err_code_t_GPG_ERR_MISSING_ENVVAR: gpg_err_code_t = 303;
pub const gpg_err_code_t_GPG_ERR_USER_ID_EXISTS: gpg_err_code_t = 304;
pub const gpg_err_code_t_GPG_ERR_NAME_EXISTS: gpg_err_code_t = 305;
pub const gpg_err_code_t_GPG_ERR_DUP_NAME: gpg_err_code_t = 306;
pub const gpg_err_code_t_GPG_ERR_TOO_YOUNG: gpg_err_code_t = 307;
pub const gpg_err_code_t_GPG_ERR_TOO_OLD: gpg_err_code_t = 308;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_FLAG: gpg_err_code_t = 309;
pub const gpg_err_code_t_GPG_ERR_INV_ORDER: gpg_err_code_t = 310;
pub const gpg_err_code_t_GPG_ERR_ALREADY_FETCHED: gpg_err_code_t = 311;
pub const gpg_err_code_t_GPG_ERR_TRY_LATER: gpg_err_code_t = 312;
pub const gpg_err_code_t_GPG_ERR_WRONG_NAME: gpg_err_code_t = 313;
pub const gpg_err_code_t_GPG_ERR_NO_AUTH: gpg_err_code_t = 314;
pub const gpg_err_code_t_GPG_ERR_BAD_AUTH: gpg_err_code_t = 315;
pub const gpg_err_code_t_GPG_ERR_NO_KEYBOXD: gpg_err_code_t = 316;
pub const gpg_err_code_t_GPG_ERR_KEYBOXD: gpg_err_code_t = 317;
pub const gpg_err_code_t_GPG_ERR_NO_SERVICE: gpg_err_code_t = 318;
pub const gpg_err_code_t_GPG_ERR_SERVICE: gpg_err_code_t = 319;
pub const gpg_err_code_t_GPG_ERR_SYSTEM_BUG: gpg_err_code_t = 666;
pub const gpg_err_code_t_GPG_ERR_DNS_UNKNOWN: gpg_err_code_t = 711;
pub const gpg_err_code_t_GPG_ERR_DNS_SECTION: gpg_err_code_t = 712;
pub const gpg_err_code_t_GPG_ERR_DNS_ADDRESS: gpg_err_code_t = 713;
pub const gpg_err_code_t_GPG_ERR_DNS_NO_QUERY: gpg_err_code_t = 714;
pub const gpg_err_code_t_GPG_ERR_DNS_NO_ANSWER: gpg_err_code_t = 715;
pub const gpg_err_code_t_GPG_ERR_DNS_CLOSED: gpg_err_code_t = 716;
pub const gpg_err_code_t_GPG_ERR_DNS_VERIFY: gpg_err_code_t = 717;
pub const gpg_err_code_t_GPG_ERR_DNS_TIMEOUT: gpg_err_code_t = 718;
pub const gpg_err_code_t_GPG_ERR_LDAP_GENERAL: gpg_err_code_t = 721;
pub const gpg_err_code_t_GPG_ERR_LDAP_ATTR_GENERAL: gpg_err_code_t = 722;
pub const gpg_err_code_t_GPG_ERR_LDAP_NAME_GENERAL: gpg_err_code_t = 723;
pub const gpg_err_code_t_GPG_ERR_LDAP_SECURITY_GENERAL: gpg_err_code_t = 724;
pub const gpg_err_code_t_GPG_ERR_LDAP_SERVICE_GENERAL: gpg_err_code_t = 725;
pub const gpg_err_code_t_GPG_ERR_LDAP_UPDATE_GENERAL: gpg_err_code_t = 726;
pub const gpg_err_code_t_GPG_ERR_LDAP_E_GENERAL: gpg_err_code_t = 727;
pub const gpg_err_code_t_GPG_ERR_LDAP_X_GENERAL: gpg_err_code_t = 728;
pub const gpg_err_code_t_GPG_ERR_LDAP_OTHER_GENERAL: gpg_err_code_t = 729;
pub const gpg_err_code_t_GPG_ERR_LDAP_X_CONNECTING: gpg_err_code_t = 750;
pub const gpg_err_code_t_GPG_ERR_LDAP_REFERRAL_LIMIT: gpg_err_code_t = 751;
pub const gpg_err_code_t_GPG_ERR_LDAP_CLIENT_LOOP: gpg_err_code_t = 752;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_RESULTS: gpg_err_code_t = 754;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONTROL_NOT_FOUND: gpg_err_code_t = 755;
pub const gpg_err_code_t_GPG_ERR_LDAP_NOT_SUPPORTED: gpg_err_code_t = 756;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONNECT: gpg_err_code_t = 757;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_MEMORY: gpg_err_code_t = 758;
pub const gpg_err_code_t_GPG_ERR_LDAP_PARAM: gpg_err_code_t = 759;
pub const gpg_err_code_t_GPG_ERR_LDAP_USER_CANCELLED: gpg_err_code_t = 760;
pub const gpg_err_code_t_GPG_ERR_LDAP_FILTER: gpg_err_code_t = 761;
pub const gpg_err_code_t_GPG_ERR_LDAP_AUTH_UNKNOWN: gpg_err_code_t = 762;
pub const gpg_err_code_t_GPG_ERR_LDAP_TIMEOUT: gpg_err_code_t = 763;
pub const gpg_err_code_t_GPG_ERR_LDAP_DECODING: gpg_err_code_t = 764;
pub const gpg_err_code_t_GPG_ERR_LDAP_ENCODING: gpg_err_code_t = 765;
pub const gpg_err_code_t_GPG_ERR_LDAP_LOCAL: gpg_err_code_t = 766;
pub const gpg_err_code_t_GPG_ERR_LDAP_SERVER_DOWN: gpg_err_code_t = 767;
pub const gpg_err_code_t_GPG_ERR_LDAP_SUCCESS: gpg_err_code_t = 768;
pub const gpg_err_code_t_GPG_ERR_LDAP_OPERATIONS: gpg_err_code_t = 769;
pub const gpg_err_code_t_GPG_ERR_LDAP_PROTOCOL: gpg_err_code_t = 770;
pub const gpg_err_code_t_GPG_ERR_LDAP_TIMELIMIT: gpg_err_code_t = 771;
pub const gpg_err_code_t_GPG_ERR_LDAP_SIZELIMIT: gpg_err_code_t = 772;
pub const gpg_err_code_t_GPG_ERR_LDAP_COMPARE_FALSE: gpg_err_code_t = 773;
pub const gpg_err_code_t_GPG_ERR_LDAP_COMPARE_TRUE: gpg_err_code_t = 774;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNSUPPORTED_AUTH: gpg_err_code_t = 775;
pub const gpg_err_code_t_GPG_ERR_LDAP_STRONG_AUTH_RQRD: gpg_err_code_t = 776;
pub const gpg_err_code_t_GPG_ERR_LDAP_PARTIAL_RESULTS: gpg_err_code_t = 777;
pub const gpg_err_code_t_GPG_ERR_LDAP_REFERRAL: gpg_err_code_t = 778;
pub const gpg_err_code_t_GPG_ERR_LDAP_ADMINLIMIT: gpg_err_code_t = 779;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN: gpg_err_code_t = 780;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONFIDENT_RQRD: gpg_err_code_t = 781;
pub const gpg_err_code_t_GPG_ERR_LDAP_SASL_BIND_INPROG: gpg_err_code_t = 782;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE: gpg_err_code_t = 784;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNDEFINED_TYPE: gpg_err_code_t = 785;
pub const gpg_err_code_t_GPG_ERR_LDAP_BAD_MATCHING: gpg_err_code_t = 786;
pub const gpg_err_code_t_GPG_ERR_LDAP_CONST_VIOLATION: gpg_err_code_t = 787;
pub const gpg_err_code_t_GPG_ERR_LDAP_TYPE_VALUE_EXISTS: gpg_err_code_t = 788;
pub const gpg_err_code_t_GPG_ERR_LDAP_INV_SYNTAX: gpg_err_code_t = 789;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_SUCH_OBJ: gpg_err_code_t = 800;
pub const gpg_err_code_t_GPG_ERR_LDAP_ALIAS_PROBLEM: gpg_err_code_t = 801;
pub const gpg_err_code_t_GPG_ERR_LDAP_INV_DN_SYNTAX: gpg_err_code_t = 802;
pub const gpg_err_code_t_GPG_ERR_LDAP_IS_LEAF: gpg_err_code_t = 803;
pub const gpg_err_code_t_GPG_ERR_LDAP_ALIAS_DEREF: gpg_err_code_t = 804;
pub const gpg_err_code_t_GPG_ERR_LDAP_X_PROXY_AUTH_FAIL: gpg_err_code_t = 815;
pub const gpg_err_code_t_GPG_ERR_LDAP_BAD_AUTH: gpg_err_code_t = 816;
pub const gpg_err_code_t_GPG_ERR_LDAP_INV_CREDENTIALS: gpg_err_code_t = 817;
pub const gpg_err_code_t_GPG_ERR_LDAP_INSUFFICIENT_ACC: gpg_err_code_t = 818;
pub const gpg_err_code_t_GPG_ERR_LDAP_BUSY: gpg_err_code_t = 819;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNAVAILABLE: gpg_err_code_t = 820;
pub const gpg_err_code_t_GPG_ERR_LDAP_UNWILL_TO_PERFORM: gpg_err_code_t = 821;
pub const gpg_err_code_t_GPG_ERR_LDAP_LOOP_DETECT: gpg_err_code_t = 822;
pub const gpg_err_code_t_GPG_ERR_LDAP_NAMING_VIOLATION: gpg_err_code_t = 832;
pub const gpg_err_code_t_GPG_ERR_LDAP_OBJ_CLS_VIOLATION: gpg_err_code_t = 833;
pub const gpg_err_code_t_GPG_ERR_LDAP_NOT_ALLOW_NONLEAF: gpg_err_code_t = 834;
pub const gpg_err_code_t_GPG_ERR_LDAP_NOT_ALLOW_ON_RDN: gpg_err_code_t = 835;
pub const gpg_err_code_t_GPG_ERR_LDAP_ALREADY_EXISTS: gpg_err_code_t = 836;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_OBJ_CLASS_MODS: gpg_err_code_t = 837;
pub const gpg_err_code_t_GPG_ERR_LDAP_RESULTS_TOO_LARGE: gpg_err_code_t = 838;
pub const gpg_err_code_t_GPG_ERR_LDAP_AFFECTS_MULT_DSAS: gpg_err_code_t = 839;
pub const gpg_err_code_t_GPG_ERR_LDAP_VLV: gpg_err_code_t = 844;
pub const gpg_err_code_t_GPG_ERR_LDAP_OTHER: gpg_err_code_t = 848;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_RESOURCE_LIMIT: gpg_err_code_t = 881;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_SEC_VIOLATION: gpg_err_code_t = 882;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_INV_DATA: gpg_err_code_t = 883;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_UNSUP_SCHEME: gpg_err_code_t = 884;
pub const gpg_err_code_t_GPG_ERR_LDAP_CUP_RELOAD: gpg_err_code_t = 885;
pub const gpg_err_code_t_GPG_ERR_LDAP_CANCELLED: gpg_err_code_t = 886;
pub const gpg_err_code_t_GPG_ERR_LDAP_NO_SUCH_OPERATION: gpg_err_code_t = 887;
pub const gpg_err_code_t_GPG_ERR_LDAP_TOO_LATE: gpg_err_code_t = 888;
pub const gpg_err_code_t_GPG_ERR_LDAP_CANNOT_CANCEL: gpg_err_code_t = 889;
pub const gpg_err_code_t_GPG_ERR_LDAP_ASSERTION_FAILED: gpg_err_code_t = 890;
pub const gpg_err_code_t_GPG_ERR_LDAP_PROX_AUTH_DENIED: gpg_err_code_t = 891;
pub const gpg_err_code_t_GPG_ERR_USER_1: gpg_err_code_t = 1024;
pub const gpg_err_code_t_GPG_ERR_USER_2: gpg_err_code_t = 1025;
pub const gpg_err_code_t_GPG_ERR_USER_3: gpg_err_code_t = 1026;
pub const gpg_err_code_t_GPG_ERR_USER_4: gpg_err_code_t = 1027;
pub const gpg_err_code_t_GPG_ERR_USER_5: gpg_err_code_t = 1028;
pub const gpg_err_code_t_GPG_ERR_USER_6: gpg_err_code_t = 1029;
pub const gpg_err_code_t_GPG_ERR_USER_7: gpg_err_code_t = 1030;
pub const gpg_err_code_t_GPG_ERR_USER_8: gpg_err_code_t = 1031;
pub const gpg_err_code_t_GPG_ERR_USER_9: gpg_err_code_t = 1032;
pub const gpg_err_code_t_GPG_ERR_USER_10: gpg_err_code_t = 1033;
pub const gpg_err_code_t_GPG_ERR_USER_11: gpg_err_code_t = 1034;
pub const gpg_err_code_t_GPG_ERR_USER_12: gpg_err_code_t = 1035;
pub const gpg_err_code_t_GPG_ERR_USER_13: gpg_err_code_t = 1036;
pub const gpg_err_code_t_GPG_ERR_USER_14: gpg_err_code_t = 1037;
pub const gpg_err_code_t_GPG_ERR_USER_15: gpg_err_code_t = 1038;
pub const gpg_err_code_t_GPG_ERR_USER_16: gpg_err_code_t = 1039;
pub const gpg_err_code_t_GPG_ERR_SQL_OK: gpg_err_code_t = 1500;
pub const gpg_err_code_t_GPG_ERR_SQL_ERROR: gpg_err_code_t = 1501;
pub const gpg_err_code_t_GPG_ERR_SQL_INTERNAL: gpg_err_code_t = 1502;
pub const gpg_err_code_t_GPG_ERR_SQL_PERM: gpg_err_code_t = 1503;
pub const gpg_err_code_t_GPG_ERR_SQL_ABORT: gpg_err_code_t = 1504;
pub const gpg_err_code_t_GPG_ERR_SQL_BUSY: gpg_err_code_t = 1505;
pub const gpg_err_code_t_GPG_ERR_SQL_LOCKED: gpg_err_code_t = 1506;
pub const gpg_err_code_t_GPG_ERR_SQL_NOMEM: gpg_err_code_t = 1507;
pub const gpg_err_code_t_GPG_ERR_SQL_READONLY: gpg_err_code_t = 1508;
pub const gpg_err_code_t_GPG_ERR_SQL_INTERRUPT: gpg_err_code_t = 1509;
pub const gpg_err_code_t_GPG_ERR_SQL_IOERR: gpg_err_code_t = 1510;
pub const gpg_err_code_t_GPG_ERR_SQL_CORRUPT: gpg_err_code_t = 1511;
pub const gpg_err_code_t_GPG_ERR_SQL_NOTFOUND: gpg_err_code_t = 1512;
pub const gpg_err_code_t_GPG_ERR_SQL_FULL: gpg_err_code_t = 1513;
pub const gpg_err_code_t_GPG_ERR_SQL_CANTOPEN: gpg_err_code_t = 1514;
pub const gpg_err_code_t_GPG_ERR_SQL_PROTOCOL: gpg_err_code_t = 1515;
pub const gpg_err_code_t_GPG_ERR_SQL_EMPTY: gpg_err_code_t = 1516;
pub const gpg_err_code_t_GPG_ERR_SQL_SCHEMA: gpg_err_code_t = 1517;
pub const gpg_err_code_t_GPG_ERR_SQL_TOOBIG: gpg_err_code_t = 1518;
pub const gpg_err_code_t_GPG_ERR_SQL_CONSTRAINT: gpg_err_code_t = 1519;
pub const gpg_err_code_t_GPG_ERR_SQL_MISMATCH: gpg_err_code_t = 1520;
pub const gpg_err_code_t_GPG_ERR_SQL_MISUSE: gpg_err_code_t = 1521;
pub const gpg_err_code_t_GPG_ERR_SQL_NOLFS: gpg_err_code_t = 1522;
pub const gpg_err_code_t_GPG_ERR_SQL_AUTH: gpg_err_code_t = 1523;
pub const gpg_err_code_t_GPG_ERR_SQL_FORMAT: gpg_err_code_t = 1524;
pub const gpg_err_code_t_GPG_ERR_SQL_RANGE: gpg_err_code_t = 1525;
pub const gpg_err_code_t_GPG_ERR_SQL_NOTADB: gpg_err_code_t = 1526;
pub const gpg_err_code_t_GPG_ERR_SQL_NOTICE: gpg_err_code_t = 1527;
pub const gpg_err_code_t_GPG_ERR_SQL_WARNING: gpg_err_code_t = 1528;
pub const gpg_err_code_t_GPG_ERR_SQL_ROW: gpg_err_code_t = 1600;
pub const gpg_err_code_t_GPG_ERR_SQL_DONE: gpg_err_code_t = 1601;
pub const gpg_err_code_t_GPG_ERR_MISSING_ERRNO: gpg_err_code_t = 16381;
pub const gpg_err_code_t_GPG_ERR_UNKNOWN_ERRNO: gpg_err_code_t = 16382;
pub const gpg_err_code_t_GPG_ERR_EOF: gpg_err_code_t = 16383;
pub const gpg_err_code_t_GPG_ERR_E2BIG: gpg_err_code_t = 32768;
pub const gpg_err_code_t_GPG_ERR_EACCES: gpg_err_code_t = 32769;
pub const gpg_err_code_t_GPG_ERR_EADDRINUSE: gpg_err_code_t = 32770;
pub const gpg_err_code_t_GPG_ERR_EADDRNOTAVAIL: gpg_err_code_t = 32771;
pub const gpg_err_code_t_GPG_ERR_EADV: gpg_err_code_t = 32772;
pub const gpg_err_code_t_GPG_ERR_EAFNOSUPPORT: gpg_err_code_t = 32773;
pub const gpg_err_code_t_GPG_ERR_EAGAIN: gpg_err_code_t = 32774;
pub const gpg_err_code_t_GPG_ERR_EALREADY: gpg_err_code_t = 32775;
pub const gpg_err_code_t_GPG_ERR_EAUTH: gpg_err_code_t = 32776;
pub const gpg_err_code_t_GPG_ERR_EBACKGROUND: gpg_err_code_t = 32777;
pub const gpg_err_code_t_GPG_ERR_EBADE: gpg_err_code_t = 32778;
pub const gpg_err_code_t_GPG_ERR_EBADF: gpg_err_code_t = 32779;
pub const gpg_err_code_t_GPG_ERR_EBADFD: gpg_err_code_t = 32780;
pub const gpg_err_code_t_GPG_ERR_EBADMSG: gpg_err_code_t = 32781;
pub const gpg_err_code_t_GPG_ERR_EBADR: gpg_err_code_t = 32782;
pub const gpg_err_code_t_GPG_ERR_EBADRPC: gpg_err_code_t = 32783;
pub const gpg_err_code_t_GPG_ERR_EBADRQC: gpg_err_code_t = 32784;
pub const gpg_err_code_t_GPG_ERR_EBADSLT: gpg_err_code_t = 32785;
pub const gpg_err_code_t_GPG_ERR_EBFONT: gpg_err_code_t = 32786;
pub const gpg_err_code_t_GPG_ERR_EBUSY: gpg_err_code_t = 32787;
pub const gpg_err_code_t_GPG_ERR_ECANCELED: gpg_err_code_t = 32788;
pub const gpg_err_code_t_GPG_ERR_ECHILD: gpg_err_code_t = 32789;
pub const gpg_err_code_t_GPG_ERR_ECHRNG: gpg_err_code_t = 32790;
pub const gpg_err_code_t_GPG_ERR_ECOMM: gpg_err_code_t = 32791;
pub const gpg_err_code_t_GPG_ERR_ECONNABORTED: gpg_err_code_t = 32792;
pub const gpg_err_code_t_GPG_ERR_ECONNREFUSED: gpg_err_code_t = 32793;
pub const gpg_err_code_t_GPG_ERR_ECONNRESET: gpg_err_code_t = 32794;
pub const gpg_err_code_t_GPG_ERR_ED: gpg_err_code_t = 32795;
pub const gpg_err_code_t_GPG_ERR_EDEADLK: gpg_err_code_t = 32796;
pub const gpg_err_code_t_GPG_ERR_EDEADLOCK: gpg_err_code_t = 32797;
pub const gpg_err_code_t_GPG_ERR_EDESTADDRREQ: gpg_err_code_t = 32798;
pub const gpg_err_code_t_GPG_ERR_EDIED: gpg_err_code_t = 32799;
pub const gpg_err_code_t_GPG_ERR_EDOM: gpg_err_code_t = 32800;
pub const gpg_err_code_t_GPG_ERR_EDOTDOT: gpg_err_code_t = 32801;
pub const gpg_err_code_t_GPG_ERR_EDQUOT: gpg_err_code_t = 32802;
pub const gpg_err_code_t_GPG_ERR_EEXIST: gpg_err_code_t = 32803;
pub const gpg_err_code_t_GPG_ERR_EFAULT: gpg_err_code_t = 32804;
pub const gpg_err_code_t_GPG_ERR_EFBIG: gpg_err_code_t = 32805;
pub const gpg_err_code_t_GPG_ERR_EFTYPE: gpg_err_code_t = 32806;
pub const gpg_err_code_t_GPG_ERR_EGRATUITOUS: gpg_err_code_t = 32807;
pub const gpg_err_code_t_GPG_ERR_EGREGIOUS: gpg_err_code_t = 32808;
pub const gpg_err_code_t_GPG_ERR_EHOSTDOWN: gpg_err_code_t = 32809;
pub const gpg_err_code_t_GPG_ERR_EHOSTUNREACH: gpg_err_code_t = 32810;
pub const gpg_err_code_t_GPG_ERR_EIDRM: gpg_err_code_t = 32811;
pub const gpg_err_code_t_GPG_ERR_EIEIO: gpg_err_code_t = 32812;
pub const gpg_err_code_t_GPG_ERR_EILSEQ: gpg_err_code_t = 32813;
pub const gpg_err_code_t_GPG_ERR_EINPROGRESS: gpg_err_code_t = 32814;
pub const gpg_err_code_t_GPG_ERR_EINTR: gpg_err_code_t = 32815;
pub const gpg_err_code_t_GPG_ERR_EINVAL: gpg_err_code_t = 32816;
pub const gpg_err_code_t_GPG_ERR_EIO: gpg_err_code_t = 32817;
pub const gpg_err_code_t_GPG_ERR_EISCONN: gpg_err_code_t = 32818;
pub const gpg_err_code_t_GPG_ERR_EISDIR: gpg_err_code_t = 32819;
pub const gpg_err_code_t_GPG_ERR_EISNAM: gpg_err_code_t = 32820;
pub const gpg_err_code_t_GPG_ERR_EL2HLT: gpg_err_code_t = 32821;
pub const gpg_err_code_t_GPG_ERR_EL2NSYNC: gpg_err_code_t = 32822;
pub const gpg_err_code_t_GPG_ERR_EL3HLT: gpg_err_code_t = 32823;
pub const gpg_err_code_t_GPG_ERR_EL3RST: gpg_err_code_t = 32824;
pub const gpg_err_code_t_GPG_ERR_ELIBACC: gpg_err_code_t = 32825;
pub const gpg_err_code_t_GPG_ERR_ELIBBAD: gpg_err_code_t = 32826;
pub const gpg_err_code_t_GPG_ERR_ELIBEXEC: gpg_err_code_t = 32827;
pub const gpg_err_code_t_GPG_ERR_ELIBMAX: gpg_err_code_t = 32828;
pub const gpg_err_code_t_GPG_ERR_ELIBSCN: gpg_err_code_t = 32829;
pub const gpg_err_code_t_GPG_ERR_ELNRNG: gpg_err_code_t = 32830;
pub const gpg_err_code_t_GPG_ERR_ELOOP: gpg_err_code_t = 32831;
pub const gpg_err_code_t_GPG_ERR_EMEDIUMTYPE: gpg_err_code_t = 32832;
pub const gpg_err_code_t_GPG_ERR_EMFILE: gpg_err_code_t = 32833;
pub const gpg_err_code_t_GPG_ERR_EMLINK: gpg_err_code_t = 32834;
pub const gpg_err_code_t_GPG_ERR_EMSGSIZE: gpg_err_code_t = 32835;
pub const gpg_err_code_t_GPG_ERR_EMULTIHOP: gpg_err_code_t = 32836;
pub const gpg_err_code_t_GPG_ERR_ENAMETOOLONG: gpg_err_code_t = 32837;
pub const gpg_err_code_t_GPG_ERR_ENAVAIL: gpg_err_code_t = 32838;
pub const gpg_err_code_t_GPG_ERR_ENEEDAUTH: gpg_err_code_t = 32839;
pub const gpg_err_code_t_GPG_ERR_ENETDOWN: gpg_err_code_t = 32840;
pub const gpg_err_code_t_GPG_ERR_ENETRESET: gpg_err_code_t = 32841;
pub const gpg_err_code_t_GPG_ERR_ENETUNREACH: gpg_err_code_t = 32842;
pub const gpg_err_code_t_GPG_ERR_ENFILE: gpg_err_code_t = 32843;
pub const gpg_err_code_t_GPG_ERR_ENOANO: gpg_err_code_t = 32844;
pub const gpg_err_code_t_GPG_ERR_ENOBUFS: gpg_err_code_t = 32845;
pub const gpg_err_code_t_GPG_ERR_ENOCSI: gpg_err_code_t = 32846;
pub const gpg_err_code_t_GPG_ERR_ENODATA: gpg_err_code_t = 32847;
pub const gpg_err_code_t_GPG_ERR_ENODEV: gpg_err_code_t = 32848;
pub const gpg_err_code_t_GPG_ERR_ENOENT: gpg_err_code_t = 32849;
pub const gpg_err_code_t_GPG_ERR_ENOEXEC: gpg_err_code_t = 32850;
pub const gpg_err_code_t_GPG_ERR_ENOLCK: gpg_err_code_t = 32851;
pub const gpg_err_code_t_GPG_ERR_ENOLINK: gpg_err_code_t = 32852;
pub const gpg_err_code_t_GPG_ERR_ENOMEDIUM: gpg_err_code_t = 32853;
pub const gpg_err_code_t_GPG_ERR_ENOMEM: gpg_err_code_t = 32854;
pub const gpg_err_code_t_GPG_ERR_ENOMSG: gpg_err_code_t = 32855;
pub const gpg_err_code_t_GPG_ERR_ENONET: gpg_err_code_t = 32856;
pub const gpg_err_code_t_GPG_ERR_ENOPKG: gpg_err_code_t = 32857;
pub const gpg_err_code_t_GPG_ERR_ENOPROTOOPT: gpg_err_code_t = 32858;
pub const gpg_err_code_t_GPG_ERR_ENOSPC: gpg_err_code_t = 32859;
pub const gpg_err_code_t_GPG_ERR_ENOSR: gpg_err_code_t = 32860;
pub const gpg_err_code_t_GPG_ERR_ENOSTR: gpg_err_code_t = 32861;
pub const gpg_err_code_t_GPG_ERR_ENOSYS: gpg_err_code_t = 32862;
pub const gpg_err_code_t_GPG_ERR_ENOTBLK: gpg_err_code_t = 32863;
pub const gpg_err_code_t_GPG_ERR_ENOTCONN: gpg_err_code_t = 32864;
pub const gpg_err_code_t_GPG_ERR_ENOTDIR: gpg_err_code_t = 32865;
pub const gpg_err_code_t_GPG_ERR_ENOTEMPTY: gpg_err_code_t = 32866;
pub const gpg_err_code_t_GPG_ERR_ENOTNAM: gpg_err_code_t = 32867;
pub const gpg_err_code_t_GPG_ERR_ENOTSOCK: gpg_err_code_t = 32868;
pub const gpg_err_code_t_GPG_ERR_ENOTSUP: gpg_err_code_t = 32869;
pub const gpg_err_code_t_GPG_ERR_ENOTTY: gpg_err_code_t = 32870;
pub const gpg_err_code_t_GPG_ERR_ENOTUNIQ: gpg_err_code_t = 32871;
pub const gpg_err_code_t_GPG_ERR_ENXIO: gpg_err_code_t = 32872;
pub const gpg_err_code_t_GPG_ERR_EOPNOTSUPP: gpg_err_code_t = 32873;
pub const gpg_err_code_t_GPG_ERR_EOVERFLOW: gpg_err_code_t = 32874;
pub const gpg_err_code_t_GPG_ERR_EPERM: gpg_err_code_t = 32875;
pub const gpg_err_code_t_GPG_ERR_EPFNOSUPPORT: gpg_err_code_t = 32876;
pub const gpg_err_code_t_GPG_ERR_EPIPE: gpg_err_code_t = 32877;
pub const gpg_err_code_t_GPG_ERR_EPROCLIM: gpg_err_code_t = 32878;
pub const gpg_err_code_t_GPG_ERR_EPROCUNAVAIL: gpg_err_code_t = 32879;
pub const gpg_err_code_t_GPG_ERR_EPROGMISMATCH: gpg_err_code_t = 32880;
pub const gpg_err_code_t_GPG_ERR_EPROGUNAVAIL: gpg_err_code_t = 32881;
pub const gpg_err_code_t_GPG_ERR_EPROTO: gpg_err_code_t = 32882;
pub const gpg_err_code_t_GPG_ERR_EPROTONOSUPPORT: gpg_err_code_t = 32883;
pub const gpg_err_code_t_GPG_ERR_EPROTOTYPE: gpg_err_code_t = 32884;
pub const gpg_err_code_t_GPG_ERR_ERANGE: gpg_err_code_t = 32885;
pub const gpg_err_code_t_GPG_ERR_EREMCHG: gpg_err_code_t = 32886;
pub const gpg_err_code_t_GPG_ERR_EREMOTE: gpg_err_code_t = 32887;
pub const gpg_err_code_t_GPG_ERR_EREMOTEIO: gpg_err_code_t = 32888;
pub const gpg_err_code_t_GPG_ERR_ERESTART: gpg_err_code_t = 32889;
pub const gpg_err_code_t_GPG_ERR_EROFS: gpg_err_code_t = 32890;
pub const gpg_err_code_t_GPG_ERR_ERPCMISMATCH: gpg_err_code_t = 32891;
pub const gpg_err_code_t_GPG_ERR_ESHUTDOWN: gpg_err_code_t = 32892;
pub const gpg_err_code_t_GPG_ERR_ESOCKTNOSUPPORT: gpg_err_code_t = 32893;
pub const gpg_err_code_t_GPG_ERR_ESPIPE: gpg_err_code_t = 32894;
pub const gpg_err_code_t_GPG_ERR_ESRCH: gpg_err_code_t = 32895;
pub const gpg_err_code_t_GPG_ERR_ESRMNT: gpg_err_code_t = 32896;
pub const gpg_err_code_t_GPG_ERR_ESTALE: gpg_err_code_t = 32897;
pub const gpg_err_code_t_GPG_ERR_ESTRPIPE: gpg_err_code_t = 32898;
pub const gpg_err_code_t_GPG_ERR_ETIME: gpg_err_code_t = 32899;
pub const gpg_err_code_t_GPG_ERR_ETIMEDOUT: gpg_err_code_t = 32900;
pub const gpg_err_code_t_GPG_ERR_ETOOMANYREFS: gpg_err_code_t = 32901;
pub const gpg_err_code_t_GPG_ERR_ETXTBSY: gpg_err_code_t = 32902;
pub const gpg_err_code_t_GPG_ERR_EUCLEAN: gpg_err_code_t = 32903;
pub const gpg_err_code_t_GPG_ERR_EUNATCH: gpg_err_code_t = 32904;
pub const gpg_err_code_t_GPG_ERR_EUSERS: gpg_err_code_t = 32905;
pub const gpg_err_code_t_GPG_ERR_EWOULDBLOCK: gpg_err_code_t = 32906;
pub const gpg_err_code_t_GPG_ERR_EXDEV: gpg_err_code_t = 32907;
pub const gpg_err_code_t_GPG_ERR_EXFULL: gpg_err_code_t = 32908;
pub const gpg_err_code_t_GPG_ERR_CODE_DIM: gpg_err_code_t = 65536;
pub type gpg_err_code_t = ::std::os::raw::c_uint;
pub type gpg_error_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gpg_err_init() -> gpg_error_t;
}
extern "C" {
    pub fn gpg_err_deinit(mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgrt_set_syscall_clamp(
        pre: ::std::option::Option<unsafe extern "C" fn()>,
        post: ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn gpgrt_get_syscall_clamp(
        r_pre: *mut ::std::option::Option<unsafe extern "C" fn()>,
        r_post: *mut ::std::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    pub fn gpgrt_set_alloc_func(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                a: *mut ::std::os::raw::c_void,
                n: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
    );
}
extern "C" {
    pub fn gpgrt_add_emergency_cleanup(f: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn gpgrt_abort();
}
extern "C" {
    pub fn gpg_strerror(err: gpg_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpg_strerror_r(
        err: gpg_error_t,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpg_strsource(err: gpg_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpg_err_code_from_errno(err: ::std::os::raw::c_int) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpg_err_code_to_errno(code: gpg_err_code_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpg_err_code_from_syserror() -> gpg_err_code_t;
}
extern "C" {
    pub fn gpg_err_set_errno(err: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgrt_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpg_error_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type gpgrt_ssize_t = isize;
pub type gpgrt_off_t = ::std::os::raw::c_long;
extern "C" {
    pub fn gpgrt_realloc(a: *mut ::std::os::raw::c_void, n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_reallocarray(
        a: *mut ::std::os::raw::c_void,
        oldnmemb: usize,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_malloc(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_calloc(n: usize, m: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_strdup(string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_strconcat(s1: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_free(a: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgrt_getenv(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_setenv(
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_mkdir(
        name: *const ::std::os::raw::c_char,
        modestr: *const ::std::os::raw::c_char,
    ) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_chdir(name: *const ::std::os::raw::c_char) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_getcwd() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpgrt_lock_t {
    pub _vers: ::std::os::raw::c_long,
    pub u: gpgrt_lock_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpgrt_lock_t__bindgen_ty_1 {
    pub _priv: [::std::os::raw::c_char; 40usize],
    pub _x_align: ::std::os::raw::c_long,
    pub _xp_align: *mut ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_gpgrt_lock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_lock_t__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(gpgrt_lock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_lock_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_lock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_lock_t__bindgen_ty_1>()))._priv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t__bindgen_ty_1),
            "::",
            stringify!(_priv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_lock_t__bindgen_ty_1>()))._x_align as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t__bindgen_ty_1),
            "::",
            stringify!(_x_align)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_lock_t__bindgen_ty_1>()))._xp_align as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t__bindgen_ty_1),
            "::",
            stringify!(_xp_align)
        )
    );
}
#[test]
fn bindgen_test_layout_gpgrt_lock_t() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_lock_t>(),
        48usize,
        concat!("Size of: ", stringify!(gpgrt_lock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_lock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_lock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_lock_t>()))._vers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t),
            "::",
            stringify!(_vers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_lock_t>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_lock_t),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn gpgrt_lock_init(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_lock(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_trylock(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_unlock(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_lock_destroy(lockhd: *mut gpgrt_lock_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_yield() -> gpg_err_code_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_stream_internal {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt__stream {
    pub flags: _gpgrt__stream__bindgen_ty_1,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub buffer_size: usize,
    pub data_len: usize,
    pub data_offset: usize,
    pub data_flushed: usize,
    pub unread_buffer: *mut ::std::os::raw::c_uchar,
    pub unread_buffer_size: usize,
    pub unread_data_len: usize,
    pub intern: *mut _gpgrt_stream_internal,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt__stream__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout__gpgrt__stream__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt__stream__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_gpgrt__stream__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt__stream__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_gpgrt__stream__bindgen_ty_1))
    );
}
impl _gpgrt__stream__bindgen_ty_1 {
    #[inline]
    pub fn magic(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_magic(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn writing(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_writing(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        magic: ::std::os::raw::c_uint,
        writing: ::std::os::raw::c_uint,
        reserved: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let magic: u32 = unsafe { ::std::mem::transmute(magic) };
            magic as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let writing: u32 = unsafe { ::std::mem::transmute(writing) };
            writing as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__gpgrt__stream() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt__stream>(),
        80usize,
        concat!("Size of: ", stringify!(_gpgrt__stream))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt__stream>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt__stream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).data_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).data_offset as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).data_flushed as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(data_flushed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).unread_buffer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(unread_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt__stream>())).unread_buffer_size as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(unread_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).unread_data_len as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(unread_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt__stream>())).intern as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt__stream),
            "::",
            stringify!(intern)
        )
    );
}
pub type gpgrt_stream_t = *mut _gpgrt__stream;
pub type gpgrt_cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type gpgrt_cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        size: usize,
    ) -> isize,
>;
pub type gpgrt_cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        cookie: *mut ::std::os::raw::c_void,
        pos: *mut gpgrt_off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type gpgrt_cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_cookie_io_functions {
    pub func_read: gpgrt_cookie_read_function_t,
    pub func_write: gpgrt_cookie_write_function_t,
    pub func_seek: gpgrt_cookie_seek_function_t,
    pub func_close: gpgrt_cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__gpgrt_cookie_io_functions() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_cookie_io_functions>(),
        32usize,
        concat!("Size of: ", stringify!(_gpgrt_cookie_io_functions))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_cookie_io_functions>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_cookie_io_functions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_read as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_read)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_write as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_seek as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_cookie_io_functions>())).func_close as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_cookie_io_functions),
            "::",
            stringify!(func_close)
        )
    );
}
pub type gpgrt_cookie_io_functions_t = _gpgrt_cookie_io_functions;
pub const gpgrt_syshd_types_GPGRT_SYSHD_NONE: gpgrt_syshd_types = 0;
pub const gpgrt_syshd_types_GPGRT_SYSHD_FD: gpgrt_syshd_types = 1;
pub const gpgrt_syshd_types_GPGRT_SYSHD_SOCK: gpgrt_syshd_types = 2;
pub const gpgrt_syshd_types_GPGRT_SYSHD_RVID: gpgrt_syshd_types = 3;
pub const gpgrt_syshd_types_GPGRT_SYSHD_HANDLE: gpgrt_syshd_types = 4;
pub type gpgrt_syshd_types = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _gpgrt_syshd {
    pub type_: gpgrt_syshd_types,
    pub u: _gpgrt_syshd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _gpgrt_syshd__bindgen_ty_1 {
    pub fd: ::std::os::raw::c_int,
    pub sock: ::std::os::raw::c_int,
    pub rvid: ::std::os::raw::c_int,
    pub handle: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__gpgrt_syshd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_syshd__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_gpgrt_syshd__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_syshd__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_syshd__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).sock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(sock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).rvid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(rvid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_gpgrt_syshd__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
}
#[test]
fn bindgen_test_layout__gpgrt_syshd() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_syshd>(),
        16usize,
        concat!("Size of: ", stringify!(_gpgrt_syshd))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_syshd>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_syshd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_syshd>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_syshd),
            "::",
            stringify!(u)
        )
    );
}
pub type gpgrt_syshd_t = _gpgrt_syshd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_poll_s {
    pub stream: gpgrt_stream_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__gpgrt_poll_s() {
    assert_eq!(
        ::std::mem::size_of::<_gpgrt_poll_s>(),
        16usize,
        concat!("Size of: ", stringify!(_gpgrt_poll_s))
    );
    assert_eq!(
        ::std::mem::align_of::<_gpgrt_poll_s>(),
        8usize,
        concat!("Alignment of ", stringify!(_gpgrt_poll_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_gpgrt_poll_s>())).stream as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_gpgrt_poll_s),
            "::",
            stringify!(stream)
        )
    );
}
impl _gpgrt_poll_s {
    #[inline]
    pub fn want_read(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_read(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_write(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_write(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_oob(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_oob(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn want_rdhup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_rdhup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserv1(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserv1(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn got_read(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_read(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_write(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_write(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_oob(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_oob(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_rdhup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_rdhup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserv2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserv2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn got_err(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_err(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_hup(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_hup(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn got_nval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_got_nval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserv3(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserv3(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_user(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_read: ::std::os::raw::c_uint,
        want_write: ::std::os::raw::c_uint,
        want_oob: ::std::os::raw::c_uint,
        want_rdhup: ::std::os::raw::c_uint,
        _reserv1: ::std::os::raw::c_uint,
        got_read: ::std::os::raw::c_uint,
        got_write: ::std::os::raw::c_uint,
        got_oob: ::std::os::raw::c_uint,
        got_rdhup: ::std::os::raw::c_uint,
        _reserv2: ::std::os::raw::c_uint,
        got_err: ::std::os::raw::c_uint,
        got_hup: ::std::os::raw::c_uint,
        got_nval: ::std::os::raw::c_uint,
        _reserv3: ::std::os::raw::c_uint,
        ignore: ::std::os::raw::c_uint,
        user: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_read: u32 = unsafe { ::std::mem::transmute(want_read) };
            want_read as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let want_write: u32 = unsafe { ::std::mem::transmute(want_write) };
            want_write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let want_oob: u32 = unsafe { ::std::mem::transmute(want_oob) };
            want_oob as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let want_rdhup: u32 = unsafe { ::std::mem::transmute(want_rdhup) };
            want_rdhup as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _reserv1: u32 = unsafe { ::std::mem::transmute(_reserv1) };
            _reserv1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let got_read: u32 = unsafe { ::std::mem::transmute(got_read) };
            got_read as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let got_write: u32 = unsafe { ::std::mem::transmute(got_write) };
            got_write as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let got_oob: u32 = unsafe { ::std::mem::transmute(got_oob) };
            got_oob as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let got_rdhup: u32 = unsafe { ::std::mem::transmute(got_rdhup) };
            got_rdhup as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let _reserv2: u32 = unsafe { ::std::mem::transmute(_reserv2) };
            _reserv2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let got_err: u32 = unsafe { ::std::mem::transmute(got_err) };
            got_err as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let got_hup: u32 = unsafe { ::std::mem::transmute(got_hup) };
            got_hup as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let got_nval: u32 = unsafe { ::std::mem::transmute(got_nval) };
            got_nval as u64
        });
        __bindgen_bitfield_unit.set(19usize, 4u8, {
            let _reserv3: u32 = unsafe { ::std::mem::transmute(_reserv3) };
            _reserv3 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let ignore: u32 = unsafe { ::std::mem::transmute(ignore) };
            ignore as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let user: u32 = unsafe { ::std::mem::transmute(user) };
            user as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type gpgrt_poll_t = _gpgrt_poll_s;
pub type gpgrt_string_filter_t = ::std::option::Option<
    unsafe extern "C" fn(
        s: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        opaque: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char,
>;
extern "C" {
    pub fn gpgrt_fopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_mopen(
        data: *mut ::std::os::raw::c_void,
        data_n: usize,
        data_len: usize,
        grow: ::std::os::raw::c_uint,
        func_realloc: ::std::option::Option<
            unsafe extern "C" fn(
                mem: *mut ::std::os::raw::c_void,
                size: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        func_free: ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fopenmem(memlimit: usize, mode: *const ::std::os::raw::c_char) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fopenmem_init(
        memlimit: usize,
        mode: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        datalen: usize,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fdopen(
        filedes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fdopen_nc(
        filedes: ::std::os::raw::c_int,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_sysopen(
        syshd: *mut gpgrt_syshd_t,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_sysopen_nc(
        syshd: *mut gpgrt_syshd_t,
        mode: *const ::std::os::raw::c_char,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fpopen(fp: *mut FILE, mode: *const ::std::os::raw::c_char) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fpopen_nc(fp: *mut FILE, mode: *const ::std::os::raw::c_char) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_freopen(
        path: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fopencookie(
        cookie: *mut ::std::os::raw::c_void,
        mode: *const ::std::os::raw::c_char,
        functions: gpgrt_cookie_io_functions_t,
    ) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_fclose(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fclose_snatch(
        stream: gpgrt_stream_t,
        r_buffer: *mut *mut ::std::os::raw::c_void,
        r_buflen: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_onclose(
        stream: gpgrt_stream_t,
        mode: ::std::os::raw::c_int,
        fnc: ::std::option::Option<
            unsafe extern "C" fn(arg1: gpgrt_stream_t, arg2: *mut ::std::os::raw::c_void),
        >,
        fnc_value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fileno(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fileno_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_syshd(stream: gpgrt_stream_t, syshd: *mut gpgrt_syshd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_syshd_unlocked(
        stream: gpgrt_stream_t,
        syshd: *mut gpgrt_syshd_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_set_std_fd(no: ::std::os::raw::c_int, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _gpgrt_get_std_stream(fd: ::std::os::raw::c_int) -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_flockfile(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_ftrylockfile(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_funlockfile(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_feof(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_feof_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ferror(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ferror_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_clearerr(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_clearerr_unlocked(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn _gpgrt_pending(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_pending_unlocked(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fflush(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fseek(
        stream: gpgrt_stream_t,
        offset: ::std::os::raw::c_long,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fseeko(
        stream: gpgrt_stream_t,
        offset: gpgrt_off_t,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ftruncate(stream: gpgrt_stream_t, length: gpgrt_off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ftell(stream: gpgrt_stream_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn gpgrt_ftello(stream: gpgrt_stream_t) -> gpgrt_off_t;
}
extern "C" {
    pub fn gpgrt_rewind(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_fgetc(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fputc(c: ::std::os::raw::c_int, stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_getc_underflow(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gpgrt_putc_overflow(
        c: ::std::os::raw::c_int,
        stream: gpgrt_stream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_ungetc(c: ::std::os::raw::c_int, stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_read(
        stream: gpgrt_stream_t,
        buffer: *mut ::std::os::raw::c_void,
        bytes_to_read: usize,
        bytes_read: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_write(
        stream: gpgrt_stream_t,
        buffer: *const ::std::os::raw::c_void,
        bytes_to_write: usize,
        bytes_written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_write_sanitized(
        stream: gpgrt_stream_t,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        delimiters: *const ::std::os::raw::c_char,
        bytes_written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_write_hexstring(
        stream: gpgrt_stream_t,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        reserved: ::std::os::raw::c_int,
        bytes_written: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fread(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        nitems: usize,
        stream: gpgrt_stream_t,
    ) -> usize;
}
extern "C" {
    pub fn gpgrt_fwrite(
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        nitems: usize,
        stream: gpgrt_stream_t,
    ) -> usize;
}
extern "C" {
    pub fn gpgrt_fgets(
        s: *mut ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        stream: gpgrt_stream_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_fputs(
        s: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fputs_unlocked(
        s: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_getline(
        lineptr: *mut *mut ::std::os::raw::c_char,
        n: *mut usize,
        stream: gpgrt_stream_t,
    ) -> isize;
}
extern "C" {
    pub fn gpgrt_read_line(
        stream: gpgrt_stream_t,
        addr_of_buffer: *mut *mut ::std::os::raw::c_char,
        length_of_buffer: *mut usize,
        max_length: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn gpgrt_fprintf(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fprintf_unlocked(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fprintf_sf(
        stream: gpgrt_stream_t,
        sf: gpgrt_string_filter_t,
        sfvalue: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fprintf_sf_unlocked(
        stream: gpgrt_stream_t,
        sf: gpgrt_string_filter_t,
        sfvalue: *mut ::std::os::raw::c_void,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_printf_unlocked(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vfprintf(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vfprintf_unlocked(
        stream: gpgrt_stream_t,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_setvbuf(
        stream: gpgrt_stream_t,
        buf: *mut ::std::os::raw::c_char,
        mode: ::std::os::raw::c_int,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_setbuf(stream: gpgrt_stream_t, buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_set_binary(stream: gpgrt_stream_t);
}
extern "C" {
    pub fn gpgrt_set_nonblock(
        stream: gpgrt_stream_t,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_get_nonblock(stream: gpgrt_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_poll(
        fdlist: *mut gpgrt_poll_t,
        nfds: ::std::os::raw::c_uint,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_tmpfile() -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_opaque_set(stream: gpgrt_stream_t, opaque: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gpgrt_opaque_get(stream: gpgrt_stream_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gpgrt_fname_set(stream: gpgrt_stream_t, fname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_fname_get(stream: gpgrt_stream_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_asprintf(
        r_buf: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vasprintf(
        r_buf: *mut *mut ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_bsprintf(
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_vbsprintf(
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_snprintf(
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_vsnprintf(
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
        format: *const ::std::os::raw::c_char,
        arg_ptr: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_b64state {
    _unused: [u8; 0],
}
pub type gpgrt_b64state_t = *mut _gpgrt_b64state;
extern "C" {
    pub fn gpgrt_b64enc_start(
        stream: gpgrt_stream_t,
        title: *const ::std::os::raw::c_char,
    ) -> gpgrt_b64state_t;
}
extern "C" {
    pub fn gpgrt_b64enc_write(
        state: gpgrt_b64state_t,
        buffer: *const ::std::os::raw::c_void,
        nbytes: usize,
    ) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_b64enc_finish(state: gpgrt_b64state_t) -> gpg_err_code_t;
}
extern "C" {
    pub fn gpgrt_b64dec_start(title: *const ::std::os::raw::c_char) -> gpgrt_b64state_t;
}
extern "C" {
    pub fn gpgrt_b64dec_proc(
        state: gpgrt_b64state_t,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        r_nbytes: *mut usize,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gpgrt_b64dec_finish(state: gpgrt_b64state_t) -> gpg_error_t;
}
pub const gpgrt_log_levels_GPGRT_LOGLVL_BEGIN: gpgrt_log_levels = 0;
pub const gpgrt_log_levels_GPGRT_LOGLVL_CONT: gpgrt_log_levels = 1;
pub const gpgrt_log_levels_GPGRT_LOGLVL_INFO: gpgrt_log_levels = 2;
pub const gpgrt_log_levels_GPGRT_LOGLVL_WARN: gpgrt_log_levels = 3;
pub const gpgrt_log_levels_GPGRT_LOGLVL_ERROR: gpgrt_log_levels = 4;
pub const gpgrt_log_levels_GPGRT_LOGLVL_FATAL: gpgrt_log_levels = 5;
pub const gpgrt_log_levels_GPGRT_LOGLVL_BUG: gpgrt_log_levels = 6;
pub const gpgrt_log_levels_GPGRT_LOGLVL_DEBUG: gpgrt_log_levels = 7;
pub type gpgrt_log_levels = ::std::os::raw::c_uint;
extern "C" {
    pub fn gpgrt_log_set_sink(
        name: *const ::std::os::raw::c_char,
        stream: gpgrt_stream_t,
        fd: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gpgrt_log_set_socket_dir_cb(
        fnc: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>,
    );
}
extern "C" {
    pub fn gpgrt_log_set_pid_suffix_cb(
        cb: ::std::option::Option<
            unsafe extern "C" fn(r_value: *mut ::std::os::raw::c_ulong) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn gpgrt_log_set_prefix(text: *const ::std::os::raw::c_char, flags: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gpgrt_get_errorcount(clear: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_inc_errorcount();
}
extern "C" {
    pub fn gpgrt_log_get_prefix(
        flags: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_log_test_fd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_log_get_fd() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_log_get_stream() -> gpgrt_stream_t;
}
extern "C" {
    pub fn gpgrt_log(level: ::std::os::raw::c_int, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_logv(
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        arg_ptr: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn gpgrt_logv_prefix(
        level: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        arg_ptr: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn gpgrt_log_string(level: ::std::os::raw::c_int, string: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_log_bug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_fatal(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_error(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_info(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_debug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_debug_string(
        string: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn gpgrt_log_printf(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_printhex(
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn gpgrt_log_clock(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gpgrt_log_flush();
}
extern "C" {
    pub fn _gpgrt_log_assert(
        expr: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _gpgrt_argparse_internal_s {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpgrt_argparse_t {
    pub argc: *mut ::std::os::raw::c_int,
    pub argv: *mut *mut *mut ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub err: ::std::os::raw::c_int,
    pub lineno: ::std::os::raw::c_uint,
    pub r_opt: ::std::os::raw::c_int,
    pub r_type: ::std::os::raw::c_int,
    pub r: gpgrt_argparse_t__bindgen_ty_1,
    pub internal: *mut _gpgrt_argparse_internal_s,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpgrt_argparse_t__bindgen_ty_1 {
    pub ret_int: ::std::os::raw::c_int,
    pub ret_long: ::std::os::raw::c_long,
    pub ret_ulong: ::std::os::raw::c_ulong,
    pub ret_str: *mut ::std::os::raw::c_char,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_gpgrt_argparse_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_argparse_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(gpgrt_argparse_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_argparse_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_argparse_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_int as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_int)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_long as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_long)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_ulong as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_ulong)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<gpgrt_argparse_t__bindgen_ty_1>())).ret_str as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t__bindgen_ty_1),
            "::",
            stringify!(ret_str)
        )
    );
}
#[test]
fn bindgen_test_layout_gpgrt_argparse_t() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_argparse_t>(),
        56usize,
        concat!("Size of: ", stringify!(gpgrt_argparse_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_argparse_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_argparse_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).argv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).err as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).lineno as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(lineno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).r_opt as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(r_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).r_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(r_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).r as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_argparse_t>())).internal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_argparse_t),
            "::",
            stringify!(internal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gpgrt_opt_t {
    pub short_opt: ::std::os::raw::c_int,
    pub long_opt: *const ::std::os::raw::c_char,
    pub flags: ::std::os::raw::c_uint,
    pub description: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_gpgrt_opt_t() {
    assert_eq!(
        ::std::mem::size_of::<gpgrt_opt_t>(),
        32usize,
        concat!("Size of: ", stringify!(gpgrt_opt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gpgrt_opt_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gpgrt_opt_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).short_opt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(short_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).long_opt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(long_opt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gpgrt_opt_t>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gpgrt_opt_t),
            "::",
            stringify!(description)
        )
    );
}
extern "C" {
    pub fn gpgrt_argparse(
        fp: gpgrt_stream_t,
        arg: *mut gpgrt_argparse_t,
        opts: *mut gpgrt_opt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_argparser(
        arg: *mut gpgrt_argparse_t,
        opts: *mut gpgrt_opt_t,
        confname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_usage(level: ::std::os::raw::c_int);
}
extern "C" {
    pub fn gpgrt_strusage(level: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_set_strusage(
        f: ::std::option::Option<
            unsafe extern "C" fn(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char,
        >,
    );
}
extern "C" {
    pub fn gpgrt_set_usage_outfnc(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: ::std::os::raw::c_int,
                arg2: *const ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn gpgrt_set_fixed_string_mapper(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char,
        >,
    );
}
extern "C" {
    pub fn gpgrt_set_confdir(what: ::std::os::raw::c_int, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn gpgrt_cmp_version(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
        level: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpgrt_fnameconcat(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gpgrt_absfnameconcat(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
extern "C" {
    pub fn gettimeofday(
        __tv: *mut timeval,
        __tz: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub use self::__itimer_which as __itimer_which_t;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimesat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
pub type gcry_socklen_t = socklen_t;
pub type gcry_error_t = gpg_error_t;
pub use self::gpg_err_code_t as gcry_err_code_t;
pub use self::gpg_err_source_t as gcry_err_source_t;
extern "C" {
    pub fn gcry_strerror(err: gcry_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_strsource(err: gcry_error_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_err_code_from_errno(err: ::std::os::raw::c_int) -> gcry_err_code_t;
}
extern "C" {
    pub fn gcry_err_code_to_errno(code: gcry_err_code_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_err_make_from_errno(
        source: gcry_err_source_t,
        err: ::std::os::raw::c_int,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_error_from_errno(err: ::std::os::raw::c_int) -> gcry_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_thread_cbs {
    pub option: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_gcry_thread_cbs() {
    assert_eq!(
        ::std::mem::size_of::<gcry_thread_cbs>(),
        4usize,
        concat!("Size of: ", stringify!(gcry_thread_cbs))
    );
    assert_eq!(
        ::std::mem::align_of::<gcry_thread_cbs>(),
        4usize,
        concat!("Alignment of ", stringify!(gcry_thread_cbs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_thread_cbs>())).option as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_thread_cbs),
            "::",
            stringify!(option)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_context {
    _unused: [u8; 0],
}
pub type gcry_ctx_t = *mut gcry_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_mpi {
    _unused: [u8; 0],
}
pub type gcry_mpi_t = *mut gcry_mpi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_mpi_point {
    _unused: [u8; 0],
}
pub type gcry_mpi_point_t = *mut gcry_mpi_point;
pub type GCRY_MPI = *mut gcry_mpi;
pub type GcryMPI = *mut gcry_mpi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_buffer_t {
    pub size: usize,
    pub off: usize,
    pub len: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gcry_buffer_t() {
    assert_eq!(
        ::std::mem::size_of::<gcry_buffer_t>(),
        32usize,
        concat!("Size of: ", stringify!(gcry_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gcry_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gcry_buffer_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_buffer_t>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_buffer_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_buffer_t>())).off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_buffer_t),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_buffer_t>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_buffer_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_buffer_t>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_buffer_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn gcry_check_version(
        req_version: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub const gcry_ctl_cmds_GCRYCTL_CFB_SYNC: gcry_ctl_cmds = 3;
pub const gcry_ctl_cmds_GCRYCTL_RESET: gcry_ctl_cmds = 4;
pub const gcry_ctl_cmds_GCRYCTL_FINALIZE: gcry_ctl_cmds = 5;
pub const gcry_ctl_cmds_GCRYCTL_GET_KEYLEN: gcry_ctl_cmds = 6;
pub const gcry_ctl_cmds_GCRYCTL_GET_BLKLEN: gcry_ctl_cmds = 7;
pub const gcry_ctl_cmds_GCRYCTL_TEST_ALGO: gcry_ctl_cmds = 8;
pub const gcry_ctl_cmds_GCRYCTL_IS_SECURE: gcry_ctl_cmds = 9;
pub const gcry_ctl_cmds_GCRYCTL_GET_ASNOID: gcry_ctl_cmds = 10;
pub const gcry_ctl_cmds_GCRYCTL_ENABLE_ALGO: gcry_ctl_cmds = 11;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_ALGO: gcry_ctl_cmds = 12;
pub const gcry_ctl_cmds_GCRYCTL_DUMP_RANDOM_STATS: gcry_ctl_cmds = 13;
pub const gcry_ctl_cmds_GCRYCTL_DUMP_SECMEM_STATS: gcry_ctl_cmds = 14;
pub const gcry_ctl_cmds_GCRYCTL_GET_ALGO_NPKEY: gcry_ctl_cmds = 15;
pub const gcry_ctl_cmds_GCRYCTL_GET_ALGO_NSKEY: gcry_ctl_cmds = 16;
pub const gcry_ctl_cmds_GCRYCTL_GET_ALGO_NSIGN: gcry_ctl_cmds = 17;
pub const gcry_ctl_cmds_GCRYCTL_GET_ALGO_NENCR: gcry_ctl_cmds = 18;
pub const gcry_ctl_cmds_GCRYCTL_SET_VERBOSITY: gcry_ctl_cmds = 19;
pub const gcry_ctl_cmds_GCRYCTL_SET_DEBUG_FLAGS: gcry_ctl_cmds = 20;
pub const gcry_ctl_cmds_GCRYCTL_CLEAR_DEBUG_FLAGS: gcry_ctl_cmds = 21;
pub const gcry_ctl_cmds_GCRYCTL_USE_SECURE_RNDPOOL: gcry_ctl_cmds = 22;
pub const gcry_ctl_cmds_GCRYCTL_DUMP_MEMORY_STATS: gcry_ctl_cmds = 23;
pub const gcry_ctl_cmds_GCRYCTL_INIT_SECMEM: gcry_ctl_cmds = 24;
pub const gcry_ctl_cmds_GCRYCTL_TERM_SECMEM: gcry_ctl_cmds = 25;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_SECMEM_WARN: gcry_ctl_cmds = 27;
pub const gcry_ctl_cmds_GCRYCTL_SUSPEND_SECMEM_WARN: gcry_ctl_cmds = 28;
pub const gcry_ctl_cmds_GCRYCTL_RESUME_SECMEM_WARN: gcry_ctl_cmds = 29;
pub const gcry_ctl_cmds_GCRYCTL_DROP_PRIVS: gcry_ctl_cmds = 30;
pub const gcry_ctl_cmds_GCRYCTL_ENABLE_M_GUARD: gcry_ctl_cmds = 31;
pub const gcry_ctl_cmds_GCRYCTL_START_DUMP: gcry_ctl_cmds = 32;
pub const gcry_ctl_cmds_GCRYCTL_STOP_DUMP: gcry_ctl_cmds = 33;
pub const gcry_ctl_cmds_GCRYCTL_GET_ALGO_USAGE: gcry_ctl_cmds = 34;
pub const gcry_ctl_cmds_GCRYCTL_IS_ALGO_ENABLED: gcry_ctl_cmds = 35;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_INTERNAL_LOCKING: gcry_ctl_cmds = 36;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_SECMEM: gcry_ctl_cmds = 37;
pub const gcry_ctl_cmds_GCRYCTL_INITIALIZATION_FINISHED: gcry_ctl_cmds = 38;
pub const gcry_ctl_cmds_GCRYCTL_INITIALIZATION_FINISHED_P: gcry_ctl_cmds = 39;
pub const gcry_ctl_cmds_GCRYCTL_ANY_INITIALIZATION_P: gcry_ctl_cmds = 40;
pub const gcry_ctl_cmds_GCRYCTL_SET_CBC_CTS: gcry_ctl_cmds = 41;
pub const gcry_ctl_cmds_GCRYCTL_SET_CBC_MAC: gcry_ctl_cmds = 42;
pub const gcry_ctl_cmds_GCRYCTL_ENABLE_QUICK_RANDOM: gcry_ctl_cmds = 44;
pub const gcry_ctl_cmds_GCRYCTL_SET_RANDOM_SEED_FILE: gcry_ctl_cmds = 45;
pub const gcry_ctl_cmds_GCRYCTL_UPDATE_RANDOM_SEED_FILE: gcry_ctl_cmds = 46;
pub const gcry_ctl_cmds_GCRYCTL_SET_THREAD_CBS: gcry_ctl_cmds = 47;
pub const gcry_ctl_cmds_GCRYCTL_FAST_POLL: gcry_ctl_cmds = 48;
pub const gcry_ctl_cmds_GCRYCTL_SET_RANDOM_DAEMON_SOCKET: gcry_ctl_cmds = 49;
pub const gcry_ctl_cmds_GCRYCTL_USE_RANDOM_DAEMON: gcry_ctl_cmds = 50;
pub const gcry_ctl_cmds_GCRYCTL_FAKED_RANDOM_P: gcry_ctl_cmds = 51;
pub const gcry_ctl_cmds_GCRYCTL_SET_RNDEGD_SOCKET: gcry_ctl_cmds = 52;
pub const gcry_ctl_cmds_GCRYCTL_PRINT_CONFIG: gcry_ctl_cmds = 53;
pub const gcry_ctl_cmds_GCRYCTL_OPERATIONAL_P: gcry_ctl_cmds = 54;
pub const gcry_ctl_cmds_GCRYCTL_FIPS_MODE_P: gcry_ctl_cmds = 55;
pub const gcry_ctl_cmds_GCRYCTL_FORCE_FIPS_MODE: gcry_ctl_cmds = 56;
pub const gcry_ctl_cmds_GCRYCTL_SELFTEST: gcry_ctl_cmds = 57;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_HWF: gcry_ctl_cmds = 63;
pub const gcry_ctl_cmds_GCRYCTL_SET_ENFORCED_FIPS_FLAG: gcry_ctl_cmds = 64;
pub const gcry_ctl_cmds_GCRYCTL_SET_PREFERRED_RNG_TYPE: gcry_ctl_cmds = 65;
pub const gcry_ctl_cmds_GCRYCTL_GET_CURRENT_RNG_TYPE: gcry_ctl_cmds = 66;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_LOCKED_SECMEM: gcry_ctl_cmds = 67;
pub const gcry_ctl_cmds_GCRYCTL_DISABLE_PRIV_DROP: gcry_ctl_cmds = 68;
pub const gcry_ctl_cmds_GCRYCTL_SET_CCM_LENGTHS: gcry_ctl_cmds = 69;
pub const gcry_ctl_cmds_GCRYCTL_CLOSE_RANDOM_DEVICE: gcry_ctl_cmds = 70;
pub const gcry_ctl_cmds_GCRYCTL_INACTIVATE_FIPS_FLAG: gcry_ctl_cmds = 71;
pub const gcry_ctl_cmds_GCRYCTL_REACTIVATE_FIPS_FLAG: gcry_ctl_cmds = 72;
pub const gcry_ctl_cmds_GCRYCTL_SET_SBOX: gcry_ctl_cmds = 73;
pub const gcry_ctl_cmds_GCRYCTL_DRBG_REINIT: gcry_ctl_cmds = 74;
pub const gcry_ctl_cmds_GCRYCTL_SET_TAGLEN: gcry_ctl_cmds = 75;
pub const gcry_ctl_cmds_GCRYCTL_GET_TAGLEN: gcry_ctl_cmds = 76;
pub const gcry_ctl_cmds_GCRYCTL_REINIT_SYSCALL_CLAMP: gcry_ctl_cmds = 77;
pub type gcry_ctl_cmds = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_control(CMD: gcry_ctl_cmds, ...) -> gcry_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_sexp {
    _unused: [u8; 0],
}
pub type gcry_sexp_t = *mut gcry_sexp;
pub type GCRY_SEXP = *mut gcry_sexp;
pub type GcrySexp = *mut gcry_sexp;
pub const gcry_sexp_format_GCRYSEXP_FMT_DEFAULT: gcry_sexp_format = 0;
pub const gcry_sexp_format_GCRYSEXP_FMT_CANON: gcry_sexp_format = 1;
pub const gcry_sexp_format_GCRYSEXP_FMT_BASE64: gcry_sexp_format = 2;
pub const gcry_sexp_format_GCRYSEXP_FMT_ADVANCED: gcry_sexp_format = 3;
pub type gcry_sexp_format = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_sexp_new(
        retsexp: *mut gcry_sexp_t,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        autodetect: ::std::os::raw::c_int,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_sexp_create(
        retsexp: *mut gcry_sexp_t,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        autodetect: ::std::os::raw::c_int,
        freefnc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_sexp_sscan(
        retsexp: *mut gcry_sexp_t,
        erroff: *mut usize,
        buffer: *const ::std::os::raw::c_char,
        length: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_sexp_build(
        retsexp: *mut gcry_sexp_t,
        erroff: *mut usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_sexp_build_array(
        retsexp: *mut gcry_sexp_t,
        erroff: *mut usize,
        format: *const ::std::os::raw::c_char,
        arg_list: *mut *mut ::std::os::raw::c_void,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_sexp_release(sexp: gcry_sexp_t);
}
extern "C" {
    pub fn gcry_sexp_canon_len(
        buffer: *const ::std::os::raw::c_uchar,
        length: usize,
        erroff: *mut usize,
        errcode: *mut gcry_error_t,
    ) -> usize;
}
extern "C" {
    pub fn gcry_sexp_sprint(
        sexp: gcry_sexp_t,
        mode: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        maxlength: usize,
    ) -> usize;
}
extern "C" {
    pub fn gcry_sexp_dump(a: gcry_sexp_t);
}
extern "C" {
    pub fn gcry_sexp_cons(a: gcry_sexp_t, b: gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_alist(array: *const gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_vlist(a: gcry_sexp_t, ...) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_append(a: gcry_sexp_t, n: gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_prepend(a: gcry_sexp_t, n: gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_find_token(
        list: gcry_sexp_t,
        tok: *const ::std::os::raw::c_char,
        toklen: usize,
    ) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_length(list: gcry_sexp_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_sexp_nth(list: gcry_sexp_t, number: ::std::os::raw::c_int) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_car(list: gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_cdr(list: gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_cadr(list: gcry_sexp_t) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_sexp_nth_data(
        list: gcry_sexp_t,
        number: ::std::os::raw::c_int,
        datalen: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_sexp_nth_buffer(
        list: gcry_sexp_t,
        number: ::std::os::raw::c_int,
        rlength: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_sexp_nth_string(
        list: gcry_sexp_t,
        number: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_sexp_nth_mpi(
        list: gcry_sexp_t,
        number: ::std::os::raw::c_int,
        mpifmt: ::std::os::raw::c_int,
    ) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_sexp_extract_param(
        sexp: gcry_sexp_t,
        path: *const ::std::os::raw::c_char,
        list: *const ::std::os::raw::c_char,
        ...
    ) -> gpg_error_t;
}
pub const gcry_mpi_format_GCRYMPI_FMT_NONE: gcry_mpi_format = 0;
pub const gcry_mpi_format_GCRYMPI_FMT_STD: gcry_mpi_format = 1;
pub const gcry_mpi_format_GCRYMPI_FMT_PGP: gcry_mpi_format = 2;
pub const gcry_mpi_format_GCRYMPI_FMT_SSH: gcry_mpi_format = 3;
pub const gcry_mpi_format_GCRYMPI_FMT_HEX: gcry_mpi_format = 4;
pub const gcry_mpi_format_GCRYMPI_FMT_USG: gcry_mpi_format = 5;
pub const gcry_mpi_format_GCRYMPI_FMT_OPAQUE: gcry_mpi_format = 8;
pub type gcry_mpi_format = ::std::os::raw::c_uint;
pub const gcry_mpi_flag_GCRYMPI_FLAG_SECURE: gcry_mpi_flag = 1;
pub const gcry_mpi_flag_GCRYMPI_FLAG_OPAQUE: gcry_mpi_flag = 2;
pub const gcry_mpi_flag_GCRYMPI_FLAG_IMMUTABLE: gcry_mpi_flag = 4;
pub const gcry_mpi_flag_GCRYMPI_FLAG_CONST: gcry_mpi_flag = 8;
pub const gcry_mpi_flag_GCRYMPI_FLAG_USER1: gcry_mpi_flag = 256;
pub const gcry_mpi_flag_GCRYMPI_FLAG_USER2: gcry_mpi_flag = 512;
pub const gcry_mpi_flag_GCRYMPI_FLAG_USER3: gcry_mpi_flag = 1024;
pub const gcry_mpi_flag_GCRYMPI_FLAG_USER4: gcry_mpi_flag = 2048;
pub type gcry_mpi_flag = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_mpi_new(nbits: ::std::os::raw::c_uint) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_snew(nbits: ::std::os::raw::c_uint) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_release(a: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_copy(a: gcry_mpi_t) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_snatch(w: gcry_mpi_t, u: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_set(w: gcry_mpi_t, u: gcry_mpi_t) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_set_ui(w: gcry_mpi_t, u: ::std::os::raw::c_ulong) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_swap(a: gcry_mpi_t, b: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_is_neg(a: gcry_mpi_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_neg(w: gcry_mpi_t, u: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_abs(w: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_cmp(u: gcry_mpi_t, v: gcry_mpi_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_cmp_ui(u: gcry_mpi_t, v: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_scan(
        ret_mpi: *mut gcry_mpi_t,
        format: gcry_mpi_format,
        buffer: *const ::std::os::raw::c_void,
        buflen: usize,
        nscanned: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mpi_print(
        format: gcry_mpi_format,
        buffer: *mut ::std::os::raw::c_uchar,
        buflen: usize,
        nwritten: *mut usize,
        a: gcry_mpi_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mpi_aprint(
        format: gcry_mpi_format,
        buffer: *mut *mut ::std::os::raw::c_uchar,
        nwritten: *mut usize,
        a: gcry_mpi_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mpi_dump(a: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_add(w: gcry_mpi_t, u: gcry_mpi_t, v: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_add_ui(w: gcry_mpi_t, u: gcry_mpi_t, v: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn gcry_mpi_addm(w: gcry_mpi_t, u: gcry_mpi_t, v: gcry_mpi_t, m: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_sub(w: gcry_mpi_t, u: gcry_mpi_t, v: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_sub_ui(w: gcry_mpi_t, u: gcry_mpi_t, v: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn gcry_mpi_subm(w: gcry_mpi_t, u: gcry_mpi_t, v: gcry_mpi_t, m: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_mul(w: gcry_mpi_t, u: gcry_mpi_t, v: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_mul_ui(w: gcry_mpi_t, u: gcry_mpi_t, v: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn gcry_mpi_mulm(w: gcry_mpi_t, u: gcry_mpi_t, v: gcry_mpi_t, m: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_mul_2exp(w: gcry_mpi_t, u: gcry_mpi_t, cnt: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn gcry_mpi_div(
        q: gcry_mpi_t,
        r: gcry_mpi_t,
        dividend: gcry_mpi_t,
        divisor: gcry_mpi_t,
        round: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn gcry_mpi_mod(r: gcry_mpi_t, dividend: gcry_mpi_t, divisor: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_powm(w: gcry_mpi_t, b: gcry_mpi_t, e: gcry_mpi_t, m: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_mpi_gcd(g: gcry_mpi_t, a: gcry_mpi_t, b: gcry_mpi_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_invm(x: gcry_mpi_t, a: gcry_mpi_t, m: gcry_mpi_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_point_new(nbits: ::std::os::raw::c_uint) -> gcry_mpi_point_t;
}
extern "C" {
    pub fn gcry_mpi_point_release(point: gcry_mpi_point_t);
}
extern "C" {
    pub fn gcry_mpi_point_copy(point: gcry_mpi_point_t) -> gcry_mpi_point_t;
}
extern "C" {
    pub fn gcry_mpi_point_get(x: gcry_mpi_t, y: gcry_mpi_t, z: gcry_mpi_t, point: gcry_mpi_point_t);
}
extern "C" {
    pub fn gcry_mpi_point_snatch_get(
        x: gcry_mpi_t,
        y: gcry_mpi_t,
        z: gcry_mpi_t,
        point: gcry_mpi_point_t,
    );
}
extern "C" {
    pub fn gcry_mpi_point_set(
        point: gcry_mpi_point_t,
        x: gcry_mpi_t,
        y: gcry_mpi_t,
        z: gcry_mpi_t,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    pub fn gcry_mpi_point_snatch_set(
        point: gcry_mpi_point_t,
        x: gcry_mpi_t,
        y: gcry_mpi_t,
        z: gcry_mpi_t,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    pub fn gcry_mpi_ec_new(
        r_ctx: *mut gcry_ctx_t,
        keyparam: gcry_sexp_t,
        curvename: *const ::std::os::raw::c_char,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_mpi_ec_get_mpi(
        name: *const ::std::os::raw::c_char,
        ctx: gcry_ctx_t,
        copy: ::std::os::raw::c_int,
    ) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_ec_get_point(
        name: *const ::std::os::raw::c_char,
        ctx: gcry_ctx_t,
        copy: ::std::os::raw::c_int,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    pub fn gcry_mpi_ec_set_mpi(
        name: *const ::std::os::raw::c_char,
        newvalue: gcry_mpi_t,
        ctx: gcry_ctx_t,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_mpi_ec_set_point(
        name: *const ::std::os::raw::c_char,
        newvalue: gcry_mpi_point_t,
        ctx: gcry_ctx_t,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_mpi_ec_decode_point(
        result: gcry_mpi_point_t,
        value: gcry_mpi_t,
        ctx: gcry_ctx_t,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_mpi_ec_get_affine(
        x: gcry_mpi_t,
        y: gcry_mpi_t,
        point: gcry_mpi_point_t,
        ctx: gcry_ctx_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_ec_dup(w: gcry_mpi_point_t, u: gcry_mpi_point_t, ctx: gcry_ctx_t);
}
extern "C" {
    pub fn gcry_mpi_ec_add(
        w: gcry_mpi_point_t,
        u: gcry_mpi_point_t,
        v: gcry_mpi_point_t,
        ctx: gcry_ctx_t,
    );
}
extern "C" {
    pub fn gcry_mpi_ec_sub(
        w: gcry_mpi_point_t,
        u: gcry_mpi_point_t,
        v: gcry_mpi_point_t,
        ctx: gcry_ctx_t,
    );
}
extern "C" {
    pub fn gcry_mpi_ec_mul(
        w: gcry_mpi_point_t,
        n: gcry_mpi_t,
        u: gcry_mpi_point_t,
        ctx: gcry_ctx_t,
    );
}
extern "C" {
    pub fn gcry_mpi_ec_curve_point(w: gcry_mpi_point_t, ctx: gcry_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_get_nbits(a: gcry_mpi_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gcry_mpi_test_bit(a: gcry_mpi_t, n: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mpi_set_bit(a: gcry_mpi_t, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gcry_mpi_clear_bit(a: gcry_mpi_t, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gcry_mpi_set_highbit(a: gcry_mpi_t, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gcry_mpi_clear_highbit(a: gcry_mpi_t, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gcry_mpi_rshift(x: gcry_mpi_t, a: gcry_mpi_t, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gcry_mpi_lshift(x: gcry_mpi_t, a: gcry_mpi_t, n: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn gcry_mpi_set_opaque(
        a: gcry_mpi_t,
        p: *mut ::std::os::raw::c_void,
        nbits: ::std::os::raw::c_uint,
    ) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_set_opaque_copy(
        a: gcry_mpi_t,
        p: *const ::std::os::raw::c_void,
        nbits: ::std::os::raw::c_uint,
    ) -> gcry_mpi_t;
}
extern "C" {
    pub fn gcry_mpi_get_opaque(
        a: gcry_mpi_t,
        nbits: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_mpi_set_flag(a: gcry_mpi_t, flag: gcry_mpi_flag);
}
extern "C" {
    pub fn gcry_mpi_clear_flag(a: gcry_mpi_t, flag: gcry_mpi_flag);
}
extern "C" {
    pub fn gcry_mpi_get_flag(a: gcry_mpi_t, flag: gcry_mpi_flag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _gcry_mpi_get_const(no: ::std::os::raw::c_int) -> gcry_mpi_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_cipher_handle {
    _unused: [u8; 0],
}
pub type gcry_cipher_hd_t = *mut gcry_cipher_handle;
pub type GCRY_CIPHER_HD = *mut gcry_cipher_handle;
pub type GcryCipherHd = *mut gcry_cipher_handle;
pub const gcry_cipher_algos_GCRY_CIPHER_NONE: gcry_cipher_algos = 0;
pub const gcry_cipher_algos_GCRY_CIPHER_IDEA: gcry_cipher_algos = 1;
pub const gcry_cipher_algos_GCRY_CIPHER_3DES: gcry_cipher_algos = 2;
pub const gcry_cipher_algos_GCRY_CIPHER_CAST5: gcry_cipher_algos = 3;
pub const gcry_cipher_algos_GCRY_CIPHER_BLOWFISH: gcry_cipher_algos = 4;
pub const gcry_cipher_algos_GCRY_CIPHER_SAFER_SK128: gcry_cipher_algos = 5;
pub const gcry_cipher_algos_GCRY_CIPHER_DES_SK: gcry_cipher_algos = 6;
pub const gcry_cipher_algos_GCRY_CIPHER_AES: gcry_cipher_algos = 7;
pub const gcry_cipher_algos_GCRY_CIPHER_AES192: gcry_cipher_algos = 8;
pub const gcry_cipher_algos_GCRY_CIPHER_AES256: gcry_cipher_algos = 9;
pub const gcry_cipher_algos_GCRY_CIPHER_TWOFISH: gcry_cipher_algos = 10;
pub const gcry_cipher_algos_GCRY_CIPHER_ARCFOUR: gcry_cipher_algos = 301;
pub const gcry_cipher_algos_GCRY_CIPHER_DES: gcry_cipher_algos = 302;
pub const gcry_cipher_algos_GCRY_CIPHER_TWOFISH128: gcry_cipher_algos = 303;
pub const gcry_cipher_algos_GCRY_CIPHER_SERPENT128: gcry_cipher_algos = 304;
pub const gcry_cipher_algos_GCRY_CIPHER_SERPENT192: gcry_cipher_algos = 305;
pub const gcry_cipher_algos_GCRY_CIPHER_SERPENT256: gcry_cipher_algos = 306;
pub const gcry_cipher_algos_GCRY_CIPHER_RFC2268_40: gcry_cipher_algos = 307;
pub const gcry_cipher_algos_GCRY_CIPHER_RFC2268_128: gcry_cipher_algos = 308;
pub const gcry_cipher_algos_GCRY_CIPHER_SEED: gcry_cipher_algos = 309;
pub const gcry_cipher_algos_GCRY_CIPHER_CAMELLIA128: gcry_cipher_algos = 310;
pub const gcry_cipher_algos_GCRY_CIPHER_CAMELLIA192: gcry_cipher_algos = 311;
pub const gcry_cipher_algos_GCRY_CIPHER_CAMELLIA256: gcry_cipher_algos = 312;
pub const gcry_cipher_algos_GCRY_CIPHER_SALSA20: gcry_cipher_algos = 313;
pub const gcry_cipher_algos_GCRY_CIPHER_SALSA20R12: gcry_cipher_algos = 314;
pub const gcry_cipher_algos_GCRY_CIPHER_GOST28147: gcry_cipher_algos = 315;
pub const gcry_cipher_algos_GCRY_CIPHER_CHACHA20: gcry_cipher_algos = 316;
pub type gcry_cipher_algos = ::std::os::raw::c_uint;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_NONE: gcry_cipher_modes = 0;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_ECB: gcry_cipher_modes = 1;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_CFB: gcry_cipher_modes = 2;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_CBC: gcry_cipher_modes = 3;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_STREAM: gcry_cipher_modes = 4;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_OFB: gcry_cipher_modes = 5;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_CTR: gcry_cipher_modes = 6;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_AESWRAP: gcry_cipher_modes = 7;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_CCM: gcry_cipher_modes = 8;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_GCM: gcry_cipher_modes = 9;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_POLY1305: gcry_cipher_modes = 10;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_OCB: gcry_cipher_modes = 11;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_CFB8: gcry_cipher_modes = 12;
pub const gcry_cipher_modes_GCRY_CIPHER_MODE_XTS: gcry_cipher_modes = 13;
pub type gcry_cipher_modes = ::std::os::raw::c_uint;
pub const gcry_cipher_flags_GCRY_CIPHER_SECURE: gcry_cipher_flags = 1;
pub const gcry_cipher_flags_GCRY_CIPHER_ENABLE_SYNC: gcry_cipher_flags = 2;
pub const gcry_cipher_flags_GCRY_CIPHER_CBC_CTS: gcry_cipher_flags = 4;
pub const gcry_cipher_flags_GCRY_CIPHER_CBC_MAC: gcry_cipher_flags = 8;
pub type gcry_cipher_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_cipher_open(
        handle: *mut gcry_cipher_hd_t,
        algo: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_close(h: gcry_cipher_hd_t);
}
extern "C" {
    pub fn gcry_cipher_ctl(
        h: gcry_cipher_hd_t,
        cmd: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_info(
        h: gcry_cipher_hd_t,
        what: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        nbytes: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_algo_info(
        algo: ::std::os::raw::c_int,
        what: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        nbytes: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_algo_name(algorithm: ::std::os::raw::c_int)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_cipher_map_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_cipher_mode_from_oid(
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_cipher_encrypt(
        h: gcry_cipher_hd_t,
        out: *mut ::std::os::raw::c_void,
        outsize: usize,
        in_: *const ::std::os::raw::c_void,
        inlen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_decrypt(
        h: gcry_cipher_hd_t,
        out: *mut ::std::os::raw::c_void,
        outsize: usize,
        in_: *const ::std::os::raw::c_void,
        inlen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_setkey(
        hd: gcry_cipher_hd_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_setiv(
        hd: gcry_cipher_hd_t,
        iv: *const ::std::os::raw::c_void,
        ivlen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_authenticate(
        hd: gcry_cipher_hd_t,
        abuf: *const ::std::os::raw::c_void,
        abuflen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_gettag(
        hd: gcry_cipher_hd_t,
        outtag: *mut ::std::os::raw::c_void,
        taglen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_checktag(
        hd: gcry_cipher_hd_t,
        intag: *const ::std::os::raw::c_void,
        taglen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_cipher_setctr(
        hd: gcry_cipher_hd_t,
        ctr: *const ::std::os::raw::c_void,
        ctrlen: usize,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_cipher_get_algo_keylen(algo: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn gcry_cipher_get_algo_blklen(algo: ::std::os::raw::c_int) -> usize;
}
pub const gcry_pk_algos_GCRY_PK_RSA: gcry_pk_algos = 1;
pub const gcry_pk_algos_GCRY_PK_RSA_E: gcry_pk_algos = 2;
pub const gcry_pk_algos_GCRY_PK_RSA_S: gcry_pk_algos = 3;
pub const gcry_pk_algos_GCRY_PK_ELG_E: gcry_pk_algos = 16;
pub const gcry_pk_algos_GCRY_PK_DSA: gcry_pk_algos = 17;
pub const gcry_pk_algos_GCRY_PK_ECC: gcry_pk_algos = 18;
pub const gcry_pk_algos_GCRY_PK_ELG: gcry_pk_algos = 20;
pub const gcry_pk_algos_GCRY_PK_ECDSA: gcry_pk_algos = 301;
pub const gcry_pk_algos_GCRY_PK_ECDH: gcry_pk_algos = 302;
pub const gcry_pk_algos_GCRY_PK_EDDSA: gcry_pk_algos = 303;
pub type gcry_pk_algos = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_pk_encrypt(
        result: *mut gcry_sexp_t,
        data: gcry_sexp_t,
        pkey: gcry_sexp_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_decrypt(
        result: *mut gcry_sexp_t,
        data: gcry_sexp_t,
        skey: gcry_sexp_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_sign(
        result: *mut gcry_sexp_t,
        data: gcry_sexp_t,
        skey: gcry_sexp_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_verify(
        sigval: gcry_sexp_t,
        data: gcry_sexp_t,
        pkey: gcry_sexp_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_testkey(key: gcry_sexp_t) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_genkey(r_key: *mut gcry_sexp_t, s_parms: gcry_sexp_t) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_ctl(
        cmd: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_algo_info(
        algo: ::std::os::raw::c_int,
        what: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        nbytes: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_pk_algo_name(algorithm: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_pk_map_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_pk_get_nbits(key: gcry_sexp_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gcry_pk_get_keygrip(
        key: gcry_sexp_t,
        array: *mut ::std::os::raw::c_uchar,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn gcry_pk_get_curve(
        key: gcry_sexp_t,
        iterator: ::std::os::raw::c_int,
        r_nbits: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_pk_get_param(
        algo: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
    ) -> gcry_sexp_t;
}
extern "C" {
    pub fn gcry_pubkey_get_sexp(
        r_sexp: *mut gcry_sexp_t,
        mode: ::std::os::raw::c_int,
        ctx: gcry_ctx_t,
    ) -> gcry_error_t;
}
pub const gcry_md_algos_GCRY_MD_NONE: gcry_md_algos = 0;
pub const gcry_md_algos_GCRY_MD_MD5: gcry_md_algos = 1;
pub const gcry_md_algos_GCRY_MD_SHA1: gcry_md_algos = 2;
pub const gcry_md_algos_GCRY_MD_RMD160: gcry_md_algos = 3;
pub const gcry_md_algos_GCRY_MD_MD2: gcry_md_algos = 5;
pub const gcry_md_algos_GCRY_MD_TIGER: gcry_md_algos = 6;
pub const gcry_md_algos_GCRY_MD_HAVAL: gcry_md_algos = 7;
pub const gcry_md_algos_GCRY_MD_SHA256: gcry_md_algos = 8;
pub const gcry_md_algos_GCRY_MD_SHA384: gcry_md_algos = 9;
pub const gcry_md_algos_GCRY_MD_SHA512: gcry_md_algos = 10;
pub const gcry_md_algos_GCRY_MD_SHA224: gcry_md_algos = 11;
pub const gcry_md_algos_GCRY_MD_MD4: gcry_md_algos = 301;
pub const gcry_md_algos_GCRY_MD_CRC32: gcry_md_algos = 302;
pub const gcry_md_algos_GCRY_MD_CRC32_RFC1510: gcry_md_algos = 303;
pub const gcry_md_algos_GCRY_MD_CRC24_RFC2440: gcry_md_algos = 304;
pub const gcry_md_algos_GCRY_MD_WHIRLPOOL: gcry_md_algos = 305;
pub const gcry_md_algos_GCRY_MD_TIGER1: gcry_md_algos = 306;
pub const gcry_md_algos_GCRY_MD_TIGER2: gcry_md_algos = 307;
pub const gcry_md_algos_GCRY_MD_GOSTR3411_94: gcry_md_algos = 308;
pub const gcry_md_algos_GCRY_MD_STRIBOG256: gcry_md_algos = 309;
pub const gcry_md_algos_GCRY_MD_STRIBOG512: gcry_md_algos = 310;
pub const gcry_md_algos_GCRY_MD_GOSTR3411_CP: gcry_md_algos = 311;
pub const gcry_md_algos_GCRY_MD_SHA3_224: gcry_md_algos = 312;
pub const gcry_md_algos_GCRY_MD_SHA3_256: gcry_md_algos = 313;
pub const gcry_md_algos_GCRY_MD_SHA3_384: gcry_md_algos = 314;
pub const gcry_md_algos_GCRY_MD_SHA3_512: gcry_md_algos = 315;
pub const gcry_md_algos_GCRY_MD_SHAKE128: gcry_md_algos = 316;
pub const gcry_md_algos_GCRY_MD_SHAKE256: gcry_md_algos = 317;
pub const gcry_md_algos_GCRY_MD_BLAKE2B_512: gcry_md_algos = 318;
pub const gcry_md_algos_GCRY_MD_BLAKE2B_384: gcry_md_algos = 319;
pub const gcry_md_algos_GCRY_MD_BLAKE2B_256: gcry_md_algos = 320;
pub const gcry_md_algos_GCRY_MD_BLAKE2B_160: gcry_md_algos = 321;
pub const gcry_md_algos_GCRY_MD_BLAKE2S_256: gcry_md_algos = 322;
pub const gcry_md_algos_GCRY_MD_BLAKE2S_224: gcry_md_algos = 323;
pub const gcry_md_algos_GCRY_MD_BLAKE2S_160: gcry_md_algos = 324;
pub const gcry_md_algos_GCRY_MD_BLAKE2S_128: gcry_md_algos = 325;
pub type gcry_md_algos = ::std::os::raw::c_uint;
pub const gcry_md_flags_GCRY_MD_FLAG_SECURE: gcry_md_flags = 1;
pub const gcry_md_flags_GCRY_MD_FLAG_HMAC: gcry_md_flags = 2;
pub const gcry_md_flags_GCRY_MD_FLAG_BUGEMU1: gcry_md_flags = 256;
pub type gcry_md_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_md_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_md_handle {
    pub ctx: *mut gcry_md_context,
    pub bufpos: ::std::os::raw::c_int,
    pub bufsize: ::std::os::raw::c_int,
    pub buf: [::std::os::raw::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_gcry_md_handle() {
    assert_eq!(
        ::std::mem::size_of::<gcry_md_handle>(),
        24usize,
        concat!("Size of: ", stringify!(gcry_md_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<gcry_md_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(gcry_md_handle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_md_handle>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_md_handle),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_md_handle>())).bufpos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_md_handle),
            "::",
            stringify!(bufpos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_md_handle>())).bufsize as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_md_handle),
            "::",
            stringify!(bufsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<gcry_md_handle>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gcry_md_handle),
            "::",
            stringify!(buf)
        )
    );
}
pub type gcry_md_hd_t = *mut gcry_md_handle;
pub type GCRY_MD_HD = *mut gcry_md_handle;
pub type GcryMDHd = *mut gcry_md_handle;
extern "C" {
    pub fn gcry_md_open(
        h: *mut gcry_md_hd_t,
        algo: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_close(hd: gcry_md_hd_t);
}
extern "C" {
    pub fn gcry_md_enable(hd: gcry_md_hd_t, algo: ::std::os::raw::c_int) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_copy(bhd: *mut gcry_md_hd_t, ahd: gcry_md_hd_t) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_reset(hd: gcry_md_hd_t);
}
extern "C" {
    pub fn gcry_md_ctl(
        hd: gcry_md_hd_t,
        cmd: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_write(hd: gcry_md_hd_t, buffer: *const ::std::os::raw::c_void, length: usize);
}
extern "C" {
    pub fn gcry_md_read(
        hd: gcry_md_hd_t,
        algo: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn gcry_md_extract(
        hd: gcry_md_hd_t,
        algo: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_md_hash_buffer(
        algo: ::std::os::raw::c_int,
        digest: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    pub fn gcry_md_hash_buffers(
        algo: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        digest: *mut ::std::os::raw::c_void,
        iov: *const gcry_buffer_t,
        iovcnt: ::std::os::raw::c_int,
    ) -> gpg_error_t;
}
extern "C" {
    pub fn gcry_md_get_algo(hd: gcry_md_hd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_md_get_algo_dlen(algo: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gcry_md_is_enabled(
        a: gcry_md_hd_t,
        algo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_md_is_secure(a: gcry_md_hd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_md_info(
        h: gcry_md_hd_t,
        what: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        nbytes: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_algo_info(
        algo: ::std::os::raw::c_int,
        what: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        nbytes: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_algo_name(algo: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_md_map_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_md_setkey(
        hd: gcry_md_hd_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_md_debug(hd: gcry_md_hd_t, suffix: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gcry_mac_handle {
    _unused: [u8; 0],
}
pub type gcry_mac_hd_t = *mut gcry_mac_handle;
pub const gcry_mac_algos_GCRY_MAC_NONE: gcry_mac_algos = 0;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA256: gcry_mac_algos = 101;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA224: gcry_mac_algos = 102;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA512: gcry_mac_algos = 103;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA384: gcry_mac_algos = 104;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA1: gcry_mac_algos = 105;
pub const gcry_mac_algos_GCRY_MAC_HMAC_MD5: gcry_mac_algos = 106;
pub const gcry_mac_algos_GCRY_MAC_HMAC_MD4: gcry_mac_algos = 107;
pub const gcry_mac_algos_GCRY_MAC_HMAC_RMD160: gcry_mac_algos = 108;
pub const gcry_mac_algos_GCRY_MAC_HMAC_TIGER1: gcry_mac_algos = 109;
pub const gcry_mac_algos_GCRY_MAC_HMAC_WHIRLPOOL: gcry_mac_algos = 110;
pub const gcry_mac_algos_GCRY_MAC_HMAC_GOSTR3411_94: gcry_mac_algos = 111;
pub const gcry_mac_algos_GCRY_MAC_HMAC_STRIBOG256: gcry_mac_algos = 112;
pub const gcry_mac_algos_GCRY_MAC_HMAC_STRIBOG512: gcry_mac_algos = 113;
pub const gcry_mac_algos_GCRY_MAC_HMAC_MD2: gcry_mac_algos = 114;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA3_224: gcry_mac_algos = 115;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA3_256: gcry_mac_algos = 116;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA3_384: gcry_mac_algos = 117;
pub const gcry_mac_algos_GCRY_MAC_HMAC_SHA3_512: gcry_mac_algos = 118;
pub const gcry_mac_algos_GCRY_MAC_CMAC_AES: gcry_mac_algos = 201;
pub const gcry_mac_algos_GCRY_MAC_CMAC_3DES: gcry_mac_algos = 202;
pub const gcry_mac_algos_GCRY_MAC_CMAC_CAMELLIA: gcry_mac_algos = 203;
pub const gcry_mac_algos_GCRY_MAC_CMAC_CAST5: gcry_mac_algos = 204;
pub const gcry_mac_algos_GCRY_MAC_CMAC_BLOWFISH: gcry_mac_algos = 205;
pub const gcry_mac_algos_GCRY_MAC_CMAC_TWOFISH: gcry_mac_algos = 206;
pub const gcry_mac_algos_GCRY_MAC_CMAC_SERPENT: gcry_mac_algos = 207;
pub const gcry_mac_algos_GCRY_MAC_CMAC_SEED: gcry_mac_algos = 208;
pub const gcry_mac_algos_GCRY_MAC_CMAC_RFC2268: gcry_mac_algos = 209;
pub const gcry_mac_algos_GCRY_MAC_CMAC_IDEA: gcry_mac_algos = 210;
pub const gcry_mac_algos_GCRY_MAC_CMAC_GOST28147: gcry_mac_algos = 211;
pub const gcry_mac_algos_GCRY_MAC_GMAC_AES: gcry_mac_algos = 401;
pub const gcry_mac_algos_GCRY_MAC_GMAC_CAMELLIA: gcry_mac_algos = 402;
pub const gcry_mac_algos_GCRY_MAC_GMAC_TWOFISH: gcry_mac_algos = 403;
pub const gcry_mac_algos_GCRY_MAC_GMAC_SERPENT: gcry_mac_algos = 404;
pub const gcry_mac_algos_GCRY_MAC_GMAC_SEED: gcry_mac_algos = 405;
pub const gcry_mac_algos_GCRY_MAC_POLY1305: gcry_mac_algos = 501;
pub const gcry_mac_algos_GCRY_MAC_POLY1305_AES: gcry_mac_algos = 502;
pub const gcry_mac_algos_GCRY_MAC_POLY1305_CAMELLIA: gcry_mac_algos = 503;
pub const gcry_mac_algos_GCRY_MAC_POLY1305_TWOFISH: gcry_mac_algos = 504;
pub const gcry_mac_algos_GCRY_MAC_POLY1305_SERPENT: gcry_mac_algos = 505;
pub const gcry_mac_algos_GCRY_MAC_POLY1305_SEED: gcry_mac_algos = 506;
pub type gcry_mac_algos = ::std::os::raw::c_uint;
pub const gcry_mac_flags_GCRY_MAC_FLAG_SECURE: gcry_mac_flags = 1;
pub type gcry_mac_flags = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_mac_open(
        handle: *mut gcry_mac_hd_t,
        algo: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        ctx: gcry_ctx_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_close(h: gcry_mac_hd_t);
}
extern "C" {
    pub fn gcry_mac_ctl(
        h: gcry_mac_hd_t,
        cmd: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_algo_info(
        algo: ::std::os::raw::c_int,
        what: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        nbytes: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_setkey(
        hd: gcry_mac_hd_t,
        key: *const ::std::os::raw::c_void,
        keylen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_setiv(
        hd: gcry_mac_hd_t,
        iv: *const ::std::os::raw::c_void,
        ivlen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_write(
        hd: gcry_mac_hd_t,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_read(
        hd: gcry_mac_hd_t,
        buffer: *mut ::std::os::raw::c_void,
        buflen: *mut usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_verify(
        hd: gcry_mac_hd_t,
        buffer: *const ::std::os::raw::c_void,
        buflen: usize,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_mac_get_algo(hd: gcry_mac_hd_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gcry_mac_get_algo_maclen(algo: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gcry_mac_get_algo_keylen(algo: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gcry_mac_algo_name(algorithm: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_mac_map_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub const gcry_kdf_algos_GCRY_KDF_NONE: gcry_kdf_algos = 0;
pub const gcry_kdf_algos_GCRY_KDF_SIMPLE_S2K: gcry_kdf_algos = 16;
pub const gcry_kdf_algos_GCRY_KDF_SALTED_S2K: gcry_kdf_algos = 17;
pub const gcry_kdf_algos_GCRY_KDF_ITERSALTED_S2K: gcry_kdf_algos = 19;
pub const gcry_kdf_algos_GCRY_KDF_PBKDF1: gcry_kdf_algos = 33;
pub const gcry_kdf_algos_GCRY_KDF_PBKDF2: gcry_kdf_algos = 34;
pub const gcry_kdf_algos_GCRY_KDF_SCRYPT: gcry_kdf_algos = 48;
pub type gcry_kdf_algos = ::std::os::raw::c_uint;
extern "C" {
    pub fn gcry_kdf_derive(
        passphrase: *const ::std::os::raw::c_void,
        passphraselen: usize,
        algo: ::std::os::raw::c_int,
        subalgo: ::std::os::raw::c_int,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        iterations: ::std::os::raw::c_ulong,
        keysize: usize,
        keybuffer: *mut ::std::os::raw::c_void,
    ) -> gpg_error_t;
}
pub const gcry_rng_types_GCRY_RNG_TYPE_STANDARD: gcry_rng_types = 1;
pub const gcry_rng_types_GCRY_RNG_TYPE_FIPS: gcry_rng_types = 2;
pub const gcry_rng_types_GCRY_RNG_TYPE_SYSTEM: gcry_rng_types = 3;
pub type gcry_rng_types = ::std::os::raw::c_uint;
pub const gcry_random_level_GCRY_WEAK_RANDOM: gcry_random_level = 0;
pub const gcry_random_level_GCRY_STRONG_RANDOM: gcry_random_level = 1;
pub const gcry_random_level_GCRY_VERY_STRONG_RANDOM: gcry_random_level = 2;
pub type gcry_random_level = ::std::os::raw::c_uint;
pub use self::gcry_random_level as gcry_random_level_t;
extern "C" {
    pub fn gcry_randomize(
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        level: gcry_random_level,
    );
}
extern "C" {
    pub fn gcry_random_add_bytes(
        buffer: *const ::std::os::raw::c_void,
        length: usize,
        quality: ::std::os::raw::c_int,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_random_bytes(
        nbytes: usize,
        level: gcry_random_level,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_random_bytes_secure(
        nbytes: usize,
        level: gcry_random_level,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_mpi_randomize(
        w: gcry_mpi_t,
        nbits: ::std::os::raw::c_uint,
        level: gcry_random_level,
    );
}
extern "C" {
    pub fn gcry_create_nonce(buffer: *mut ::std::os::raw::c_void, length: usize);
}
pub type gcry_prime_check_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg: *mut ::std::os::raw::c_void,
        mode: ::std::os::raw::c_int,
        candidate: gcry_mpi_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn gcry_prime_generate(
        prime: *mut gcry_mpi_t,
        prime_bits: ::std::os::raw::c_uint,
        factor_bits: ::std::os::raw::c_uint,
        factors: *mut *mut gcry_mpi_t,
        cb_func: gcry_prime_check_func_t,
        cb_arg: *mut ::std::os::raw::c_void,
        random_level: gcry_random_level_t,
        flags: ::std::os::raw::c_uint,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_prime_group_generator(
        r_g: *mut gcry_mpi_t,
        prime: gcry_mpi_t,
        factors: *mut gcry_mpi_t,
        start_g: gcry_mpi_t,
    ) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_prime_release_factors(factors: *mut gcry_mpi_t);
}
extern "C" {
    pub fn gcry_prime_check(x: gcry_mpi_t, flags: ::std::os::raw::c_uint) -> gcry_error_t;
}
extern "C" {
    pub fn gcry_ctx_release(ctx: gcry_ctx_t);
}
extern "C" {
    pub fn gcry_log_debug(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn gcry_log_debughex(
        text: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    pub fn gcry_log_debugmpi(text: *const ::std::os::raw::c_char, mpi: gcry_mpi_t);
}
extern "C" {
    pub fn gcry_log_debugpnt(
        text: *const ::std::os::raw::c_char,
        point: gcry_mpi_point_t,
        ctx: gcry_ctx_t,
    );
}
extern "C" {
    pub fn gcry_log_debugsxp(text: *const ::std::os::raw::c_char, sexp: gcry_sexp_t);
}
extern "C" {
    pub fn gcry_get_config(
        mode: ::std::os::raw::c_int,
        what: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub const gcry_log_levels_GCRY_LOG_CONT: gcry_log_levels = 0;
pub const gcry_log_levels_GCRY_LOG_INFO: gcry_log_levels = 10;
pub const gcry_log_levels_GCRY_LOG_WARN: gcry_log_levels = 20;
pub const gcry_log_levels_GCRY_LOG_ERROR: gcry_log_levels = 30;
pub const gcry_log_levels_GCRY_LOG_FATAL: gcry_log_levels = 40;
pub const gcry_log_levels_GCRY_LOG_BUG: gcry_log_levels = 50;
pub const gcry_log_levels_GCRY_LOG_DEBUG: gcry_log_levels = 100;
pub type gcry_log_levels = ::std::os::raw::c_uint;
pub type gcry_handler_progress_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
    ),
>;
pub type gcry_handler_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(n: usize) -> *mut ::std::os::raw::c_void>;
pub type gcry_handler_secure_check_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type gcry_handler_realloc_t = ::std::option::Option<
    unsafe extern "C" fn(p: *mut ::std::os::raw::c_void, n: usize) -> *mut ::std::os::raw::c_void,
>;
pub type gcry_handler_free_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type gcry_handler_no_mem_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type gcry_handler_error_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ),
>;
pub type gcry_handler_log_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ),
>;
extern "C" {
    pub fn gcry_set_progress_handler(
        cb: gcry_handler_progress_t,
        cb_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gcry_set_allocation_handler(
        func_alloc: gcry_handler_alloc_t,
        func_alloc_secure: gcry_handler_alloc_t,
        func_secure_check: gcry_handler_secure_check_t,
        func_realloc: gcry_handler_realloc_t,
        func_free: gcry_handler_free_t,
    );
}
extern "C" {
    pub fn gcry_set_outofcore_handler(
        h: gcry_handler_no_mem_t,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gcry_set_fatalerror_handler(
        fnc: gcry_handler_error_t,
        opaque: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn gcry_set_log_handler(f: gcry_handler_log_t, opaque: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gcry_set_gettext_handler(
        f: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
            ) -> *const ::std::os::raw::c_char,
        >,
    );
}
extern "C" {
    pub fn gcry_malloc(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_calloc(n: usize, m: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_malloc_secure(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_calloc_secure(n: usize, m: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_realloc(a: *mut ::std::os::raw::c_void, n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_strdup(string: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_xmalloc(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_xcalloc(n: usize, m: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_xmalloc_secure(n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_xcalloc_secure(n: usize, m: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_xrealloc(a: *mut ::std::os::raw::c_void, n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn gcry_xstrdup(a: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcry_free(a: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn gcry_is_secure(a: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
#[doc = " No good quality of the operation is needed (i.e.,"]
#[doc = " random numbers can be pseudo-random)."]
#[doc = " @ingroup crypto"]
pub const GNUNET_CRYPTO_Quality_GNUNET_CRYPTO_QUALITY_WEAK: GNUNET_CRYPTO_Quality = 0;
#[doc = " High-quality operations are desired."]
#[doc = " @ingroup crypto"]
pub const GNUNET_CRYPTO_Quality_GNUNET_CRYPTO_QUALITY_STRONG: GNUNET_CRYPTO_Quality = 1;
#[doc = " Randomness for IVs etc. is required."]
#[doc = " @ingroup crypto"]
pub const GNUNET_CRYPTO_Quality_GNUNET_CRYPTO_QUALITY_NONCE: GNUNET_CRYPTO_Quality = 2;
#[doc = " Desired quality level for random numbers."]
#[doc = " @ingroup crypto"]
pub type GNUNET_CRYPTO_Quality = ::std::os::raw::c_uint;
#[doc = " @brief 0-terminated ASCII encoding of a struct GNUNET_HashCode."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_CRYPTO_HashAsciiEncoded {
    pub encoding: [::std::os::raw::c_uchar; 104usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_HashAsciiEncoded() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_HashAsciiEncoded>(),
        104usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_HashAsciiEncoded))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_HashAsciiEncoded>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_HashAsciiEncoded))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_HashAsciiEncoded>())).encoding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_HashAsciiEncoded),
            "::",
            stringify!(encoding)
        )
    );
}
#[doc = " @brief header of what an ECC signature signs"]
#[doc = "        this must be followed by \"size - 8\" bytes of"]
#[doc = "        the actual signed data"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EccSignaturePurpose {
    #[doc = " How many bytes does this signature sign?"]
    #[doc = " (including this purpose header); in network"]
    #[doc = " byte order (!)."]
    pub size: u32,
    #[doc = " What does this signature vouch for?  This"]
    #[doc = " must contain a GNUNET_SIGNATURE_PURPOSE_XXX"]
    #[doc = " constant (from gnunet_signatures.h).  In"]
    #[doc = " network byte order!"]
    pub purpose: u32,
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EccSignaturePurpose() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EccSignaturePurpose>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EccSignaturePurpose))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EccSignaturePurpose>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_CRYPTO_EccSignaturePurpose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_EccSignaturePurpose>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EccSignaturePurpose),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_EccSignaturePurpose>())).purpose as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EccSignaturePurpose),
            "::",
            stringify!(purpose)
        )
    );
}
#[doc = " @brief an ECC signature using EdDSA."]
#[doc = " See cr.yp.to/papers.html#ed25519"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EddsaSignature {
    #[doc = " R value."]
    pub r: [::std::os::raw::c_uchar; 32usize],
    #[doc = " S value."]
    pub s: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EddsaSignature() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EddsaSignature>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EddsaSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EddsaSignature>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EddsaSignature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EddsaSignature>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EddsaSignature),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EddsaSignature>())).s as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EddsaSignature),
            "::",
            stringify!(s)
        )
    );
}
#[doc = " @brief an ECC signature using ECDSA"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EcdsaSignature {
    #[doc = " R value."]
    pub r: [::std::os::raw::c_uchar; 32usize],
    #[doc = " S value."]
    pub s: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EcdsaSignature() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EcdsaSignature>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EcdsaSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EcdsaSignature>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EcdsaSignature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EcdsaSignature>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EcdsaSignature),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EcdsaSignature>())).s as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EcdsaSignature),
            "::",
            stringify!(s)
        )
    );
}
#[doc = " Public key. Details in gnunet_util_crypto.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EddsaPublicKey {
    #[doc = " Point Q consists of a y-value mod p (256 bits); the x-value is"]
    #[doc = " always positive. The point is stored in Ed25519 standard"]
    #[doc = " compact format."]
    pub q_y: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EddsaPublicKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EddsaPublicKey>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EddsaPublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EddsaPublicKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EddsaPublicKey))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_EddsaPublicKey>())).q_y as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EddsaPublicKey),
            "::",
            stringify!(q_y)
        )
    );
}
#[doc = " Public ECC key (always for Curve25519) encoded in a format suitable"]
#[doc = " for network transmission and ECDSA signatures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EcdsaPublicKey {
    #[doc = " Q consists of an x- and a y-value, each mod p (256 bits), given"]
    #[doc = " here in affine coordinates and Ed25519 standard compact format."]
    pub q_y: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EcdsaPublicKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EcdsaPublicKey>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EcdsaPublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EcdsaPublicKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EcdsaPublicKey))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_EcdsaPublicKey>())).q_y as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EcdsaPublicKey),
            "::",
            stringify!(q_y)
        )
    );
}
#[doc = " The identity of the host (wraps the signing key of the peer)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_PeerIdentity {
    pub public_key: GNUNET_CRYPTO_EddsaPublicKey,
}
#[test]
fn bindgen_test_layout_GNUNET_PeerIdentity() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_PeerIdentity>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_PeerIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_PeerIdentity>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_PeerIdentity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_PeerIdentity>())).public_key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_PeerIdentity),
            "::",
            stringify!(public_key)
        )
    );
}
#[doc = " Public key. Details in gnunet_util_crypto.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EcdhePublicKey {
    #[doc = " Q consists of an x- and a y-value, each mod p (256 bits), given"]
    #[doc = " here in affine coordinates and Ed25519 standard compact format."]
    pub q_y: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EcdhePublicKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EcdhePublicKey>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EcdhePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EcdhePublicKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EcdhePublicKey))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_EcdhePublicKey>())).q_y as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EcdhePublicKey),
            "::",
            stringify!(q_y)
        )
    );
}
#[doc = " Private ECC key encoded for transmission.  To be used only for ECDH"]
#[doc = " key exchange (ECDHE to be precise)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EcdhePrivateKey {
    #[doc = " d is a value mod n, where n has at most 256 bits."]
    pub d: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EcdhePrivateKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EcdhePrivateKey>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EcdhePrivateKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EcdhePrivateKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EcdhePrivateKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EcdhePrivateKey>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EcdhePrivateKey),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Private ECC key encoded for transmission.  To be used only for ECDSA"]
#[doc = " signatures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EcdsaPrivateKey {
    #[doc = " d is a value mod n, where n has at most 256 bits."]
    pub d: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EcdsaPrivateKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EcdsaPrivateKey>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EcdsaPrivateKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EcdsaPrivateKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EcdsaPrivateKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EcdsaPrivateKey>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EcdsaPrivateKey),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Private ECC key encoded for transmission.  To be used only for EdDSA"]
#[doc = " signatures."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EddsaPrivateKey {
    #[doc = " d is a value mod n, where n has at most 256 bits."]
    pub d: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EddsaPrivateKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EddsaPrivateKey>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EddsaPrivateKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EddsaPrivateKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EddsaPrivateKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EddsaPrivateKey>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EddsaPrivateKey),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " @brief type for session keys"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_SymmetricSessionKey {
    #[doc = " Actual key for AES."]
    pub aes_key: [::std::os::raw::c_uchar; 32usize],
    #[doc = " Actual key for TwoFish."]
    pub twofish_key: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_SymmetricSessionKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_SymmetricSessionKey>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_SymmetricSessionKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_SymmetricSessionKey>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_CRYPTO_SymmetricSessionKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_SymmetricSessionKey>())).aes_key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_SymmetricSessionKey),
            "::",
            stringify!(aes_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_SymmetricSessionKey>())).twofish_key as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_SymmetricSessionKey),
            "::",
            stringify!(twofish_key)
        )
    );
}
#[doc = " Type of a nonce used for challenges."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChallengeNonceP {
    #[doc = " The value of the nonce.  Note that this is NOT a hash."]
    pub value: GNUNET_ShortHashCode,
}
#[test]
fn bindgen_test_layout_ChallengeNonceP() {
    assert_eq!(
        ::std::mem::size_of::<ChallengeNonceP>(),
        32usize,
        concat!("Size of: ", stringify!(ChallengeNonceP))
    );
    assert_eq!(
        ::std::mem::align_of::<ChallengeNonceP>(),
        4usize,
        concat!("Alignment of ", stringify!(ChallengeNonceP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ChallengeNonceP>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChallengeNonceP),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " @brief IV for sym cipher"]
#[doc = ""]
#[doc = " NOTE: must be smaller (!) in size than the"]
#[doc = " `struct GNUNET_HashCode`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_SymmetricInitializationVector {
    pub aes_iv: [::std::os::raw::c_uchar; 16usize],
    pub twofish_iv: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_SymmetricInitializationVector() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_SymmetricInitializationVector>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_CRYPTO_SymmetricInitializationVector)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_SymmetricInitializationVector>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_CRYPTO_SymmetricInitializationVector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_SymmetricInitializationVector>())).aes_iv
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_SymmetricInitializationVector),
            "::",
            stringify!(aes_iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_SymmetricInitializationVector>())).twofish_iv
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_SymmetricInitializationVector),
            "::",
            stringify!(twofish_iv)
        )
    );
}
#[doc = " @brief type for (message) authentication keys"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_CRYPTO_AuthKey {
    pub key: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_AuthKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_AuthKey>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_AuthKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_AuthKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_AuthKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_AuthKey>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_AuthKey),
            "::",
            stringify!(key)
        )
    );
}
#[doc = " Paillier public key."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_CRYPTO_PaillierPublicKey {
    #[doc = " N value."]
    pub n: [::std::os::raw::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_PaillierPublicKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_PaillierPublicKey>(),
        256usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_PaillierPublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_PaillierPublicKey>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_PaillierPublicKey))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_PaillierPublicKey>())).n as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_PaillierPublicKey),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " Paillier private key."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_CRYPTO_PaillierPrivateKey {
    #[doc = " Lambda-component of the private key."]
    pub lambda: [::std::os::raw::c_uchar; 256usize],
    #[doc = " Mu-component of the private key."]
    pub mu: [::std::os::raw::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_PaillierPrivateKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_PaillierPrivateKey>(),
        512usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_PaillierPrivateKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_PaillierPrivateKey>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_CRYPTO_PaillierPrivateKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_PaillierPrivateKey>())).lambda as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_PaillierPrivateKey),
            "::",
            stringify!(lambda)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_PaillierPrivateKey>())).mu as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_PaillierPrivateKey),
            "::",
            stringify!(mu)
        )
    );
}
#[doc = " Paillier ciphertext."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct GNUNET_CRYPTO_PaillierCiphertext {
    #[doc = " Guaranteed minimum number of homomorphic operations with this ciphertext,"]
    #[doc = " in network byte order (NBO)."]
    pub remaining_ops: i32,
    #[doc = " The bits of the ciphertext."]
    pub bits: [::std::os::raw::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_PaillierCiphertext() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_PaillierCiphertext>(),
        516usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_PaillierCiphertext))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_PaillierCiphertext>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_CRYPTO_PaillierCiphertext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_PaillierCiphertext>())).remaining_ops as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_PaillierCiphertext),
            "::",
            stringify!(remaining_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_PaillierCiphertext>())).bits as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_PaillierCiphertext),
            "::",
            stringify!(bits)
        )
    );
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Seed a weak random generator. Only #GNUNET_CRYPTO_QUALITY_WEAK-mode generator"]
    #[doc = " can be seeded."]
    #[doc = ""]
    #[doc = " @param seed the seed to use"]
    pub fn GNUNET_CRYPTO_seed_weak_random(seed: i32);
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Calculate the checksum of a buffer in one step."]
    #[doc = ""]
    #[doc = " @param buf buffer to calculate CRC over"]
    #[doc = " @param len number of bytes in @a buf"]
    #[doc = " @return crc8 value"]
    pub fn GNUNET_CRYPTO_crc8_n(buf: *const ::std::os::raw::c_void, len: usize) -> u8;
}
extern "C" {
    #[doc = " Perform an incremental step in a CRC16 (for TCP/IP) calculation."]
    #[doc = ""]
    #[doc = " @param sum current sum, initially 0"]
    #[doc = " @param buf buffer to calculate CRC over (must be 16-bit aligned)"]
    #[doc = " @param len number of bytes in @a buf, must be multiple of 2"]
    #[doc = " @return updated crc sum (must be subjected to #GNUNET_CRYPTO_crc16_finish to get actual crc16)"]
    pub fn GNUNET_CRYPTO_crc16_step(
        sum: u32,
        buf: *const ::std::os::raw::c_void,
        len: usize,
    ) -> u32;
}
extern "C" {
    #[doc = " Convert results from GNUNET_CRYPTO_crc16_step to final crc16."]
    #[doc = ""]
    #[doc = " @param sum cumulative sum"]
    #[doc = " @return crc16 value"]
    pub fn GNUNET_CRYPTO_crc16_finish(sum: u32) -> u16;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Calculate the checksum of a buffer in one step."]
    #[doc = ""]
    #[doc = " @param buf buffer to calculate CRC over (must be 16-bit aligned)"]
    #[doc = " @param len number of bytes in @a buf, must be multiple of 2"]
    #[doc = " @return crc16 value"]
    pub fn GNUNET_CRYPTO_crc16_n(buf: *const ::std::os::raw::c_void, len: usize) -> u16;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Compute the CRC32 checksum for the first len"]
    #[doc = " bytes of the buffer."]
    #[doc = ""]
    #[doc = " @param buf the data over which we're taking the CRC"]
    #[doc = " @param len the length of the buffer @a buf in bytes"]
    #[doc = " @return the resulting CRC32 checksum"]
    pub fn GNUNET_CRYPTO_crc32_n(buf: *const ::std::os::raw::c_void, len: usize) -> i32;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Zero out @a buffer, securely against compiler optimizations."]
    #[doc = " Used to delete key material."]
    #[doc = ""]
    #[doc = " @param buffer the buffer to zap"]
    #[doc = " @param length buffer length"]
    pub fn GNUNET_CRYPTO_zero_keys(buffer: *mut ::std::os::raw::c_void, length: usize);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Fill block with a random values."]
    #[doc = ""]
    #[doc = " @param mode desired quality of the random number"]
    #[doc = " @param buffer the buffer to fill"]
    #[doc = " @param length buffer length"]
    pub fn GNUNET_CRYPTO_random_block(
        mode: GNUNET_CRYPTO_Quality,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Fill UUID with a timeflake pseudo-random value.  Note that"]
    #[doc = " timeflakes use only 80 bits of randomness and 48 bits"]
    #[doc = " to encode a timestamp in milliseconds. So what we return"]
    #[doc = " here is not a completely random number."]
    #[doc = ""]
    #[doc = " @param mode desired quality of the random number"]
    #[doc = " @param uuid the value to fill"]
    pub fn GNUNET_CRYPTO_random_timeflake(mode: GNUNET_CRYPTO_Quality, uuid: *mut GNUNET_Uuid);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Produce a random value."]
    #[doc = ""]
    #[doc = " @param mode desired quality of the random number"]
    #[doc = " @param i the upper limit (exclusive) for the random number"]
    #[doc = " @return a random value in the interval [0,@a i) (exclusive)."]
    pub fn GNUNET_CRYPTO_random_u32(mode: GNUNET_CRYPTO_Quality, i: u32) -> u32;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Random on unsigned 64-bit values."]
    #[doc = ""]
    #[doc = " @param mode desired quality of the random number"]
    #[doc = " @param max value returned will be in range [0,@a max) (exclusive)"]
    #[doc = " @return random 64-bit number"]
    pub fn GNUNET_CRYPTO_random_u64(mode: GNUNET_CRYPTO_Quality, max: u64) -> u64;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Get an array with a random permutation of the"]
    #[doc = " numbers 0...n-1."]
    #[doc = " @param mode #GNUNET_CRYPTO_QUALITY_STRONG if the strong (but expensive) PRNG should be used,"]
    #[doc = "             #GNUNET_CRYPTO_QUALITY_WEAK or #GNUNET_CRYPTO_QUALITY_NONCE otherwise"]
    #[doc = " @param n the size of the array"]
    #[doc = " @return the permutation array (allocated from heap)"]
    pub fn GNUNET_CRYPTO_random_permute(
        mode: GNUNET_CRYPTO_Quality,
        n: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Create a new random session key."]
    #[doc = ""]
    #[doc = " @param key key to initialize"]
    pub fn GNUNET_CRYPTO_symmetric_create_session_key(key: *mut GNUNET_CRYPTO_SymmetricSessionKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Encrypt a block using a symmetric sessionkey."]
    #[doc = ""]
    #[doc = " @param block the block to encrypt"]
    #[doc = " @param size the size of the @a block"]
    #[doc = " @param sessionkey the key used to encrypt"]
    #[doc = " @param iv the initialization vector to use, use INITVALUE"]
    #[doc = "        for streams."]
    #[doc = " @return the size of the encrypted block, -1 for errors"]
    pub fn GNUNET_CRYPTO_symmetric_encrypt(
        block: *const ::std::os::raw::c_void,
        size: usize,
        sessionkey: *const GNUNET_CRYPTO_SymmetricSessionKey,
        iv: *const GNUNET_CRYPTO_SymmetricInitializationVector,
        result: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Decrypt a given block using a symmetric sessionkey."]
    #[doc = ""]
    #[doc = " @param block the data to decrypt, encoded as returned by encrypt"]
    #[doc = " @param size how big is the block?"]
    #[doc = " @param sessionkey the key used to decrypt"]
    #[doc = " @param iv the initialization vector to use"]
    #[doc = " @param result address to store the result at"]
    #[doc = " @return -1 on failure, size of decrypted block on success"]
    pub fn GNUNET_CRYPTO_symmetric_decrypt(
        block: *const ::std::os::raw::c_void,
        size: usize,
        sessionkey: *const GNUNET_CRYPTO_SymmetricSessionKey,
        iv: *const GNUNET_CRYPTO_SymmetricInitializationVector,
        result: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief Derive an IV"]
    #[doc = " @param iv initialization vector"]
    #[doc = " @param skey session key"]
    #[doc = " @param salt salt for the derivation"]
    #[doc = " @param salt_len size of the @a salt"]
    #[doc = " @param ... pairs of void * & size_t for context chunks, terminated by NULL"]
    pub fn GNUNET_CRYPTO_symmetric_derive_iv(
        iv: *mut GNUNET_CRYPTO_SymmetricInitializationVector,
        skey: *const GNUNET_CRYPTO_SymmetricSessionKey,
        salt: *const ::std::os::raw::c_void,
        salt_len: usize,
        ...
    );
}
extern "C" {
    #[doc = " @brief Derive an IV"]
    #[doc = " @param iv initialization vector"]
    #[doc = " @param skey session key"]
    #[doc = " @param salt salt for the derivation"]
    #[doc = " @param salt_len size of the @a salt"]
    #[doc = " @param argp pairs of void * & size_t for context chunks, terminated by NULL"]
    pub fn GNUNET_CRYPTO_symmetric_derive_iv_v(
        iv: *mut GNUNET_CRYPTO_SymmetricInitializationVector,
        skey: *const GNUNET_CRYPTO_SymmetricSessionKey,
        salt: *const ::std::os::raw::c_void,
        salt_len: usize,
        argp: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Convert hash to ASCII encoding."]
    #[doc = " @param block the hash code"]
    #[doc = " @param result where to store the encoding (struct GNUNET_CRYPTO_HashAsciiEncoded can be"]
    #[doc = "  safely cast to char*, a '\\\\0' termination is set)."]
    pub fn GNUNET_CRYPTO_hash_to_enc(
        block: *const GNUNET_HashCode,
        result: *mut GNUNET_CRYPTO_HashAsciiEncoded,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Convert ASCII encoding back to a 'struct GNUNET_HashCode'"]
    #[doc = ""]
    #[doc = " @param enc the encoding"]
    #[doc = " @param enclen number of characters in @a enc (without 0-terminator, which can be missing)"]
    #[doc = " @param result where to store the hash code"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if result has the wrong encoding"]
    pub fn GNUNET_CRYPTO_hash_from_string2(
        enc: *const ::std::os::raw::c_char,
        enclen: usize,
        result: *mut GNUNET_HashCode,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = ""]
    #[doc = " Compute the distance between 2 hashcodes.  The"]
    #[doc = " computation must be fast, not involve @a a[0] or @a a[4] (they're used"]
    #[doc = " elsewhere), and be somewhat consistent. And of course, the result"]
    #[doc = " should be a positive number."]
    #[doc = ""]
    #[doc = " @param a some hash code"]
    #[doc = " @param b some hash code"]
    #[doc = " @return number between 0 and UINT32_MAX"]
    pub fn GNUNET_CRYPTO_hash_distance_u32(
        a: *const GNUNET_HashCode,
        b: *const GNUNET_HashCode,
    ) -> u32;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Compute hash of a given block."]
    #[doc = ""]
    #[doc = " @param block the data to hash"]
    #[doc = " @param size size of the @a block"]
    #[doc = " @param ret pointer to where to write the hashcode"]
    pub fn GNUNET_CRYPTO_hash(
        block: *const ::std::os::raw::c_void,
        size: usize,
        ret: *mut GNUNET_HashCode,
    );
}
#[doc = " Value for a salt for #GNUNET_CRYPTO_pow_hash()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_PowSalt {
    pub salt: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_PowSalt() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_PowSalt>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_PowSalt))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_PowSalt>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_PowSalt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_PowSalt>())).salt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_PowSalt),
            "::",
            stringify!(salt)
        )
    );
}
extern "C" {
    #[doc = " Calculate the 'proof-of-work' hash (an expensive hash)."]
    #[doc = ""]
    #[doc = " @param salt salt for the hash. Must be crypto_pwhash_argon2id_SALTBYTES long."]
    #[doc = " @param buf data to hash"]
    #[doc = " @param buf_len number of bytes in @a buf"]
    #[doc = " @param result where to write the resulting hash"]
    pub fn GNUNET_CRYPTO_pow_hash(
        salt: *const GNUNET_CRYPTO_PowSalt,
        buf: *const ::std::os::raw::c_void,
        buf_len: usize,
        result: *mut GNUNET_HashCode,
    );
}
#[doc = " Context for cumulative hashing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_HashContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Start incremental hashing operation."]
    #[doc = ""]
    #[doc = " @return context for incremental hash computation"]
    pub fn GNUNET_CRYPTO_hash_context_start() -> *mut GNUNET_HashContext;
}
extern "C" {
    #[doc = " Make a copy of the hash computation."]
    #[doc = ""]
    #[doc = " @param hc hash context to use (to continue hashing independently)"]
    #[doc = " @return copy of @a hc"]
    pub fn GNUNET_CRYPTO_hash_context_copy(
        hc: *const GNUNET_HashContext,
    ) -> *mut GNUNET_HashContext;
}
extern "C" {
    #[doc = " Add data to be hashed."]
    #[doc = ""]
    #[doc = " @param hc cumulative hash context"]
    #[doc = " @param buf data to add"]
    #[doc = " @param size number of bytes in @a buf"]
    pub fn GNUNET_CRYPTO_hash_context_read(
        hc: *mut GNUNET_HashContext,
        buf: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " Finish the hash computation."]
    #[doc = ""]
    #[doc = " @param hc hash context to use, is freed in the process"]
    #[doc = " @param r_hash where to write the latest / final hash code"]
    pub fn GNUNET_CRYPTO_hash_context_finish(
        hc: *mut GNUNET_HashContext,
        r_hash: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " Abort hashing, do not bother calculating final result."]
    #[doc = ""]
    #[doc = " @param hc hash context to destroy"]
    pub fn GNUNET_CRYPTO_hash_context_abort(hc: *mut GNUNET_HashContext);
}
extern "C" {
    #[doc = " Calculate HMAC of a message (RFC 2104)"]
    #[doc = " TODO: Shouldn' this be the standard hmac function and"]
    #[doc = " the above be renamed?"]
    #[doc = ""]
    #[doc = " @param key secret key"]
    #[doc = " @param key_len secret key length"]
    #[doc = " @param plaintext input plaintext"]
    #[doc = " @param plaintext_len length of @a plaintext"]
    #[doc = " @param hmac where to store the hmac"]
    pub fn GNUNET_CRYPTO_hmac_raw(
        key: *const ::std::os::raw::c_void,
        key_len: usize,
        plaintext: *const ::std::os::raw::c_void,
        plaintext_len: usize,
        hmac: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Calculate HMAC of a message (RFC 2104)"]
    #[doc = ""]
    #[doc = " @param key secret key"]
    #[doc = " @param plaintext input plaintext"]
    #[doc = " @param plaintext_len length of @a plaintext"]
    #[doc = " @param hmac where to store the hmac"]
    pub fn GNUNET_CRYPTO_hmac(
        key: *const GNUNET_CRYPTO_AuthKey,
        plaintext: *const ::std::os::raw::c_void,
        plaintext_len: usize,
        hmac: *mut GNUNET_HashCode,
    );
}
#[doc = " Function called once the hash computation over the"]
#[doc = " specified file has completed."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param res resulting hash, NULL on error"]
pub type GNUNET_CRYPTO_HashCompletedCallback = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, res: *const GNUNET_HashCode),
>;
#[doc = " Handle to file hashing operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_FileHashContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Compute the hash of an entire file."]
    #[doc = ""]
    #[doc = " @param priority scheduling priority to use"]
    #[doc = " @param filename name of file to hash"]
    #[doc = " @param blocksize number of bytes to process in one task"]
    #[doc = " @param callback function to call upon completion"]
    #[doc = " @param callback_cls closure for @a callback"]
    #[doc = " @return NULL on (immediate) error"]
    pub fn GNUNET_CRYPTO_hash_file(
        priority: GNUNET_SCHEDULER_Priority,
        filename: *const ::std::os::raw::c_char,
        blocksize: usize,
        callback: GNUNET_CRYPTO_HashCompletedCallback,
        callback_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_CRYPTO_FileHashContext;
}
extern "C" {
    #[doc = " Cancel a file hashing operation."]
    #[doc = ""]
    #[doc = " @param fhc operation to cancel (callback must not yet have been invoked)"]
    pub fn GNUNET_CRYPTO_hash_file_cancel(fhc: *mut GNUNET_CRYPTO_FileHashContext);
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Create a random hash code."]
    #[doc = ""]
    #[doc = " @param mode desired quality level"]
    #[doc = " @param result hash code that is randomized"]
    pub fn GNUNET_CRYPTO_hash_create_random(
        mode: GNUNET_CRYPTO_Quality,
        result: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " compute @a result = @a b - @a a"]
    #[doc = ""]
    #[doc = " @param a some hash code"]
    #[doc = " @param b some hash code"]
    #[doc = " @param result set to @a b - @a a"]
    pub fn GNUNET_CRYPTO_hash_difference(
        a: *const GNUNET_HashCode,
        b: *const GNUNET_HashCode,
        result: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " compute @a result = @a a + @a delta"]
    #[doc = ""]
    #[doc = " @param a some hash code"]
    #[doc = " @param delta some hash code"]
    #[doc = " @param result set to @a a + @a delta"]
    pub fn GNUNET_CRYPTO_hash_sum(
        a: *const GNUNET_HashCode,
        delta: *const GNUNET_HashCode,
        result: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " compute result = a ^ b"]
    #[doc = ""]
    #[doc = " @param a some hash code"]
    #[doc = " @param b some hash code"]
    #[doc = " @param result set to @a a ^ @a b"]
    pub fn GNUNET_CRYPTO_hash_xor(
        a: *const GNUNET_HashCode,
        b: *const GNUNET_HashCode,
        result: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Convert a hashcode into a key."]
    #[doc = ""]
    #[doc = " @param hc hash code that serves to generate the key"]
    #[doc = " @param skey set to a valid session key"]
    #[doc = " @param iv set to a valid initialization vector"]
    pub fn GNUNET_CRYPTO_hash_to_aes_key(
        hc: *const GNUNET_HashCode,
        skey: *mut GNUNET_CRYPTO_SymmetricSessionKey,
        iv: *mut GNUNET_CRYPTO_SymmetricInitializationVector,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Obtain a bit from a hashcode."]
    #[doc = ""]
    #[doc = " @param code the `struct GNUNET_HashCode` to index bit-wise"]
    #[doc = " @param bit index into the hashcode, [0...159] where 0 is the leftmost bit"]
    #[doc = "        (bytes in code interpreted big endian)"]
    #[doc = " @return Bit \\a bit from hashcode \\a code, -1 for invalid index"]
    pub fn GNUNET_CRYPTO_hash_get_bit_ltr(
        code: *const GNUNET_HashCode,
        bit: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain a bit from a hashcode."]
    #[doc = " @param code the GNUNET_CRYPTO_hash to index bit-wise"]
    #[doc = " @param bit index into the hashcode, [0...511] where 0 is the rightmost bit"]
    #[doc = "        (bytes in code interpreted little endian)"]
    #[doc = " @return Bit \\a bit from hashcode \\a code, -1 for invalid index"]
    pub fn GNUNET_CRYPTO_hash_get_bit_rtl(
        code: *const GNUNET_HashCode,
        bit: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Determine how many low order bits match in two"]
    #[doc = " `struct GNUNET_HashCodes`.  i.e. - 010011 and 011111 share"]
    #[doc = " the first two lowest order bits, and therefore the"]
    #[doc = " return value is two (NOT XOR distance, nor how many"]
    #[doc = " bits match absolutely!)."]
    #[doc = ""]
    #[doc = " @param first the first hashcode"]
    #[doc = " @param second the hashcode to compare first to"]
    #[doc = " @return the number of bits that match"]
    pub fn GNUNET_CRYPTO_hash_matching_bits(
        first: *const GNUNET_HashCode,
        second: *const GNUNET_HashCode,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Compare function for HashCodes, producing a total ordering"]
    #[doc = " of all hashcodes."]
    #[doc = ""]
    #[doc = " @param h1 some hash code"]
    #[doc = " @param h2 some hash code"]
    #[doc = " @return 1 if @a h1 > @a h2, -1 if @a h1 < @a h2 and 0 if @a h1 == @a h2."]
    pub fn GNUNET_CRYPTO_hash_cmp(
        h1: *const GNUNET_HashCode,
        h2: *const GNUNET_HashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " Find out which of the two GNUNET_CRYPTO_hash codes is closer to target"]
    #[doc = " in the XOR metric (Kademlia)."]
    #[doc = ""]
    #[doc = " @param h1 some hash code"]
    #[doc = " @param h2 some hash code"]
    #[doc = " @param target some hash code"]
    #[doc = " @return -1 if @a h1 is closer, 1 if @a h2 is closer and 0 if @a h1== @a h2."]
    pub fn GNUNET_CRYPTO_hash_xorcmp(
        h1: *const GNUNET_HashCode,
        h2: *const GNUNET_HashCode,
        target: *const GNUNET_HashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " @brief Derive an authentication key"]
    #[doc = " @param key authentication key"]
    #[doc = " @param rkey root key"]
    #[doc = " @param salt salt"]
    #[doc = " @param salt_len size of the salt"]
    #[doc = " @param argp pair of void * & size_t for context chunks, terminated by NULL"]
    pub fn GNUNET_CRYPTO_hmac_derive_key_v(
        key: *mut GNUNET_CRYPTO_AuthKey,
        rkey: *const GNUNET_CRYPTO_SymmetricSessionKey,
        salt: *const ::std::os::raw::c_void,
        salt_len: usize,
        argp: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " @brief Derive an authentication key"]
    #[doc = " @param key authentication key"]
    #[doc = " @param rkey root key"]
    #[doc = " @param salt salt"]
    #[doc = " @param salt_len size of the salt"]
    #[doc = " @param ... pair of void * & size_t for context chunks, terminated by NULL"]
    pub fn GNUNET_CRYPTO_hmac_derive_key(
        key: *mut GNUNET_CRYPTO_AuthKey,
        rkey: *const GNUNET_CRYPTO_SymmetricSessionKey,
        salt: *const ::std::os::raw::c_void,
        salt_len: usize,
        ...
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " @brief Derive key"]
    #[doc = " @param result buffer for the derived key, allocated by caller"]
    #[doc = " @param out_len desired length of the derived key"]
    #[doc = " @param xtr_algo hash algorithm for the extraction phase, GCRY_MD_..."]
    #[doc = " @param prf_algo hash algorithm for the expansion phase, GCRY_MD_..."]
    #[doc = " @param xts salt"]
    #[doc = " @param xts_len length of @a xts"]
    #[doc = " @param skm source key material"]
    #[doc = " @param skm_len length of @a skm"]
    #[doc = " @param ... pair of void * & size_t for context chunks, terminated by NULL"]
    #[doc = " @return #GNUNET_YES on success"]
    pub fn GNUNET_CRYPTO_hkdf(
        result: *mut ::std::os::raw::c_void,
        out_len: usize,
        xtr_algo: ::std::os::raw::c_int,
        prf_algo: ::std::os::raw::c_int,
        xts: *const ::std::os::raw::c_void,
        xts_len: usize,
        skm: *const ::std::os::raw::c_void,
        skm_len: usize,
        ...
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " @brief Derive key"]
    #[doc = " @param result buffer for the derived key, allocated by caller"]
    #[doc = " @param out_len desired length of the derived key"]
    #[doc = " @param xtr_algo hash algorithm for the extraction phase, GCRY_MD_..."]
    #[doc = " @param prf_algo hash algorithm for the expansion phase, GCRY_MD_..."]
    #[doc = " @param xts salt"]
    #[doc = " @param xts_len length of @a xts"]
    #[doc = " @param skm source key material"]
    #[doc = " @param skm_len length of @a skm"]
    #[doc = " @param argp va_list of void * & size_t pairs for context chunks"]
    #[doc = " @return #GNUNET_YES on success"]
    pub fn GNUNET_CRYPTO_hkdf_v(
        result: *mut ::std::os::raw::c_void,
        out_len: usize,
        xtr_algo: ::std::os::raw::c_int,
        prf_algo: ::std::os::raw::c_int,
        xts: *const ::std::os::raw::c_void,
        xts_len: usize,
        skm: *const ::std::os::raw::c_void,
        skm_len: usize,
        argp: *mut __va_list_tag,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @brief Derive key"]
    #[doc = " @param result buffer for the derived key, allocated by caller"]
    #[doc = " @param out_len desired length of the derived key"]
    #[doc = " @param xts salt"]
    #[doc = " @param xts_len length of @a xts"]
    #[doc = " @param skm source key material"]
    #[doc = " @param skm_len length of @a skm"]
    #[doc = " @param argp va_list of void * & size_t pairs for context chunks"]
    #[doc = " @return #GNUNET_YES on success"]
    pub fn GNUNET_CRYPTO_kdf_v(
        result: *mut ::std::os::raw::c_void,
        out_len: usize,
        xts: *const ::std::os::raw::c_void,
        xts_len: usize,
        skm: *const ::std::os::raw::c_void,
        skm_len: usize,
        argp: *mut __va_list_tag,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Deterministically generate a pseudo-random number uniformly from the"]
    #[doc = " integers modulo a libgcrypt mpi."]
    #[doc = ""]
    #[doc = " @param[out] r MPI value set to the FDH"]
    #[doc = " @param n MPI to work modulo"]
    #[doc = " @param xts salt"]
    #[doc = " @param xts_len length of @a xts"]
    #[doc = " @param skm source key material"]
    #[doc = " @param skm_len length of @a skm"]
    #[doc = " @param ctx context string"]
    pub fn GNUNET_CRYPTO_kdf_mod_mpi(
        r: *mut gcry_mpi_t,
        n: gcry_mpi_t,
        xts: *const ::std::os::raw::c_void,
        xts_len: usize,
        skm: *const ::std::os::raw::c_void,
        skm_len: usize,
        ctx: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @ingroup hash"]
    #[doc = " @brief Derive key"]
    #[doc = " @param result buffer for the derived key, allocated by caller"]
    #[doc = " @param out_len desired length of the derived key"]
    #[doc = " @param xts salt"]
    #[doc = " @param xts_len length of @a xts"]
    #[doc = " @param skm source key material"]
    #[doc = " @param skm_len length of @a skm"]
    #[doc = " @param ... void * & size_t pairs for context chunks"]
    #[doc = " @return #GNUNET_YES on success"]
    pub fn GNUNET_CRYPTO_kdf(
        result: *mut ::std::os::raw::c_void,
        out_len: usize,
        xts: *const ::std::os::raw::c_void,
        xts_len: usize,
        skm: *const ::std::os::raw::c_void,
        skm_len: usize,
        ...
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Extract the public key for the given private key."]
    #[doc = ""]
    #[doc = " @param priv the private key"]
    #[doc = " @param pub where to write the public key"]
    pub fn GNUNET_CRYPTO_ecdsa_key_get_public(
        priv_: *const GNUNET_CRYPTO_EcdsaPrivateKey,
        pub_: *mut GNUNET_CRYPTO_EcdsaPublicKey,
    );
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Extract the public key for the given private key."]
    #[doc = ""]
    #[doc = " @param priv the private key"]
    #[doc = " @param pub where to write the public key"]
    pub fn GNUNET_CRYPTO_eddsa_key_get_public(
        priv_: *const GNUNET_CRYPTO_EddsaPrivateKey,
        pub_: *mut GNUNET_CRYPTO_EddsaPublicKey,
    );
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Extract the public key for the given private key."]
    #[doc = ""]
    #[doc = " @param priv the private key"]
    #[doc = " @param pub where to write the public key"]
    pub fn GNUNET_CRYPTO_ecdhe_key_get_public(
        priv_: *const GNUNET_CRYPTO_EcdhePrivateKey,
        pub_: *mut GNUNET_CRYPTO_EcdhePublicKey,
    );
}
extern "C" {
    #[doc = " Convert a public key to a string."]
    #[doc = ""]
    #[doc = " @param pub key to convert"]
    #[doc = " @return string representing @a pub"]
    pub fn GNUNET_CRYPTO_ecdsa_public_key_to_string(
        pub_: *const GNUNET_CRYPTO_EcdsaPublicKey,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a private key to a string."]
    #[doc = ""]
    #[doc = " @param priv key to convert"]
    #[doc = " @return string representing @a priv"]
    pub fn GNUNET_CRYPTO_ecdsa_private_key_to_string(
        priv_: *const GNUNET_CRYPTO_EcdsaPrivateKey,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a private key to a string."]
    #[doc = ""]
    #[doc = " @param priv key to convert"]
    #[doc = " @return string representing @a pub"]
    pub fn GNUNET_CRYPTO_eddsa_private_key_to_string(
        priv_: *const GNUNET_CRYPTO_EddsaPrivateKey,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a public key to a string."]
    #[doc = ""]
    #[doc = " @param pub key to convert"]
    #[doc = " @return string representing @a pub"]
    pub fn GNUNET_CRYPTO_eddsa_public_key_to_string(
        pub_: *const GNUNET_CRYPTO_EddsaPublicKey,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a string representing a public key to a public key."]
    #[doc = ""]
    #[doc = " @param enc encoded public key"]
    #[doc = " @param enclen number of bytes in @a enc (without 0-terminator)"]
    #[doc = " @param pub where to store the public key"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_ecdsa_public_key_from_string(
        enc: *const ::std::os::raw::c_char,
        enclen: usize,
        pub_: *mut GNUNET_CRYPTO_EcdsaPublicKey,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Convert a string representing a private key to a private key."]
    #[doc = ""]
    #[doc = " @param enc encoded public key"]
    #[doc = " @param enclen number of bytes in @a enc (without 0-terminator)"]
    #[doc = " @param priv where to store the private key"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_eddsa_private_key_from_string(
        enc: *const ::std::os::raw::c_char,
        enclen: usize,
        pub_: *mut GNUNET_CRYPTO_EddsaPrivateKey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a string representing a public key to a public key."]
    #[doc = ""]
    #[doc = " @param enc encoded public key"]
    #[doc = " @param enclen number of bytes in @a enc (without 0-terminator)"]
    #[doc = " @param pub where to store the public key"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_eddsa_public_key_from_string(
        enc: *const ::std::os::raw::c_char,
        enclen: usize,
        pub_: *mut GNUNET_CRYPTO_EddsaPublicKey,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief Create a new private key by reading it from a file."]
    #[doc = ""]
    #[doc = " If the files does not exist and @a do_create is set, creates a new key and"]
    #[doc = " write it to the file."]
    #[doc = ""]
    #[doc = " If the contents of the file are invalid, an error is returned."]
    #[doc = ""]
    #[doc = " @param filename name of file to use to store the key"]
    #[doc = " @param do_create should a file be created?"]
    #[doc = " @param[out] pkey set to the private key from @a filename on success"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_NO if @a do_create was set but"]
    #[doc = "         we found an existing file, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_CRYPTO_ecdsa_key_from_file(
        filename: *const ::std::os::raw::c_char,
        do_create: ::std::os::raw::c_int,
        pkey: *mut GNUNET_CRYPTO_EcdsaPrivateKey,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief Create a new private key by reading it from a file."]
    #[doc = ""]
    #[doc = " If the files does not exist and @a do_create is set, creates a new key and"]
    #[doc = " write it to the file."]
    #[doc = ""]
    #[doc = " If the contents of the file are invalid, an error is returned."]
    #[doc = ""]
    #[doc = " @param filename name of file to use to store the key"]
    #[doc = " @param do_create should a file be created?"]
    #[doc = " @param[out] pkey set to the private key from @a filename on success"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_NO if @a do_create was set but"]
    #[doc = "         we found an existing file, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_CRYPTO_eddsa_key_from_file(
        filename: *const ::std::os::raw::c_char,
        do_create: ::std::os::raw::c_int,
        pkey: *mut GNUNET_CRYPTO_EddsaPrivateKey,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Forward declaration to simplify #include-structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONFIGURATION_Handle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Create a new private key by reading our peer's key from"]
    #[doc = " the file specified in the configuration."]
    #[doc = ""]
    #[doc = " @param cfg the configuration to use"]
    #[doc = " @return new private key, NULL on error (for example,"]
    #[doc = "   permission denied); free using #GNUNET_free"]
    pub fn GNUNET_CRYPTO_eddsa_key_create_from_configuration(
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ) -> *mut GNUNET_CRYPTO_EddsaPrivateKey;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Create a new private key."]
    #[doc = ""]
    #[doc = " @param[out] pk private key to initialize"]
    pub fn GNUNET_CRYPTO_ecdsa_key_create(pk: *mut GNUNET_CRYPTO_EcdsaPrivateKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Create a new private key."]
    #[doc = ""]
    #[doc = " @param[out] pk private key to initialize"]
    pub fn GNUNET_CRYPTO_eddsa_key_create(pk: *mut GNUNET_CRYPTO_EddsaPrivateKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Create a new private key.  Clear with #GNUNET_CRYPTO_ecdhe_key_clear()."]
    #[doc = ""]
    #[doc = " @param[out] pk set to fresh private key;"]
    pub fn GNUNET_CRYPTO_ecdhe_key_create(pk: *mut GNUNET_CRYPTO_EcdhePrivateKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Clear memory that was used to store a private key."]
    #[doc = ""]
    #[doc = " @param pk location of the key"]
    pub fn GNUNET_CRYPTO_eddsa_key_clear(pk: *mut GNUNET_CRYPTO_EddsaPrivateKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Clear memory that was used to store a private key."]
    #[doc = ""]
    #[doc = " @param pk location of the key"]
    pub fn GNUNET_CRYPTO_ecdsa_key_clear(pk: *mut GNUNET_CRYPTO_EcdsaPrivateKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Clear memory that was used to store a private key."]
    #[doc = ""]
    #[doc = " @param pk location of the key"]
    pub fn GNUNET_CRYPTO_ecdhe_key_clear(pk: *mut GNUNET_CRYPTO_EcdhePrivateKey);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Get the shared private key we use for anonymous users."]
    #[doc = ""]
    #[doc = " @return \"anonymous\" private key; do not free"]
    pub fn GNUNET_CRYPTO_ecdsa_key_get_anonymous() -> *const GNUNET_CRYPTO_EcdsaPrivateKey;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Setup a hostkey file for a peer given the name of the"]
    #[doc = " configuration file (!).  This function is used so that"]
    #[doc = " at a later point code can be certain that reading a"]
    #[doc = " hostkey is fast (for example in time-dependent testcases)."]
    #[doc = ""]
    #[doc = " @param cfg_name name of the configuration file to use"]
    pub fn GNUNET_CRYPTO_eddsa_setup_hostkey(cfg_name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Retrieve the identity of the host's peer."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param dst pointer to where to write the peer identity"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if the identity"]
    #[doc = "         could not be retrieved"]
    pub fn GNUNET_CRYPTO_get_peer_identity(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        dst: *mut GNUNET_PeerIdentity,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Internal structure used to cache pre-calculated values for DLOG calculation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EccDlogContext {
    _unused: [u8; 0],
}
#[doc = " Point on a curve (always for Curve25519) encoded in a format suitable"]
#[doc = " for network transmission (ECDH), see http://cr.yp.to/ecdh.html."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_EccPoint {
    #[doc = " Q consists of an x- and a y-value, each mod p (256 bits), given"]
    #[doc = " here in affine coordinates and Ed25519 standard compact format."]
    pub q_y: [::std::os::raw::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_EccPoint() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_EccPoint>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_EccPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_EccPoint>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_CRYPTO_EccPoint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_CRYPTO_EccPoint>())).q_y as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_EccPoint),
            "::",
            stringify!(q_y)
        )
    );
}
extern "C" {
    #[doc = " Do pre-calculation for ECC discrete logarithm for small factors."]
    #[doc = ""]
    #[doc = " @param max maximum value the factor can be"]
    #[doc = " @param mem memory to use (should be smaller than @a max), must not be zero."]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CRYPTO_ecc_dlog_prepare(
        max: ::std::os::raw::c_uint,
        mem: ::std::os::raw::c_uint,
    ) -> *mut GNUNET_CRYPTO_EccDlogContext;
}
extern "C" {
    #[doc = " Calculate ECC discrete logarithm for small factors."]
    #[doc = " Opposite of #GNUNET_CRYPTO_ecc_dexp()."]
    #[doc = ""]
    #[doc = " @param dlc precalculated values, determine range of factors"]
    #[doc = " @param input point on the curve to factor"]
    #[doc = " @return INT_MAX if dlog failed, otherwise the factor"]
    pub fn GNUNET_CRYPTO_ecc_dlog(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        input: gcry_mpi_point_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Multiply the generator g of the elliptic curve by @a val"]
    #[doc = " to obtain the point on the curve representing @a val."]
    #[doc = " Afterwards, point addition will correspond to integer"]
    #[doc = " addition.  #GNUNET_CRYPTO_ecc_dlog() can be used to"]
    #[doc = " convert a point back to an integer (as long as the"]
    #[doc = " integer is smaller than the MAX of the @a edc context)."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param val value to encode into a point"]
    #[doc = " @return representation of the value as an ECC point,"]
    #[doc = "         must be freed using #GNUNET_CRYPTO_ecc_free()"]
    pub fn GNUNET_CRYPTO_ecc_dexp(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        val: ::std::os::raw::c_int,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    #[doc = " Multiply the generator g of the elliptic curve by @a val"]
    #[doc = " to obtain the point on the curve representing @a val."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param val (positive) value to encode into a point"]
    #[doc = " @return representation of the value as an ECC point,"]
    #[doc = "         must be freed using #GNUNET_CRYPTO_ecc_free()"]
    pub fn GNUNET_CRYPTO_ecc_dexp_mpi(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        val: gcry_mpi_t,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    #[doc = " Multiply the point @a p on the elliptic curve by @a val."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param p point to multiply"]
    #[doc = " @param val (positive) value to encode into a point"]
    #[doc = " @return representation of the value as an ECC point,"]
    #[doc = "         must be freed using #GNUNET_CRYPTO_ecc_free()"]
    pub fn GNUNET_CRYPTO_ecc_pmul_mpi(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        p: gcry_mpi_point_t,
        val: gcry_mpi_t,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    #[doc = " Convert point value to binary representation."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param point computational point representation"]
    #[doc = " @param[out] bin binary point representation"]
    pub fn GNUNET_CRYPTO_ecc_point_to_bin(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        point: gcry_mpi_point_t,
        bin: *mut GNUNET_CRYPTO_EccPoint,
    );
}
extern "C" {
    #[doc = " Convert binary representation of a point to computational representation."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param bin binary point representation"]
    #[doc = " @return computational representation"]
    pub fn GNUNET_CRYPTO_ecc_bin_to_point(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        bin: *const GNUNET_CRYPTO_EccPoint,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    #[doc = " Add two points on the elliptic curve."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param a some value"]
    #[doc = " @param b some value"]
    #[doc = " @return @a a + @a b, must be freed using #GNUNET_CRYPTO_ecc_free()"]
    pub fn GNUNET_CRYPTO_ecc_add(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        a: gcry_mpi_point_t,
        b: gcry_mpi_point_t,
    ) -> gcry_mpi_point_t;
}
extern "C" {
    #[doc = " Obtain a random point on the curve and its"]
    #[doc = " additive inverse. Both returned values"]
    #[doc = " must be freed using #GNUNET_CRYPTO_ecc_free()."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param[out] r set to a random point on the curve"]
    #[doc = " @param[out] r_inv set to the additive inverse of @a r"]
    pub fn GNUNET_CRYPTO_ecc_rnd(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        r: *mut gcry_mpi_point_t,
        r_inv: *mut gcry_mpi_point_t,
    );
}
extern "C" {
    #[doc = " Obtain a random scalar for point multiplication on the curve and"]
    #[doc = " its multiplicative inverse."]
    #[doc = ""]
    #[doc = " @param edc calculation context for ECC operations"]
    #[doc = " @param[out] r set to a random scalar on the curve"]
    #[doc = " @param[out] r_inv set to the multiplicative inverse of @a r"]
    pub fn GNUNET_CRYPTO_ecc_rnd_mpi(
        edc: *mut GNUNET_CRYPTO_EccDlogContext,
        r: *mut gcry_mpi_t,
        r_inv: *mut gcry_mpi_t,
    );
}
extern "C" {
    #[doc = " Generate a random value mod n."]
    #[doc = ""]
    #[doc = " @param edc ECC context"]
    #[doc = " @return random value mod n."]
    pub fn GNUNET_CRYPTO_ecc_random_mod_n(edc: *mut GNUNET_CRYPTO_EccDlogContext) -> gcry_mpi_t;
}
extern "C" {
    #[doc = " Free a point value returned by the API."]
    #[doc = ""]
    #[doc = " @param p point to free"]
    pub fn GNUNET_CRYPTO_ecc_free(p: gcry_mpi_point_t);
}
extern "C" {
    #[doc = " Release precalculated values."]
    #[doc = ""]
    #[doc = " @param dlc dlog context"]
    pub fn GNUNET_CRYPTO_ecc_dlog_release(dlc: *mut GNUNET_CRYPTO_EccDlogContext);
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive key material from a public and a private ECC key."]
    #[doc = ""]
    #[doc = " @param priv private key to use for the ECDH (x)"]
    #[doc = " @param pub public key to use for the ECDH (yG)"]
    #[doc = " @param key_material where to write the key material (xyG)"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_ecc_ecdh(
        priv_: *const GNUNET_CRYPTO_EcdhePrivateKey,
        pub_: *const GNUNET_CRYPTO_EcdhePublicKey,
        key_material: *mut GNUNET_HashCode,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive key material from a ECDH public key and a private EdDSA key."]
    #[doc = " Dual to #GNUNET_CRRYPTO_ecdh_eddsa."]
    #[doc = ""]
    #[doc = " @param priv private key from EdDSA to use for the ECDH (x)"]
    #[doc = " @param pub public key to use for the ECDH (yG)"]
    #[doc = " @param key_material where to write the key material H(h(x)yG)"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_eddsa_ecdh(
        priv_: *const GNUNET_CRYPTO_EddsaPrivateKey,
        pub_: *const GNUNET_CRYPTO_EcdhePublicKey,
        key_material: *mut GNUNET_HashCode,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive key material from a ECDH public key and a private ECDSA key."]
    #[doc = " Dual to #GNUNET_CRRYPTO_ecdh_ecdsa."]
    #[doc = ""]
    #[doc = " @param priv private key from ECDSA to use for the ECDH (x)"]
    #[doc = " @param pub public key to use for the ECDH (yG)"]
    #[doc = " @param key_material where to write the key material H(h(x)yG)"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_ecdsa_ecdh(
        priv_: *const GNUNET_CRYPTO_EcdsaPrivateKey,
        pub_: *const GNUNET_CRYPTO_EcdhePublicKey,
        key_material: *mut GNUNET_HashCode,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive key material from a EdDSA public key and a private ECDH key."]
    #[doc = " Dual to #GNUNET_CRRYPTO_eddsa_ecdh."]
    #[doc = ""]
    #[doc = " @param priv private key to use for the ECDH (y)"]
    #[doc = " @param pub public key from EdDSA to use for the ECDH (X=h(x)G)"]
    #[doc = " @param key_material where to write the key material H(yX)=H(h(x)yG)"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_ecdh_eddsa(
        priv_: *const GNUNET_CRYPTO_EcdhePrivateKey,
        pub_: *const GNUNET_CRYPTO_EddsaPublicKey,
        key_material: *mut GNUNET_HashCode,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive key material from a EcDSA public key and a private ECDH key."]
    #[doc = " Dual to #GNUNET_CRRYPTO_ecdsa_ecdh."]
    #[doc = ""]
    #[doc = " @param priv private key to use for the ECDH (y)"]
    #[doc = " @param pub public key from ECDSA to use for the ECDH (X=h(x)G)"]
    #[doc = " @param key_material where to write the key material H(yX)=H(h(x)yG)"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_ecdh_ecdsa(
        priv_: *const GNUNET_CRYPTO_EcdhePrivateKey,
        pub_: *const GNUNET_CRYPTO_EcdsaPublicKey,
        key_material: *mut GNUNET_HashCode,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief EdDSA sign a given block."]
    #[doc = ""]
    #[doc = " The @a purpose data is the beginning of the data of which the signature is"]
    #[doc = " to be created. The `size` field in @a purpose must correctly indicate the"]
    #[doc = " number of bytes of the data structure, including its header.  If possible,"]
    #[doc = " use #GNUNET_CRYPTO_eddsa_sign() instead of this function (only if @a validate"]
    #[doc = " is not fixed-size, you must use this function directly)."]
    #[doc = ""]
    #[doc = " @param priv private key to use for the signing"]
    #[doc = " @param purpose what to sign (size, purpose)"]
    #[doc = " @param[out] sig where to write the signature"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_eddsa_sign_(
        priv_: *const GNUNET_CRYPTO_EddsaPrivateKey,
        purpose: *const GNUNET_CRYPTO_EccSignaturePurpose,
        sig: *mut GNUNET_CRYPTO_EddsaSignature,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief ECDSA Sign a given block."]
    #[doc = ""]
    #[doc = " The @a purpose data is the beginning of the data of which the signature is"]
    #[doc = " to be created. The `size` field in @a purpose must correctly indicate the"]
    #[doc = " number of bytes of the data structure, including its header. If possible,"]
    #[doc = " use #GNUNET_CRYPTO_ecdsa_sign() instead of this function (only if @a validate"]
    #[doc = " is not fixed-size, you must use this function directly)."]
    #[doc = ""]
    #[doc = " @param priv private key to use for the signing"]
    #[doc = " @param purpose what to sign (size, purpose)"]
    #[doc = " @param[out] sig where to write the signature"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_CRYPTO_ecdsa_sign_(
        priv_: *const GNUNET_CRYPTO_EcdsaPrivateKey,
        purpose: *const GNUNET_CRYPTO_EccSignaturePurpose,
        sig: *mut GNUNET_CRYPTO_EcdsaSignature,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief Verify EdDSA signature."]
    #[doc = ""]
    #[doc = " The @a validate data is the beginning of the data of which the signature"]
    #[doc = " is to be verified. The `size` field in @a validate must correctly indicate"]
    #[doc = " the number of bytes of the data structure, including its header.  If @a"]
    #[doc = " purpose does not match the purpose given in @a validate (the latter must be"]
    #[doc = " in big endian), signature verification fails.  If possible,"]
    #[doc = " use #GNUNET_CRYPTO_eddsa_verify() instead of this function (only if @a validate"]
    #[doc = " is not fixed-size, you must use this function directly)."]
    #[doc = ""]
    #[doc = " @param purpose what is the purpose that the signature should have?"]
    #[doc = " @param validate block to validate (size, purpose, data)"]
    #[doc = " @param sig signature that is being validated"]
    #[doc = " @param pub public key of the signer"]
    #[doc = " @returns #GNUNET_OK if ok, #GNUNET_SYSERR if invalid"]
    pub fn GNUNET_CRYPTO_eddsa_verify_(
        purpose: u32,
        validate: *const GNUNET_CRYPTO_EccSignaturePurpose,
        sig: *const GNUNET_CRYPTO_EddsaSignature,
        pub_: *const GNUNET_CRYPTO_EddsaPublicKey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " @brief Verify ECDSA signature."]
    #[doc = ""]
    #[doc = " The @a validate data is the beginning of the data of which the signature is"]
    #[doc = " to be verified. The `size` field in @a validate must correctly indicate the"]
    #[doc = " number of bytes of the data structure, including its header.  If @a purpose"]
    #[doc = " does not match the purpose given in @a validate (the latter must be in big"]
    #[doc = " endian), signature verification fails.  If possible, use"]
    #[doc = " #GNUNET_CRYPTO_eddsa_verify() instead of this function (only if @a validate"]
    #[doc = " is not fixed-size, you must use this function directly)."]
    #[doc = ""]
    #[doc = " @param purpose what is the purpose that the signature should have?"]
    #[doc = " @param validate block to validate (size, purpose, data)"]
    #[doc = " @param sig signature that is being validated"]
    #[doc = " @param pub public key of the signer"]
    #[doc = " @returns #GNUNET_OK if ok, #GNUNET_SYSERR if invalid"]
    pub fn GNUNET_CRYPTO_ecdsa_verify_(
        purpose: u32,
        validate: *const GNUNET_CRYPTO_EccSignaturePurpose,
        sig: *const GNUNET_CRYPTO_EcdsaSignature,
        pub_: *const GNUNET_CRYPTO_EcdsaPublicKey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive a private key from a given private key and a label."]
    #[doc = " Essentially calculates a private key 'h = H(l,P) * d mod n'"]
    #[doc = " where n is the size of the ECC group and P is the public"]
    #[doc = " key associated with the private key 'd'."]
    #[doc = ""]
    #[doc = " @param priv original private key"]
    #[doc = " @param label label to use for key deriviation"]
    #[doc = " @param context additional context to use for HKDF of 'h';"]
    #[doc = "        typically the name of the subsystem/application"]
    #[doc = " @return derived private key"]
    pub fn GNUNET_CRYPTO_ecdsa_private_key_derive(
        priv_: *const GNUNET_CRYPTO_EcdsaPrivateKey,
        label: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
    ) -> *mut GNUNET_CRYPTO_EcdsaPrivateKey;
}
extern "C" {
    #[doc = " @ingroup crypto"]
    #[doc = " Derive a public key from a given public key and a label."]
    #[doc = " Essentially calculates a public key 'V = H(l,P) * P'."]
    #[doc = ""]
    #[doc = " @param pub original public key"]
    #[doc = " @param label label to use for key deriviation"]
    #[doc = " @param context additional context to use for HKDF of 'h'."]
    #[doc = "        typically the name of the subsystem/application"]
    #[doc = " @param result where to write the derived public key"]
    pub fn GNUNET_CRYPTO_ecdsa_public_key_derive(
        pub_: *const GNUNET_CRYPTO_EcdsaPublicKey,
        label: *const ::std::os::raw::c_char,
        context: *const ::std::os::raw::c_char,
        result: *mut GNUNET_CRYPTO_EcdsaPublicKey,
    );
}
extern "C" {
    #[doc = " Output the given MPI value to the given buffer in network"]
    #[doc = " byte order.  The MPI @a val may not be negative."]
    #[doc = ""]
    #[doc = " @param buf where to output to"]
    #[doc = " @param size number of bytes in @a buf"]
    #[doc = " @param val value to write to @a buf"]
    pub fn GNUNET_CRYPTO_mpi_print_unsigned(
        buf: *mut ::std::os::raw::c_void,
        size: usize,
        val: gcry_mpi_t,
    );
}
extern "C" {
    #[doc = " Convert data buffer into MPI value."]
    #[doc = " The buffer is interpreted as network"]
    #[doc = " byte order, unsigned integer."]
    #[doc = ""]
    #[doc = " @param result where to store MPI value (allocated)"]
    #[doc = " @param data raw data (GCRYMPI_FMT_USG)"]
    #[doc = " @param size number of bytes in @a data"]
    pub fn GNUNET_CRYPTO_mpi_scan_unsigned(
        result: *mut gcry_mpi_t,
        data: *const ::std::os::raw::c_void,
        size: usize,
    );
}
extern "C" {
    #[doc = " Create a freshly generated paillier public key."]
    #[doc = ""]
    #[doc = " @param[out] public_key Where to store the public key?"]
    #[doc = " @param[out] private_key Where to store the private key?"]
    pub fn GNUNET_CRYPTO_paillier_create(
        public_key: *mut GNUNET_CRYPTO_PaillierPublicKey,
        private_key: *mut GNUNET_CRYPTO_PaillierPrivateKey,
    );
}
extern "C" {
    #[doc = " Encrypt a plaintext with a paillier public key."]
    #[doc = ""]
    #[doc = " @param public_key Public key to use."]
    #[doc = " @param m Plaintext to encrypt."]
    #[doc = " @param desired_ops How many homomorphic ops the caller intends to use"]
    #[doc = " @param[out] ciphertext Encryption of @a plaintext with @a public_key."]
    #[doc = " @return guaranteed number of supported homomorphic operations >= 1,"]
    #[doc = "         or desired_ops, in case that is lower,"]
    #[doc = "         or -1 if less than one homomorphic operation is possible"]
    pub fn GNUNET_CRYPTO_paillier_encrypt(
        public_key: *const GNUNET_CRYPTO_PaillierPublicKey,
        m: gcry_mpi_t,
        desired_ops: ::std::os::raw::c_int,
        ciphertext: *mut GNUNET_CRYPTO_PaillierCiphertext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decrypt a paillier ciphertext with a private key."]
    #[doc = ""]
    #[doc = " @param private_key Private key to use for decryption."]
    #[doc = " @param public_key Public key to use for decryption."]
    #[doc = " @param ciphertext Ciphertext to decrypt."]
    #[doc = " @param[out] m Decryption of @a ciphertext with @private_key."]
    pub fn GNUNET_CRYPTO_paillier_decrypt(
        private_key: *const GNUNET_CRYPTO_PaillierPrivateKey,
        public_key: *const GNUNET_CRYPTO_PaillierPublicKey,
        ciphertext: *const GNUNET_CRYPTO_PaillierCiphertext,
        m: gcry_mpi_t,
    );
}
extern "C" {
    #[doc = " Compute a ciphertext that represents the sum of the plaintext in @a x1 and @a x2"]
    #[doc = ""]
    #[doc = " Note that this operation can only be done a finite number of times"]
    #[doc = " before an overflow occurs."]
    #[doc = ""]
    #[doc = " @param public_key Public key to use for encryption."]
    #[doc = " @param c1 Paillier cipher text."]
    #[doc = " @param c2 Paillier cipher text."]
    #[doc = " @param[out] result Result of the homomorphic operation."]
    #[doc = " @return #GNUNET_OK if the result could be computed,"]
    #[doc = "         #GNUNET_SYSERR if no more homomorphic operations are remaining."]
    pub fn GNUNET_CRYPTO_paillier_hom_add(
        public_key: *const GNUNET_CRYPTO_PaillierPublicKey,
        c1: *const GNUNET_CRYPTO_PaillierCiphertext,
        c2: *const GNUNET_CRYPTO_PaillierCiphertext,
        result: *mut GNUNET_CRYPTO_PaillierCiphertext,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of remaining supported homomorphic operations."]
    #[doc = ""]
    #[doc = " @param c Paillier cipher text."]
    #[doc = " @return the number of remaining homomorphic operations"]
    pub fn GNUNET_CRYPTO_paillier_hom_get_remaining(
        c: *const GNUNET_CRYPTO_PaillierCiphertext,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The private information of an RSA key pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_RsaPrivateKey {
    _unused: [u8; 0],
}
#[doc = " The public information of an RSA key pair."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_RsaPublicKey {
    _unused: [u8; 0],
}
#[doc = " Constant-size pre-secret for blinding key generation."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_RsaBlindingKeySecret {
    #[doc = " Bits used to generate the blinding key.  256 bits"]
    #[doc = " of entropy is enough."]
    pub pre_secret: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_GNUNET_CRYPTO_RsaBlindingKeySecret() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_CRYPTO_RsaBlindingKeySecret>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_CRYPTO_RsaBlindingKeySecret))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_CRYPTO_RsaBlindingKeySecret>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_CRYPTO_RsaBlindingKeySecret)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_CRYPTO_RsaBlindingKeySecret>())).pre_secret as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_CRYPTO_RsaBlindingKeySecret),
            "::",
            stringify!(pre_secret)
        )
    );
}
#[doc = " @brief an RSA signature"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CRYPTO_RsaSignature {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new private key. Caller must free return value."]
    #[doc = ""]
    #[doc = " @param len length of the key in bits (i.e. 2048)"]
    #[doc = " @return fresh private key"]
    pub fn GNUNET_CRYPTO_rsa_private_key_create(
        len: ::std::os::raw::c_uint,
    ) -> *mut GNUNET_CRYPTO_RsaPrivateKey;
}
extern "C" {
    #[doc = " Free memory occupied by the private key."]
    #[doc = ""]
    #[doc = " @param key pointer to the memory to free"]
    pub fn GNUNET_CRYPTO_rsa_private_key_free(key: *mut GNUNET_CRYPTO_RsaPrivateKey);
}
extern "C" {
    #[doc = " Encode the private key in a format suitable for"]
    #[doc = " storing it into a file."]
    #[doc = ""]
    #[doc = " @param key the private key"]
    #[doc = " @param[out] buffer set to a buffer with the encoded key"]
    #[doc = " @return size of memory allocatedin @a buffer"]
    pub fn GNUNET_CRYPTO_rsa_private_key_encode(
        key: *const GNUNET_CRYPTO_RsaPrivateKey,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " Decode the private key from the data-format back"]
    #[doc = " to the \"normal\", internal format."]
    #[doc = ""]
    #[doc = " @param buf the buffer where the private key data is stored"]
    #[doc = " @param buf_size the size of the data in @a buf"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CRYPTO_rsa_private_key_decode(
        buf: *const ::std::os::raw::c_void,
        buf_size: usize,
    ) -> *mut GNUNET_CRYPTO_RsaPrivateKey;
}
extern "C" {
    #[doc = " Duplicate the given private key"]
    #[doc = ""]
    #[doc = " @param key the private key to duplicate"]
    #[doc = " @return the duplicate key; NULL upon error"]
    pub fn GNUNET_CRYPTO_rsa_private_key_dup(
        key: *const GNUNET_CRYPTO_RsaPrivateKey,
    ) -> *mut GNUNET_CRYPTO_RsaPrivateKey;
}
extern "C" {
    #[doc = " Extract the public key of the given private key."]
    #[doc = ""]
    #[doc = " @param priv the private key"]
    #[doc = " @return NULL on error, otherwise the public key"]
    pub fn GNUNET_CRYPTO_rsa_private_key_get_public(
        priv_: *const GNUNET_CRYPTO_RsaPrivateKey,
    ) -> *mut GNUNET_CRYPTO_RsaPublicKey;
}
extern "C" {
    #[doc = " Compute hash over the public key."]
    #[doc = ""]
    #[doc = " @param key public key to hash"]
    #[doc = " @param hc where to store the hash code"]
    pub fn GNUNET_CRYPTO_rsa_public_key_hash(
        key: *const GNUNET_CRYPTO_RsaPublicKey,
        hc: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " Obtain the length of the RSA key in bits."]
    #[doc = ""]
    #[doc = " @param key the public key to introspect"]
    #[doc = " @return length of the key in bits"]
    pub fn GNUNET_CRYPTO_rsa_public_key_len(
        key: *const GNUNET_CRYPTO_RsaPublicKey,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Free memory occupied by the public key."]
    #[doc = ""]
    #[doc = " @param key pointer to the memory to free"]
    pub fn GNUNET_CRYPTO_rsa_public_key_free(key: *mut GNUNET_CRYPTO_RsaPublicKey);
}
extern "C" {
    #[doc = " Encode the public key in a format suitable for"]
    #[doc = " storing it into a file."]
    #[doc = ""]
    #[doc = " @param key the private key"]
    #[doc = " @param[out] buffer set to a buffer with the encoded key"]
    #[doc = " @return size of memory allocated in @a buffer"]
    pub fn GNUNET_CRYPTO_rsa_public_key_encode(
        key: *const GNUNET_CRYPTO_RsaPublicKey,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " Decode the public key from the data-format back"]
    #[doc = " to the \"normal\", internal format."]
    #[doc = ""]
    #[doc = " @param buf the buffer where the public key data is stored"]
    #[doc = " @param len the length of the data in @a buf"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CRYPTO_rsa_public_key_decode(
        buf: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *mut GNUNET_CRYPTO_RsaPublicKey;
}
extern "C" {
    #[doc = " Duplicate the given public key"]
    #[doc = ""]
    #[doc = " @param key the public key to duplicate"]
    #[doc = " @return the duplicate key; NULL upon error"]
    pub fn GNUNET_CRYPTO_rsa_public_key_dup(
        key: *const GNUNET_CRYPTO_RsaPublicKey,
    ) -> *mut GNUNET_CRYPTO_RsaPublicKey;
}
extern "C" {
    #[doc = " Compare the values of two signatures."]
    #[doc = ""]
    #[doc = " @param s1 one signature"]
    #[doc = " @param s2 the other signature"]
    #[doc = " @return 0 if the two are equal"]
    pub fn GNUNET_CRYPTO_rsa_signature_cmp(
        s1: *const GNUNET_CRYPTO_RsaSignature,
        s2: *const GNUNET_CRYPTO_RsaSignature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the values of two private keys."]
    #[doc = ""]
    #[doc = " @param p1 one private key"]
    #[doc = " @param p2 the other private key"]
    #[doc = " @return 0 if the two are equal"]
    pub fn GNUNET_CRYPTO_rsa_private_key_cmp(
        p1: *const GNUNET_CRYPTO_RsaPrivateKey,
        p2: *const GNUNET_CRYPTO_RsaPrivateKey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare the values of two public keys."]
    #[doc = ""]
    #[doc = " @param p1 one public key"]
    #[doc = " @param p2 the other public key"]
    #[doc = " @return 0 if the two are equal"]
    pub fn GNUNET_CRYPTO_rsa_public_key_cmp(
        p1: *const GNUNET_CRYPTO_RsaPublicKey,
        p2: *const GNUNET_CRYPTO_RsaPublicKey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Blinds the given message with the given blinding key"]
    #[doc = ""]
    #[doc = " @param hash hash of the message to sign"]
    #[doc = " @param bkey the blinding key"]
    #[doc = " @param pkey the public key of the signer"]
    #[doc = " @param[out] buf set to a buffer with the blinded message to be signed"]
    #[doc = " @param[out] buf_size number of bytes stored in @a buf"]
    #[doc = " @return #GNUNET_YES if successful, #GNUNET_NO if RSA key is malicious"]
    pub fn GNUNET_CRYPTO_rsa_blind(
        hash: *const GNUNET_HashCode,
        bks: *const GNUNET_CRYPTO_RsaBlindingKeySecret,
        pkey: *mut GNUNET_CRYPTO_RsaPublicKey,
        buf: *mut *mut ::std::os::raw::c_void,
        buf_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sign a blinded value, which must be a full domain hash of a message."]
    #[doc = ""]
    #[doc = " @param key private key to use for the signing"]
    #[doc = " @param msg the (blinded) message to sign"]
    #[doc = " @param msg_len number of bytes in @a msg to sign"]
    #[doc = " @return NULL on error, signature on success"]
    pub fn GNUNET_CRYPTO_rsa_sign_blinded(
        key: *const GNUNET_CRYPTO_RsaPrivateKey,
        msg: *const ::std::os::raw::c_void,
        msg_len: usize,
    ) -> *mut GNUNET_CRYPTO_RsaSignature;
}
extern "C" {
    #[doc = " Create and sign a full domain hash of a message."]
    #[doc = ""]
    #[doc = " @param key private key to use for the signing"]
    #[doc = " @param hash the hash of the message to sign"]
    #[doc = " @return NULL on error, including a malicious RSA key, signature on success"]
    pub fn GNUNET_CRYPTO_rsa_sign_fdh(
        key: *const GNUNET_CRYPTO_RsaPrivateKey,
        hash: *const GNUNET_HashCode,
    ) -> *mut GNUNET_CRYPTO_RsaSignature;
}
extern "C" {
    #[doc = " Free memory occupied by signature."]
    #[doc = ""]
    #[doc = " @param sig memory to free"]
    pub fn GNUNET_CRYPTO_rsa_signature_free(sig: *mut GNUNET_CRYPTO_RsaSignature);
}
extern "C" {
    #[doc = " Encode the given signature in a format suitable for storing it into a file."]
    #[doc = ""]
    #[doc = " @param sig the signature"]
    #[doc = " @param[out] buffer set to a buffer with the encoded key"]
    #[doc = " @return size of memory allocated in @a buffer"]
    pub fn GNUNET_CRYPTO_rsa_signature_encode(
        sig: *const GNUNET_CRYPTO_RsaSignature,
        buffer: *mut *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " Decode the signature from the data-format back to the \"normal\", internal"]
    #[doc = " format."]
    #[doc = ""]
    #[doc = " @param buf the buffer where the public key data is stored"]
    #[doc = " @param buf_size the number of bytes of the data in @a buf"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CRYPTO_rsa_signature_decode(
        buf: *const ::std::os::raw::c_void,
        buf_size: usize,
    ) -> *mut GNUNET_CRYPTO_RsaSignature;
}
extern "C" {
    #[doc = " Duplicate the given rsa signature"]
    #[doc = ""]
    #[doc = " @param sig the signature to duplicate"]
    #[doc = " @return the duplicate key; NULL upon error"]
    pub fn GNUNET_CRYPTO_rsa_signature_dup(
        sig: *const GNUNET_CRYPTO_RsaSignature,
    ) -> *mut GNUNET_CRYPTO_RsaSignature;
}
extern "C" {
    #[doc = " Unblind a blind-signed signature.  The signature should have been generated"]
    #[doc = " with #GNUNET_CRYPTO_rsa_sign() using a hash that was blinded with"]
    #[doc = " #GNUNET_CRYPTO_rsa_blind()."]
    #[doc = ""]
    #[doc = " @param sig the signature made on the blinded signature purpose"]
    #[doc = " @param bks the blinding key secret used to blind the signature purpose"]
    #[doc = " @param pkey the public key of the signer"]
    #[doc = " @return unblinded signature on success, NULL if RSA key is bad or malicious."]
    pub fn GNUNET_CRYPTO_rsa_unblind(
        sig: *const GNUNET_CRYPTO_RsaSignature,
        bks: *const GNUNET_CRYPTO_RsaBlindingKeySecret,
        pkey: *mut GNUNET_CRYPTO_RsaPublicKey,
    ) -> *mut GNUNET_CRYPTO_RsaSignature;
}
extern "C" {
    #[doc = " Verify whether the given hash corresponds to the given signature and the"]
    #[doc = " signature is valid with respect to the given public key."]
    #[doc = ""]
    #[doc = " @param hash the message to verify to match the @a sig"]
    #[doc = " @param sig signature that is being validated"]
    #[doc = " @param public_key public key of the signer"]
    #[doc = " @returns #GNUNET_YES if ok, #GNUNET_NO if RSA key is malicious, #GNUNET_SYSERR if signature"]
    pub fn GNUNET_CRYPTO_rsa_verify(
        hash: *const GNUNET_HashCode,
        sig: *const GNUNET_CRYPTO_RsaSignature,
        public_key: *const GNUNET_CRYPTO_RsaPublicKey,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Time for absolute times used by GNUnet, in microseconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TIME_Absolute {
    #[doc = " The actual value."]
    pub abs_value_us: u64,
}
#[test]
fn bindgen_test_layout_GNUNET_TIME_Absolute() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TIME_Absolute>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_TIME_Absolute))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TIME_Absolute>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_TIME_Absolute))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TIME_Absolute>())).abs_value_us as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TIME_Absolute),
            "::",
            stringify!(abs_value_us)
        )
    );
}
#[doc = " Time for relative time used by GNUnet, in microseconds."]
#[doc = " Always positive, so we can only refer to future time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TIME_Relative {
    #[doc = " The actual value."]
    pub rel_value_us: u64,
}
#[test]
fn bindgen_test_layout_GNUNET_TIME_Relative() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TIME_Relative>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_TIME_Relative))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TIME_Relative>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_TIME_Relative))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TIME_Relative>())).rel_value_us as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TIME_Relative),
            "::",
            stringify!(rel_value_us)
        )
    );
}
#[doc = " Time for relative time used by GNUnet, in microseconds and in network byte order."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TIME_RelativeNBO {
    #[doc = " The actual value (in network byte order)."]
    pub rel_value_us__: u64,
}
#[test]
fn bindgen_test_layout_GNUNET_TIME_RelativeNBO() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TIME_RelativeNBO>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_TIME_RelativeNBO))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TIME_RelativeNBO>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TIME_RelativeNBO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TIME_RelativeNBO>())).rel_value_us__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TIME_RelativeNBO),
            "::",
            stringify!(rel_value_us__)
        )
    );
}
#[doc = " Time for absolute time used by GNUnet, in microseconds and in network byte order."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TIME_AbsoluteNBO {
    #[doc = " The actual value (in network byte order)."]
    pub abs_value_us__: u64,
}
#[test]
fn bindgen_test_layout_GNUNET_TIME_AbsoluteNBO() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TIME_AbsoluteNBO>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_TIME_AbsoluteNBO))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TIME_AbsoluteNBO>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TIME_AbsoluteNBO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TIME_AbsoluteNBO>())).abs_value_us__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TIME_AbsoluteNBO),
            "::",
            stringify!(abs_value_us__)
        )
    );
}
extern "C" {
    #[doc = " Randomized exponential back-off, starting at 1 ms"]
    #[doc = " and going up by a factor of 2+r, where 0 <= r <= 0.5, up"]
    #[doc = " to a maximum of the given threshold."]
    #[doc = ""]
    #[doc = " @param rt current backoff time, initially zero"]
    #[doc = " @param threshold maximum value for backoff"]
    #[doc = " @return the next backoff time"]
    pub fn GNUNET_TIME_randomized_backoff(
        rt: GNUNET_TIME_Relative,
        threshold: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return a random time value between 0.5*r and 1.5*r."]
    #[doc = ""]
    #[doc = " @param r input time for scaling"]
    #[doc = " @return randomized time"]
    pub fn GNUNET_TIME_randomize(r: GNUNET_TIME_Relative) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return relative time of 0ms."]
    pub fn GNUNET_TIME_relative_get_zero_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return absolute time of 0ms."]
    pub fn GNUNET_TIME_absolute_get_zero_() -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Return relative time of 1 microsecond."]
    pub fn GNUNET_TIME_relative_get_unit_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return relative time of 1ms."]
    pub fn GNUNET_TIME_relative_get_millisecond_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return relative time of 1s."]
    pub fn GNUNET_TIME_relative_get_second_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return relative time of 1 minute."]
    pub fn GNUNET_TIME_relative_get_minute_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return relative time of 1 hour."]
    pub fn GNUNET_TIME_relative_get_hour_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return \"forever\"."]
    pub fn GNUNET_TIME_relative_get_forever_() -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return \"forever\"."]
    pub fn GNUNET_TIME_absolute_get_forever_() -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Get the current time."]
    #[doc = ""]
    #[doc = " @return the current time"]
    pub fn GNUNET_TIME_absolute_get() -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Convert relative time to an absolute time in the"]
    #[doc = " future."]
    #[doc = ""]
    #[doc = " @param rel relative time to convert"]
    #[doc = " @return timestamp that is \"rel\" in the future, or FOREVER if rel==FOREVER (or if we would overflow)"]
    pub fn GNUNET_TIME_relative_to_absolute(rel: GNUNET_TIME_Relative) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Round a time value so that it is suitable for transmission"]
    #[doc = " via JSON encodings."]
    #[doc = ""]
    #[doc = " @param at time to round"]
    #[doc = " @return #GNUNET_OK if time was already rounded, #GNUNET_NO if"]
    #[doc = "         it was just now rounded"]
    pub fn GNUNET_TIME_round_abs(at: *mut GNUNET_TIME_Absolute) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Round a time value so that it is suitable for transmission"]
    #[doc = " via JSON encodings."]
    #[doc = ""]
    #[doc = " @param rt time to round"]
    #[doc = " @return #GNUNET_OK if time was already rounded, #GNUNET_NO if"]
    #[doc = "         it was just now rounded"]
    pub fn GNUNET_TIME_round_rel(rt: *mut GNUNET_TIME_Relative) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the minimum of two relative time values."]
    #[doc = ""]
    #[doc = " @param t1 first timestamp"]
    #[doc = " @param t2 other timestamp"]
    #[doc = " @return timestamp that is smaller"]
    pub fn GNUNET_TIME_relative_min(
        t1: GNUNET_TIME_Relative,
        t2: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return the maximum of two relative time values."]
    #[doc = ""]
    #[doc = " @param t1 first timestamp"]
    #[doc = " @param t2 other timestamp"]
    #[doc = " @return timestamp that is larger"]
    pub fn GNUNET_TIME_relative_max(
        t1: GNUNET_TIME_Relative,
        t2: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Return the minimum of two absolute time values."]
    #[doc = ""]
    #[doc = " @param t1 first timestamp"]
    #[doc = " @param t2 other timestamp"]
    #[doc = " @return timestamp that is smaller"]
    pub fn GNUNET_TIME_absolute_min(
        t1: GNUNET_TIME_Absolute,
        t2: GNUNET_TIME_Absolute,
    ) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Return the maximum of two absolute time values."]
    #[doc = ""]
    #[doc = " @param t1 first timestamp"]
    #[doc = " @param t2 other timestamp"]
    #[doc = " @return timestamp that is smaller"]
    pub fn GNUNET_TIME_absolute_max(
        t1: GNUNET_TIME_Absolute,
        t2: GNUNET_TIME_Absolute,
    ) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Given a timestamp in the future, how much time"]
    #[doc = " remains until then?"]
    #[doc = ""]
    #[doc = " @param future some absolute time, typically in the future"]
    #[doc = " @return future - now, or 0 if now >= future, or FOREVER if future==FOREVER."]
    pub fn GNUNET_TIME_absolute_get_remaining(future: GNUNET_TIME_Absolute)
        -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Calculate the estimate time of arrival/completion"]
    #[doc = " for an operation."]
    #[doc = ""]
    #[doc = " @param start when did the operation start?"]
    #[doc = " @param finished how much has been done?"]
    #[doc = " @param total how much must be done overall (same unit as for \"finished\")"]
    #[doc = " @return remaining duration for the operation,"]
    #[doc = "        assuming it continues at the same speed"]
    pub fn GNUNET_TIME_calculate_eta(
        start: GNUNET_TIME_Absolute,
        finished: u64,
        total: u64,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Compute the time difference between the given start and end times."]
    #[doc = " Use this function instead of actual subtraction to ensure that"]
    #[doc = " \"FOREVER\" and overflows are handled correctly."]
    #[doc = ""]
    #[doc = " @param start some absolute time"]
    #[doc = " @param end some absolute time (typically larger or equal to start)"]
    #[doc = " @return 0 if start >= end; FOREVER if end==FOREVER; otherwise end - start"]
    pub fn GNUNET_TIME_absolute_get_difference(
        start: GNUNET_TIME_Absolute,
        end: GNUNET_TIME_Absolute,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Get the duration of an operation as the"]
    #[doc = " difference of the current time and the given start time \"hence\"."]
    #[doc = ""]
    #[doc = " @param whence some absolute time, typically in the past"]
    #[doc = " @return 0 if hence > now, otherwise now-hence."]
    pub fn GNUNET_TIME_absolute_get_duration(whence: GNUNET_TIME_Absolute) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Add a given relative duration to the"]
    #[doc = " given start time."]
    #[doc = ""]
    #[doc = " @param start some absolute time"]
    #[doc = " @param duration some relative time to add"]
    #[doc = " @return FOREVER if either argument is FOREVER or on overflow; start+duration otherwise"]
    pub fn GNUNET_TIME_absolute_add(
        start: GNUNET_TIME_Absolute,
        duration: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Subtract a given relative duration from the"]
    #[doc = " given start time."]
    #[doc = ""]
    #[doc = " @param start some absolute time"]
    #[doc = " @param duration some relative time to subtract"]
    #[doc = " @return ZERO if start <= duration, or FOREVER if start time is FOREVER; start-duration otherwise"]
    pub fn GNUNET_TIME_absolute_subtract(
        start: GNUNET_TIME_Absolute,
        duration: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Multiply relative time by a given factor."]
    #[doc = ""]
    #[doc = " @param rel some duration"]
    #[doc = " @param factor integer to multiply with"]
    #[doc = " @return FOREVER if rel=FOREVER or on overflow; otherwise rel*factor"]
    pub fn GNUNET_TIME_relative_multiply(
        rel: GNUNET_TIME_Relative,
        factor: ::std::os::raw::c_ulonglong,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Saturating multiply relative time by a given factor."]
    #[doc = ""]
    #[doc = " @param rel some duration"]
    #[doc = " @param factor integer to multiply with"]
    #[doc = " @return FOREVER if rel=FOREVER or on overflow; otherwise rel*factor"]
    pub fn GNUNET_TIME_relative_saturating_multiply(
        rel: GNUNET_TIME_Relative,
        factor: ::std::os::raw::c_ulonglong,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Divide relative time by a given factor."]
    #[doc = ""]
    #[doc = " @param rel some duration"]
    #[doc = " @param factor integer to divide by"]
    #[doc = " @return FOREVER if rel=FOREVER or factor==0; otherwise rel/factor"]
    pub fn GNUNET_TIME_relative_divide(
        rel: GNUNET_TIME_Relative,
        factor: ::std::os::raw::c_ulonglong,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Add relative times together."]
    #[doc = ""]
    #[doc = " @param a1 some relative time"]
    #[doc = " @param a2 some other relative time"]
    #[doc = " @return FOREVER if either argument is FOREVER or on overflow; a1+a2 otherwise"]
    pub fn GNUNET_TIME_relative_add(
        a1: GNUNET_TIME_Relative,
        a2: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Subtract relative timestamp from the other."]
    #[doc = ""]
    #[doc = " @param a1 first timestamp"]
    #[doc = " @param a2 second timestamp"]
    #[doc = " @return ZERO if a2>=a1 (including both FOREVER), FOREVER if a1 is FOREVER, a1-a2 otherwise"]
    pub fn GNUNET_TIME_relative_subtract(
        a1: GNUNET_TIME_Relative,
        a2: GNUNET_TIME_Relative,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Convert relative time to network byte order."]
    #[doc = ""]
    #[doc = " @param a time to convert"]
    #[doc = " @return converted time value"]
    pub fn GNUNET_TIME_relative_hton(a: GNUNET_TIME_Relative) -> GNUNET_TIME_RelativeNBO;
}
extern "C" {
    #[doc = " Convert relative time from network byte order."]
    #[doc = ""]
    #[doc = " @param a time to convert"]
    #[doc = " @return converted time value"]
    pub fn GNUNET_TIME_relative_ntoh(a: GNUNET_TIME_RelativeNBO) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Convert absolute time to network byte order."]
    #[doc = ""]
    #[doc = " @param a time to convert"]
    #[doc = " @return converted time value"]
    pub fn GNUNET_TIME_absolute_hton(a: GNUNET_TIME_Absolute) -> GNUNET_TIME_AbsoluteNBO;
}
extern "C" {
    #[doc = " Convert absolute time from network byte order."]
    #[doc = ""]
    #[doc = " @param a time to convert"]
    #[doc = " @return converted time value"]
    pub fn GNUNET_TIME_absolute_ntoh(a: GNUNET_TIME_AbsoluteNBO) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Set the timestamp offset for this instance."]
    #[doc = ""]
    #[doc = " @param offset the offset to skew the locale time by"]
    pub fn GNUNET_TIME_set_offset(offset: ::std::os::raw::c_longlong);
}
extern "C" {
    #[doc = " Get the timestamp offset for this instance."]
    #[doc = ""]
    #[doc = " @return the offset we currently skew the locale time by"]
    pub fn GNUNET_TIME_get_offset() -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Return the current year (i.e. '2011')."]
    pub fn GNUNET_TIME_get_current_year() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Convert a year to an expiration time of January 1st of that year."]
    #[doc = ""]
    #[doc = " @param year a year (after 1970, please ;-))."]
    #[doc = " @return absolute time for January 1st of that year."]
    pub fn GNUNET_TIME_year_to_time(year: ::std::os::raw::c_uint) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Convert an expiration time to the respective year (rounds)"]
    #[doc = ""]
    #[doc = " @param at absolute time"]
    #[doc = " @return year a year (after 1970), 0 on error"]
    pub fn GNUNET_TIME_time_to_year(at: GNUNET_TIME_Absolute) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Obtain the current time and make sure it is monotonically"]
    #[doc = " increasing.  Guards against systems without an RTC or"]
    #[doc = " clocks running backwards and other nasty surprises. Does"]
    #[doc = " not guarantee that the returned time is near the current"]
    #[doc = " time returned by #GNUNET_TIME_absolute_get().  Two"]
    #[doc = " subsequent calls (within a short time period) may return the"]
    #[doc = " same value. Persists the last returned time on disk to"]
    #[doc = " ensure that time never goes backwards. As a result, the"]
    #[doc = " resulting value can be used to check if a message is the"]
    #[doc = " \"most recent\" value and replays of older messages (from"]
    #[doc = " the same origin) would be discarded."]
    #[doc = ""]
    #[doc = " @param cfg configuration, used to determine where to"]
    #[doc = "   store the time; user can also insist RTC is working"]
    #[doc = "   nicely and disable the feature"]
    #[doc = " @return monotonically increasing time"]
    pub fn GNUNET_TIME_absolute_get_monotonic(
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ) -> GNUNET_TIME_Absolute;
}
#[doc = " 32-bit bandwidth used for network exchange by GNUnet, in bytes per second."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_BANDWIDTH_Value32NBO {
    #[doc = " The actual value (bytes per second)."]
    pub value__: u32,
}
#[test]
fn bindgen_test_layout_GNUNET_BANDWIDTH_Value32NBO() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_BANDWIDTH_Value32NBO>(),
        4usize,
        concat!("Size of: ", stringify!(GNUNET_BANDWIDTH_Value32NBO))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_BANDWIDTH_Value32NBO>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_BANDWIDTH_Value32NBO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Value32NBO>())).value__ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Value32NBO),
            "::",
            stringify!(value__)
        )
    );
}
#[doc = " Callback to be called by the bandwidth tracker if the tracker"]
#[doc = " was updated and the client should update it's delay values"]
#[doc = ""]
#[doc = " @param cls a closure to pass"]
pub type GNUNET_BANDWIDTH_TrackerUpdateCallback =
    ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void)>;
#[doc = " Callback to be called by the bandwidth tracker if the tracker"]
#[doc = " was updated and the client should update it's delay values"]
#[doc = ""]
#[doc = " @param cls a closure to pass"]
pub type GNUNET_BANDWIDTH_ExcessNotificationCallback =
    ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void)>;
#[doc = " Struct to track available bandwidth.  Combines a time stamp with a"]
#[doc = " number of bytes transmitted, a quota and a maximum amount that"]
#[doc = " carries over.  Not opaque so that it can be inlined into data"]
#[doc = " structures (reducing malloc-ing); however, values should not be"]
#[doc = " accessed directly by clients (hence the '__')."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_BANDWIDTH_Tracker {
    #[doc = " Closure for @e update_cb."]
    pub update_cb_cls: *mut ::std::os::raw::c_void,
    #[doc = " Function we call if the tracker's bandwidth is increased and a"]
    #[doc = " previously returned timeout might now expire earlier."]
    pub update_cb: GNUNET_BANDWIDTH_TrackerUpdateCallback,
    #[doc = " Closure for @e excess_cb."]
    pub excess_cb_cls: *mut ::std::os::raw::c_void,
    #[doc = " Function we call if the tracker is about to throw"]
    #[doc = " away bandwidth due to excess (max carry exceeded)."]
    pub excess_cb: GNUNET_BANDWIDTH_ExcessNotificationCallback,
    #[doc = " Number of bytes consumed since we last updated the tracker."]
    pub consumption_since_last_update__: i64,
    #[doc = " Task scheduled to call the @e excess_cb once we have"]
    #[doc = " reached the maximum bandwidth the tracker can hold."]
    pub excess_task: *mut GNUNET_SCHEDULER_Task,
    #[doc = " Time when we last updated the tracker."]
    pub last_update__: GNUNET_TIME_Absolute,
    #[doc = " Bandwidth limit to enforce in bytes per second."]
    pub available_bytes_per_s__: u32,
    #[doc = " Maximum number of seconds over which bandwidth may \"accumulate\"."]
    #[doc = " Note that additionally, we also always allow at least"]
    #[doc = " #GNUNET_MAX_MESSAGE_SIZE to accumulate."]
    pub max_carry_s__: u32,
}
#[test]
fn bindgen_test_layout_GNUNET_BANDWIDTH_Tracker() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_BANDWIDTH_Tracker>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_BANDWIDTH_Tracker))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_BANDWIDTH_Tracker>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_BANDWIDTH_Tracker))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).update_cb_cls as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(update_cb_cls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).update_cb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(update_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).excess_cb_cls as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(excess_cb_cls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).excess_cb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(excess_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).consumption_since_last_update__
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(consumption_since_last_update__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).excess_task as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(excess_task)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).last_update__ as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(last_update__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).available_bytes_per_s__ as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(available_bytes_per_s__)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BANDWIDTH_Tracker>())).max_carry_s__ as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BANDWIDTH_Tracker),
            "::",
            stringify!(max_carry_s__)
        )
    );
}
extern "C" {
    #[doc = " Create a new bandwidth value."]
    #[doc = ""]
    #[doc = " @param bytes_per_second value to create"]
    #[doc = " @return the new bandwidth value"]
    pub fn GNUNET_BANDWIDTH_value_init(bytes_per_second: u32) -> GNUNET_BANDWIDTH_Value32NBO;
}
extern "C" {
    #[doc = " At the given bandwidth, calculate how much traffic will be"]
    #[doc = " available until the given deadline."]
    #[doc = ""]
    #[doc = " @param bps bandwidth"]
    #[doc = " @param deadline when is the deadline"]
    #[doc = " @return number of bytes available at bps until deadline"]
    pub fn GNUNET_BANDWIDTH_value_get_available_until(
        bps: GNUNET_BANDWIDTH_Value32NBO,
        deadline: GNUNET_TIME_Relative,
    ) -> u64;
}
extern "C" {
    #[doc = " At the given bandwidth, calculate how long it would take for"]
    #[doc = " 'size' bytes to be transmitted."]
    #[doc = ""]
    #[doc = " @param bps bandwidth"]
    #[doc = " @param size number of bytes we want to have available"]
    #[doc = " @return how long it would take"]
    pub fn GNUNET_BANDWIDTH_value_get_delay_for(
        bps: GNUNET_BANDWIDTH_Value32NBO,
        size: u64,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Compute the MIN of two bandwidth values."]
    #[doc = ""]
    #[doc = " @param b1 first value"]
    #[doc = " @param b2 second value"]
    #[doc = " @return the min of b1 and b2"]
    pub fn GNUNET_BANDWIDTH_value_min(
        b1: GNUNET_BANDWIDTH_Value32NBO,
        b2: GNUNET_BANDWIDTH_Value32NBO,
    ) -> GNUNET_BANDWIDTH_Value32NBO;
}
extern "C" {
    #[doc = " Compute the MAX of two bandwidth values."]
    #[doc = ""]
    #[doc = " @param b1 first value"]
    #[doc = " @param b2 second value"]
    #[doc = " @return the min of b1 and b2"]
    pub fn GNUNET_BANDWIDTH_value_max(
        b1: GNUNET_BANDWIDTH_Value32NBO,
        b2: GNUNET_BANDWIDTH_Value32NBO,
    ) -> GNUNET_BANDWIDTH_Value32NBO;
}
extern "C" {
    #[doc = " Compute the SUM of two bandwidth values."]
    #[doc = ""]
    #[doc = " @param b1 first value"]
    #[doc = " @param b2 second value"]
    #[doc = " @return the sum of b1 and b2"]
    pub fn GNUNET_BANDWIDTH_value_sum(
        b1: GNUNET_BANDWIDTH_Value32NBO,
        b2: GNUNET_BANDWIDTH_Value32NBO,
    ) -> GNUNET_BANDWIDTH_Value32NBO;
}
extern "C" {
    #[doc = " Initialize bandwidth tracker.  Note that in addition to the"]
    #[doc = " 'max_carry_s' limit, we also always allow at least"]
    #[doc = " #GNUNET_MAX_MESSAGE_SIZE to accumulate.  So if the"]
    #[doc = " bytes-per-second limit is so small that within 'max_carry_s' not"]
    #[doc = " even #GNUNET_MAX_MESSAGE_SIZE is allowed to accumulate, it is"]
    #[doc = " ignored and replaced by #GNUNET_MAX_MESSAGE_SIZE (which is in"]
    #[doc = " bytes)."]
    #[doc = ""]
    #[doc = " @param av tracker to initialize"]
    #[doc = " @param update_cb callback to notify a client about the tracker being updated"]
    #[doc = " @param update_cb_cls cls for the @a update_cb callback"]
    #[doc = " @param bytes_per_second_limit initial limit to assume"]
    #[doc = " @param max_carry_s maximum number of seconds unused bandwidth"]
    #[doc = "        may accumulate before it expires"]
    pub fn GNUNET_BANDWIDTH_tracker_init(
        av: *mut GNUNET_BANDWIDTH_Tracker,
        update_cb: GNUNET_BANDWIDTH_TrackerUpdateCallback,
        update_cb_cls: *mut ::std::os::raw::c_void,
        bytes_per_second_limit: GNUNET_BANDWIDTH_Value32NBO,
        max_carry_s: u32,
    );
}
extern "C" {
    #[doc = " Initialize bandwidth tracker.  Note that in addition to the"]
    #[doc = " 'max_carry_s' limit, we also always allow at least"]
    #[doc = " #GNUNET_MAX_MESSAGE_SIZE to accumulate.  So if the"]
    #[doc = " bytes-per-second limit is so small that within 'max_carry_s' not"]
    #[doc = " even #GNUNET_MAX_MESSAGE_SIZE is allowed to accumulate, it is"]
    #[doc = " ignored and replaced by #GNUNET_MAX_MESSAGE_SIZE (which is in"]
    #[doc = " bytes)."]
    #[doc = ""]
    #[doc = " @param av tracker to initialize"]
    #[doc = " @param update_cb callback to notify a client about the tracker being updated"]
    #[doc = " @param update_cb_cls cls for the @a update_cb callback"]
    #[doc = " @param bytes_per_second_limit initial limit to assume"]
    #[doc = " @param max_carry_s maximum number of seconds unused bandwidth"]
    #[doc = "        may accumulate before it expires"]
    #[doc = " @param excess_cb callback to notify if we have excess bandwidth"]
    #[doc = " @param excess_cb_cls closure for @a excess_cb"]
    pub fn GNUNET_BANDWIDTH_tracker_init2(
        av: *mut GNUNET_BANDWIDTH_Tracker,
        update_cb: GNUNET_BANDWIDTH_TrackerUpdateCallback,
        update_cb_cls: *mut ::std::os::raw::c_void,
        bytes_per_second_limit: GNUNET_BANDWIDTH_Value32NBO,
        max_carry_s: u32,
        excess_cb: GNUNET_BANDWIDTH_ExcessNotificationCallback,
        excess_cb_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Stop notifying about tracker updates and excess notifications"]
    #[doc = ""]
    #[doc = " @param av the respective trackers"]
    pub fn GNUNET_BANDWIDTH_tracker_notification_stop(av: *mut GNUNET_BANDWIDTH_Tracker);
}
extern "C" {
    #[doc = " Notify the tracker that a certain number of bytes of bandwidth have"]
    #[doc = " been consumed.  Note that it is legal to consume bytes even if not"]
    #[doc = " enough bandwidth is available (in that case,"]
    #[doc = " #GNUNET_BANDWIDTH_tracker_get_delay() may return non-zero delay values"]
    #[doc = " even for a size of zero for a while)."]
    #[doc = ""]
    #[doc = " @param av tracker to update"]
    #[doc = " @param size number of bytes consumed"]
    #[doc = " @return #GNUNET_YES if this consumption is above the limit"]
    pub fn GNUNET_BANDWIDTH_tracker_consume(
        av: *mut GNUNET_BANDWIDTH_Tracker,
        size: isize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute how long we should wait until consuming @a size"]
    #[doc = " bytes of bandwidth in order to stay within the given"]
    #[doc = " quota."]
    #[doc = ""]
    #[doc = " @param av tracker to query"]
    #[doc = " @param size number of bytes we would like to consume"]
    #[doc = " @return time to wait for consumption to be OK"]
    pub fn GNUNET_BANDWIDTH_tracker_get_delay(
        av: *mut GNUNET_BANDWIDTH_Tracker,
        size: usize,
    ) -> GNUNET_TIME_Relative;
}
extern "C" {
    #[doc = " Compute how many bytes are available for consumption right now."]
    #[doc = " quota."]
    #[doc = ""]
    #[doc = " @param av tracker to query"]
    #[doc = " @return number of bytes available for consumption right now"]
    pub fn GNUNET_BANDWIDTH_tracker_get_available(av: *mut GNUNET_BANDWIDTH_Tracker) -> i64;
}
extern "C" {
    #[doc = " Update quota of bandwidth tracker."]
    #[doc = ""]
    #[doc = " @param av tracker to initialize"]
    #[doc = " @param bytes_per_second_limit new limit to assume"]
    pub fn GNUNET_BANDWIDTH_tracker_update_quota(
        av: *mut GNUNET_BANDWIDTH_Tracker,
        bytes_per_second_limit: GNUNET_BANDWIDTH_Value32NBO,
    );
}
extern "C" {
    #[doc = " Try to compress the given block of data using libz.  Only returns"]
    #[doc = " the compressed block if compression worked and the new block is"]
    #[doc = " actually smaller.  Decompress using #GNUNET_decompress()."]
    #[doc = ""]
    #[doc = " @param data block to compress; if compression"]
    #[doc = "        resulted in a smaller block, the first"]
    #[doc = "        bytes of data are updated to the compressed"]
    #[doc = "        data"]
    #[doc = " @param old_size number of bytes in data"]
    #[doc = " @param[out] result set to the compressed data, if compression worked"]
    #[doc = " @param[out] new_size set to size of result, if compression worked"]
    #[doc = " @return #GNUNET_YES if compression reduce the size,"]
    #[doc = "         #GNUNET_NO if compression did not help"]
    pub fn GNUNET_try_compression(
        data: *const ::std::os::raw::c_char,
        old_size: usize,
        result: *mut *mut ::std::os::raw::c_char,
        new_size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decompress input, return the decompressed data as output.  Dual to"]
    #[doc = " #GNUNET_try_compression(). Caller must set @a output_size to the"]
    #[doc = " number of bytes that were originally compressed."]
    #[doc = ""]
    #[doc = " @param input compressed data"]
    #[doc = " @param input_size number of bytes in input"]
    #[doc = " @param output_size expected size of the output"]
    #[doc = " @return NULL on error, buffer of @a output_size decompressed bytes otherwise"]
    pub fn GNUNET_decompress(
        input: *const ::std::os::raw::c_char,
        input_size: usize,
        output_size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
pub const EXTRACTOR_Options_EXTRACTOR_OPTION_DEFAULT_POLICY: EXTRACTOR_Options = 0;
pub const EXTRACTOR_Options_EXTRACTOR_OPTION_OUT_OF_PROCESS_NO_RESTART: EXTRACTOR_Options = 1;
pub const EXTRACTOR_Options_EXTRACTOR_OPTION_IN_PROCESS: EXTRACTOR_Options = 2;
pub const EXTRACTOR_Options_EXTRACTOR_OPTION_DISABLED: EXTRACTOR_Options = 3;
pub type EXTRACTOR_Options = ::std::os::raw::c_uint;
pub const EXTRACTOR_MetaFormat_EXTRACTOR_METAFORMAT_UNKNOWN: EXTRACTOR_MetaFormat = 0;
pub const EXTRACTOR_MetaFormat_EXTRACTOR_METAFORMAT_UTF8: EXTRACTOR_MetaFormat = 1;
pub const EXTRACTOR_MetaFormat_EXTRACTOR_METAFORMAT_BINARY: EXTRACTOR_MetaFormat = 2;
pub const EXTRACTOR_MetaFormat_EXTRACTOR_METAFORMAT_C_STRING: EXTRACTOR_MetaFormat = 3;
pub type EXTRACTOR_MetaFormat = ::std::os::raw::c_uint;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_RESERVED: EXTRACTOR_MetaType = 0;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MIMETYPE: EXTRACTOR_MetaType = 1;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FILENAME: EXTRACTOR_MetaType = 2;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_COMMENT: EXTRACTOR_MetaType = 3;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TITLE: EXTRACTOR_MetaType = 4;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BOOK_TITLE: EXTRACTOR_MetaType = 5;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BOOK_EDITION: EXTRACTOR_MetaType = 6;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BOOK_CHAPTER_NUMBER: EXTRACTOR_MetaType = 7;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_JOURNAL_NAME: EXTRACTOR_MetaType = 8;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_JOURNAL_VOLUME: EXTRACTOR_MetaType = 9;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_JOURNAL_NUMBER: EXTRACTOR_MetaType = 10;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PAGE_COUNT: EXTRACTOR_MetaType = 11;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PAGE_RANGE: EXTRACTOR_MetaType = 12;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUTHOR_NAME: EXTRACTOR_MetaType = 13;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUTHOR_EMAIL: EXTRACTOR_MetaType = 14;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUTHOR_INSTITUTION: EXTRACTOR_MetaType = 15;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLISHER: EXTRACTOR_MetaType = 16;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLISHER_ADDRESS: EXTRACTOR_MetaType = 17;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLISHER_INSTITUTION: EXTRACTOR_MetaType = 18;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLISHER_SERIES: EXTRACTOR_MetaType = 19;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLICATION_TYPE: EXTRACTOR_MetaType = 20;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLICATION_YEAR: EXTRACTOR_MetaType = 21;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLICATION_MONTH: EXTRACTOR_MetaType = 22;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLICATION_DAY: EXTRACTOR_MetaType = 23;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PUBLICATION_DATE: EXTRACTOR_MetaType = 24;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BIBTEX_EPRINT: EXTRACTOR_MetaType = 25;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BIBTEX_ENTRY_TYPE: EXTRACTOR_MetaType = 26;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LANGUAGE: EXTRACTOR_MetaType = 27;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CREATION_TIME: EXTRACTOR_MetaType = 28;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_URL: EXTRACTOR_MetaType = 29;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_URI: EXTRACTOR_MetaType = 30;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ISRC: EXTRACTOR_MetaType = 31;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_HASH_MD4: EXTRACTOR_MetaType = 32;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_HASH_MD5: EXTRACTOR_MetaType = 33;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_HASH_SHA0: EXTRACTOR_MetaType = 34;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_HASH_SHA1: EXTRACTOR_MetaType = 35;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_HASH_RMD160: EXTRACTOR_MetaType = 36;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GPS_LATITUDE_REF: EXTRACTOR_MetaType = 37;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GPS_LATITUDE: EXTRACTOR_MetaType = 38;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GPS_LONGITUDE_REF: EXTRACTOR_MetaType = 39;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GPS_LONGITUDE: EXTRACTOR_MetaType = 40;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_CITY: EXTRACTOR_MetaType = 41;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_SUBLOCATION: EXTRACTOR_MetaType = 42;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_COUNTRY: EXTRACTOR_MetaType = 43;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_COUNTRY_CODE: EXTRACTOR_MetaType = 44;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_UNKNOWN: EXTRACTOR_MetaType = 45;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DESCRIPTION: EXTRACTOR_MetaType = 46;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_COPYRIGHT: EXTRACTOR_MetaType = 47;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_RIGHTS: EXTRACTOR_MetaType = 48;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_KEYWORDS: EXTRACTOR_MetaType = 49;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ABSTRACT: EXTRACTOR_MetaType = 50;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SUMMARY: EXTRACTOR_MetaType = 51;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SUBJECT: EXTRACTOR_MetaType = 52;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CREATOR: EXTRACTOR_MetaType = 53;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FORMAT: EXTRACTOR_MetaType = 54;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FORMAT_VERSION: EXTRACTOR_MetaType = 55;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CREATED_BY_SOFTWARE: EXTRACTOR_MetaType = 56;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_UNKNOWN_DATE: EXTRACTOR_MetaType = 57;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CREATION_DATE: EXTRACTOR_MetaType = 58;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MODIFICATION_DATE: EXTRACTOR_MetaType = 59;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LAST_PRINTED: EXTRACTOR_MetaType = 60;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LAST_SAVED_BY: EXTRACTOR_MetaType = 61;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TOTAL_EDITING_TIME: EXTRACTOR_MetaType = 62;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_EDITING_CYCLES: EXTRACTOR_MetaType = 63;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MODIFIED_BY_SOFTWARE: EXTRACTOR_MetaType = 64;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_REVISION_HISTORY: EXTRACTOR_MetaType = 65;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_EMBEDDED_FILE_SIZE: EXTRACTOR_MetaType = 66;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FINDER_FILE_TYPE: EXTRACTOR_MetaType = 67;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FINDER_FILE_CREATOR: EXTRACTOR_MetaType = 68;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_NAME: EXTRACTOR_MetaType = 69;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_VERSION: EXTRACTOR_MetaType = 70;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SECTION: EXTRACTOR_MetaType = 71;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_UPLOAD_PRIORITY: EXTRACTOR_MetaType = 72;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_DEPENDENCY: EXTRACTOR_MetaType = 73;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_CONFLICTS: EXTRACTOR_MetaType = 74;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_REPLACES: EXTRACTOR_MetaType = 75;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_PROVIDES: EXTRACTOR_MetaType = 76;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_RECOMMENDS: EXTRACTOR_MetaType = 77;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_SUGGESTS: EXTRACTOR_MetaType = 78;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_MAINTAINER: EXTRACTOR_MetaType = 79;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_INSTALLED_SIZE: EXTRACTOR_MetaType = 80;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_SOURCE: EXTRACTOR_MetaType = 81;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_ESSENTIAL: EXTRACTOR_MetaType = 82;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TARGET_ARCHITECTURE: EXTRACTOR_MetaType = 83;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_PRE_DEPENDENCY: EXTRACTOR_MetaType = 84;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LICENSE: EXTRACTOR_MetaType = 85;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PACKAGE_DISTRIBUTION: EXTRACTOR_MetaType = 86;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BUILDHOST: EXTRACTOR_MetaType = 87;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VENDOR: EXTRACTOR_MetaType = 88;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TARGET_OS: EXTRACTOR_MetaType = 89;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SOFTWARE_VERSION: EXTRACTOR_MetaType = 90;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TARGET_PLATFORM: EXTRACTOR_MetaType = 91;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_RESOURCE_TYPE: EXTRACTOR_MetaType = 92;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LIBRARY_SEARCH_PATH: EXTRACTOR_MetaType = 93;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LIBRARY_DEPENDENCY: EXTRACTOR_MetaType = 94;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CAMERA_MAKE: EXTRACTOR_MetaType = 95;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CAMERA_MODEL: EXTRACTOR_MetaType = 96;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_EXPOSURE: EXTRACTOR_MetaType = 97;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_APERTURE: EXTRACTOR_MetaType = 98;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_EXPOSURE_BIAS: EXTRACTOR_MetaType = 99;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FLASH: EXTRACTOR_MetaType = 100;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FLASH_BIAS: EXTRACTOR_MetaType = 101;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FOCAL_LENGTH: EXTRACTOR_MetaType = 102;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FOCAL_LENGTH_35MM: EXTRACTOR_MetaType = 103;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ISO_SPEED: EXTRACTOR_MetaType = 104;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_EXPOSURE_MODE: EXTRACTOR_MetaType = 105;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_METERING_MODE: EXTRACTOR_MetaType = 106;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MACRO_MODE: EXTRACTOR_MetaType = 107;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_IMAGE_QUALITY: EXTRACTOR_MetaType = 108;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_WHITE_BALANCE: EXTRACTOR_MetaType = 109;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORIENTATION: EXTRACTOR_MetaType = 110;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MAGNIFICATION: EXTRACTOR_MetaType = 111;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_IMAGE_DIMENSIONS: EXTRACTOR_MetaType = 112;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PRODUCED_BY_SOFTWARE: EXTRACTOR_MetaType = 113;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_THUMBNAIL: EXTRACTOR_MetaType = 114;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_IMAGE_RESOLUTION: EXTRACTOR_MetaType = 115;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SOURCE: EXTRACTOR_MetaType = 116;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CHARACTER_SET: EXTRACTOR_MetaType = 117;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LINE_COUNT: EXTRACTOR_MetaType = 118;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PARAGRAPH_COUNT: EXTRACTOR_MetaType = 119;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_WORD_COUNT: EXTRACTOR_MetaType = 120;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CHARACTER_COUNT: EXTRACTOR_MetaType = 121;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PAGE_ORIENTATION: EXTRACTOR_MetaType = 122;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PAPER_SIZE: EXTRACTOR_MetaType = 123;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TEMPLATE: EXTRACTOR_MetaType = 124;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_COMPANY: EXTRACTOR_MetaType = 125;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MANAGER: EXTRACTOR_MetaType = 126;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_REVISION_NUMBER: EXTRACTOR_MetaType = 127;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DURATION: EXTRACTOR_MetaType = 128;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ALBUM: EXTRACTOR_MetaType = 129;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ARTIST: EXTRACTOR_MetaType = 130;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GENRE: EXTRACTOR_MetaType = 131;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TRACK_NUMBER: EXTRACTOR_MetaType = 132;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DISC_NUMBER: EXTRACTOR_MetaType = 133;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PERFORMER: EXTRACTOR_MetaType = 134;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CONTACT_INFORMATION: EXTRACTOR_MetaType = 135;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SONG_VERSION: EXTRACTOR_MetaType = 136;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PICTURE: EXTRACTOR_MetaType = 137;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_COVER_PICTURE: EXTRACTOR_MetaType = 138;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CONTRIBUTOR_PICTURE: EXTRACTOR_MetaType = 139;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_EVENT_PICTURE: EXTRACTOR_MetaType = 140;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOGO: EXTRACTOR_MetaType = 141;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BROADCAST_TELEVISION_SYSTEM: EXTRACTOR_MetaType =
    142;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SOURCE_DEVICE: EXTRACTOR_MetaType = 143;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DISCLAIMER: EXTRACTOR_MetaType = 144;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_WARNING: EXTRACTOR_MetaType = 145;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PAGE_ORDER: EXTRACTOR_MetaType = 146;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_WRITER: EXTRACTOR_MetaType = 147;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PRODUCT_VERSION: EXTRACTOR_MetaType = 148;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CONTRIBUTOR_NAME: EXTRACTOR_MetaType = 149;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MOVIE_DIRECTOR: EXTRACTOR_MetaType = 150;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_NETWORK_NAME: EXTRACTOR_MetaType = 151;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SHOW_NAME: EXTRACTOR_MetaType = 152;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CHAPTER_NAME: EXTRACTOR_MetaType = 153;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SONG_COUNT: EXTRACTOR_MetaType = 154;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_STARTING_SONG: EXTRACTOR_MetaType = 155;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PLAY_COUNTER: EXTRACTOR_MetaType = 156;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CONDUCTOR: EXTRACTOR_MetaType = 157;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_INTERPRETATION: EXTRACTOR_MetaType = 158;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_COMPOSER: EXTRACTOR_MetaType = 159;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BEATS_PER_MINUTE: EXTRACTOR_MetaType = 160;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ENCODED_BY: EXTRACTOR_MetaType = 161;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORIGINAL_TITLE: EXTRACTOR_MetaType = 162;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORIGINAL_ARTIST: EXTRACTOR_MetaType = 163;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORIGINAL_WRITER: EXTRACTOR_MetaType = 164;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORIGINAL_RELEASE_YEAR: EXTRACTOR_MetaType = 165;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORIGINAL_PERFORMER: EXTRACTOR_MetaType = 166;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LYRICS: EXTRACTOR_MetaType = 167;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_POPULARITY_METER: EXTRACTOR_MetaType = 168;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LICENSEE: EXTRACTOR_MetaType = 169;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MUSICIAN_CREDITS_LIST: EXTRACTOR_MetaType = 170;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MOOD: EXTRACTOR_MetaType = 171;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SUBTITLE: EXTRACTOR_MetaType = 172;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GNUNET_DISPLAY_TYPE: EXTRACTOR_MetaType = 173;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GNUNET_FULL_DATA: EXTRACTOR_MetaType = 174;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_RATING: EXTRACTOR_MetaType = 175;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ORGANIZATION: EXTRACTOR_MetaType = 176;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_RIPPER: EXTRACTOR_MetaType = 177;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PRODUCER: EXTRACTOR_MetaType = 178;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GROUP: EXTRACTOR_MetaType = 179;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GNUNET_ORIGINAL_FILENAME: EXTRACTOR_MetaType = 180;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DISC_COUNT: EXTRACTOR_MetaType = 181;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CODEC: EXTRACTOR_MetaType = 182;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VIDEO_CODEC: EXTRACTOR_MetaType = 183;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUDIO_CODEC: EXTRACTOR_MetaType = 184;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SUBTITLE_CODEC: EXTRACTOR_MetaType = 185;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CONTAINER_FORMAT: EXTRACTOR_MetaType = 186;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_BITRATE: EXTRACTOR_MetaType = 187;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_NOMINAL_BITRATE: EXTRACTOR_MetaType = 188;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MINIMUM_BITRATE: EXTRACTOR_MetaType = 189;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MAXIMUM_BITRATE: EXTRACTOR_MetaType = 190;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SERIAL: EXTRACTOR_MetaType = 191;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ENCODER: EXTRACTOR_MetaType = 192;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ENCODER_VERSION: EXTRACTOR_MetaType = 193;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TRACK_GAIN: EXTRACTOR_MetaType = 194;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TRACK_PEAK: EXTRACTOR_MetaType = 195;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ALBUM_GAIN: EXTRACTOR_MetaType = 196;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_ALBUM_PEAK: EXTRACTOR_MetaType = 197;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_REFERENCE_LEVEL: EXTRACTOR_MetaType = 198;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_NAME: EXTRACTOR_MetaType = 199;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_ELEVATION: EXTRACTOR_MetaType = 200;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_HORIZONTAL_ERROR: EXTRACTOR_MetaType = 201;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_MOVEMENT_SPEED: EXTRACTOR_MetaType = 202;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_MOVEMENT_DIRECTION: EXTRACTOR_MetaType =
    203;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LOCATION_CAPTURE_DIRECTION: EXTRACTOR_MetaType =
    204;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SHOW_EPISODE_NUMBER: EXTRACTOR_MetaType = 205;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SHOW_SEASON_NUMBER: EXTRACTOR_MetaType = 206;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_GROUPING: EXTRACTOR_MetaType = 207;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DEVICE_MANUFACTURER: EXTRACTOR_MetaType = 208;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_DEVICE_MODEL: EXTRACTOR_MetaType = 209;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUDIO_LANGUAGE: EXTRACTOR_MetaType = 210;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_CHANNELS: EXTRACTOR_MetaType = 211;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SAMPLE_RATE: EXTRACTOR_MetaType = 212;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUDIO_DEPTH: EXTRACTOR_MetaType = 213;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUDIO_BITRATE: EXTRACTOR_MetaType = 214;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MAXIMUM_AUDIO_BITRATE: EXTRACTOR_MetaType = 215;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VIDEO_DIMENSIONS: EXTRACTOR_MetaType = 216;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VIDEO_DEPTH: EXTRACTOR_MetaType = 217;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_FRAME_RATE: EXTRACTOR_MetaType = 218;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_PIXEL_ASPECT_RATIO: EXTRACTOR_MetaType = 219;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VIDEO_BITRATE: EXTRACTOR_MetaType = 220;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_MAXIMUM_VIDEO_BITRATE: EXTRACTOR_MetaType = 221;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SUBTITLE_LANGUAGE: EXTRACTOR_MetaType = 222;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VIDEO_LANGUAGE: EXTRACTOR_MetaType = 223;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_TOC: EXTRACTOR_MetaType = 224;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_VIDEO_DURATION: EXTRACTOR_MetaType = 225;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUDIO_DURATION: EXTRACTOR_MetaType = 226;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_SUBTITLE_DURATION: EXTRACTOR_MetaType = 227;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_AUDIO_PREVIEW: EXTRACTOR_MetaType = 228;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_NARINFO: EXTRACTOR_MetaType = 229;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_NAR: EXTRACTOR_MetaType = 230;
pub const EXTRACTOR_MetaType_EXTRACTOR_METATYPE_LAST: EXTRACTOR_MetaType = 231;
pub type EXTRACTOR_MetaType = ::std::os::raw::c_uint;
extern "C" {
    pub fn EXTRACTOR_metatype_to_string(type_: EXTRACTOR_MetaType)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EXTRACTOR_metatype_to_description(
        type_: EXTRACTOR_MetaType,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn EXTRACTOR_metatype_get_max() -> EXTRACTOR_MetaType;
}
pub type EXTRACTOR_MetaDataProcessor = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        plugin_name: *const ::std::os::raw::c_char,
        type_: EXTRACTOR_MetaType,
        format: EXTRACTOR_MetaFormat,
        data_mime_type: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        data_len: usize,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXTRACTOR_ExtractContext {
    pub cls: *mut ::std::os::raw::c_void,
    pub config: *const ::std::os::raw::c_char,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            cls: *mut ::std::os::raw::c_void,
            data: *mut *mut ::std::os::raw::c_void,
            size: usize,
        ) -> isize,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            cls: *mut ::std::os::raw::c_void,
            pos: i64,
            whence: ::std::os::raw::c_int,
        ) -> i64,
    >,
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void) -> u64>,
    pub proc_: EXTRACTOR_MetaDataProcessor,
}
#[test]
fn bindgen_test_layout_EXTRACTOR_ExtractContext() {
    assert_eq!(
        ::std::mem::size_of::<EXTRACTOR_ExtractContext>(),
        48usize,
        concat!("Size of: ", stringify!(EXTRACTOR_ExtractContext))
    );
    assert_eq!(
        ::std::mem::align_of::<EXTRACTOR_ExtractContext>(),
        8usize,
        concat!("Alignment of ", stringify!(EXTRACTOR_ExtractContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EXTRACTOR_ExtractContext>())).cls as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTRACTOR_ExtractContext),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EXTRACTOR_ExtractContext>())).config as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTRACTOR_ExtractContext),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EXTRACTOR_ExtractContext>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTRACTOR_ExtractContext),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EXTRACTOR_ExtractContext>())).seek as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTRACTOR_ExtractContext),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EXTRACTOR_ExtractContext>())).get_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTRACTOR_ExtractContext),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EXTRACTOR_ExtractContext>())).proc_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EXTRACTOR_ExtractContext),
            "::",
            stringify!(proc_)
        )
    );
}
pub type EXTRACTOR_extract_method =
    ::std::option::Option<unsafe extern "C" fn(ec: *mut EXTRACTOR_ExtractContext)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EXTRACTOR_PluginList {
    _unused: [u8; 0],
}
extern "C" {
    pub fn EXTRACTOR_plugin_add_defaults(flags: EXTRACTOR_Options) -> *mut EXTRACTOR_PluginList;
}
extern "C" {
    pub fn EXTRACTOR_plugin_add(
        prev: *mut EXTRACTOR_PluginList,
        library: *const ::std::os::raw::c_char,
        options: *const ::std::os::raw::c_char,
        flags: EXTRACTOR_Options,
    ) -> *mut EXTRACTOR_PluginList;
}
extern "C" {
    pub fn EXTRACTOR_plugin_add_config(
        prev: *mut EXTRACTOR_PluginList,
        config: *const ::std::os::raw::c_char,
        flags: EXTRACTOR_Options,
    ) -> *mut EXTRACTOR_PluginList;
}
extern "C" {
    pub fn EXTRACTOR_plugin_remove(
        prev: *mut EXTRACTOR_PluginList,
        library: *const ::std::os::raw::c_char,
    ) -> *mut EXTRACTOR_PluginList;
}
extern "C" {
    pub fn EXTRACTOR_plugin_remove_all(plugins: *mut EXTRACTOR_PluginList);
}
extern "C" {
    pub fn EXTRACTOR_extract(
        plugins: *mut EXTRACTOR_PluginList,
        filename: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        size: usize,
        proc_: EXTRACTOR_MetaDataProcessor,
        proc_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn EXTRACTOR_meta_data_print(
        handle: *mut ::std::os::raw::c_void,
        plugin_name: *const ::std::os::raw::c_char,
        type_: EXTRACTOR_MetaType,
        format: EXTRACTOR_MetaFormat,
        data_mime_type: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        data_len: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief bloomfilter representation (opaque)"]
#[doc = " @ingroup bloomfilter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_BloomFilter {
    _unused: [u8; 0],
}
#[doc = " @ingroup bloomfilter"]
#[doc = " Iterator over `struct GNUNET_HashCode`."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param next set to the next hash code"]
#[doc = " @return #GNUNET_YES if next was updated"]
#[doc = "         #GNUNET_NO if there are no more entries"]
pub type GNUNET_CONTAINER_HashCodeIterator = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        next: *mut GNUNET_HashCode,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Load a Bloom filter from a file."]
    #[doc = ""]
    #[doc = " @param filename the name of the file (or the prefix)"]
    #[doc = " @param size the size of the bloom-filter (number of"]
    #[doc = "        bytes of storage space to use); will be rounded up"]
    #[doc = "        to next power of 2"]
    #[doc = " @param k the number of #GNUNET_CRYPTO_hash-functions to apply per"]
    #[doc = "        element (number of bits set per element in the set)"]
    #[doc = " @return the bloomfilter"]
    pub fn GNUNET_CONTAINER_bloomfilter_load(
        filename: *const ::std::os::raw::c_char,
        size: usize,
        k: ::std::os::raw::c_uint,
    ) -> *mut GNUNET_CONTAINER_BloomFilter;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Create a Bloom filter from raw bits."]
    #[doc = ""]
    #[doc = " @param data the raw bits in memory (maybe NULL,"]
    #[doc = "        in which case all bits should be considered"]
    #[doc = "        to be zero)."]
    #[doc = " @param size the size of the bloom-filter (number of"]
    #[doc = "        bytes of storage space to use); also size of @a data"]
    #[doc = "        -- unless data is NULL.  Must be a power of 2."]
    #[doc = " @param k the number of #GNUNET_CRYPTO_hash-functions to apply per"]
    #[doc = "        element (number of bits set per element in the set)"]
    #[doc = " @return the bloomfilter"]
    pub fn GNUNET_CONTAINER_bloomfilter_init(
        data: *const ::std::os::raw::c_char,
        size: usize,
        k: ::std::os::raw::c_uint,
    ) -> *mut GNUNET_CONTAINER_BloomFilter;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Copy the raw data of this Bloom filter into"]
    #[doc = " the given data array."]
    #[doc = ""]
    #[doc = " @param data where to write the data"]
    #[doc = " @param size the size of the given @a data array"]
    #[doc = " @return #GNUNET_SYSERR if the data array of the wrong size"]
    pub fn GNUNET_CONTAINER_bloomfilter_get_raw_data(
        bf: *const GNUNET_CONTAINER_BloomFilter,
        data: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Test if an element is in the filter."]
    #[doc = ""]
    #[doc = " @param e the element"]
    #[doc = " @param bf the filter"]
    #[doc = " @return #GNUNET_YES if the element is in the filter, #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_bloomfilter_test(
        bf: *const GNUNET_CONTAINER_BloomFilter,
        e: *const GNUNET_HashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Add an element to the filter."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @param e the element"]
    pub fn GNUNET_CONTAINER_bloomfilter_add(
        bf: *mut GNUNET_CONTAINER_BloomFilter,
        e: *const GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Remove an element from the filter."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @param e the element to remove"]
    pub fn GNUNET_CONTAINER_bloomfilter_remove(
        bf: *mut GNUNET_CONTAINER_BloomFilter,
        e: *const GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Create a copy of a bloomfilter."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @return copy of bf"]
    pub fn GNUNET_CONTAINER_bloomfilter_copy(
        bf: *const GNUNET_CONTAINER_BloomFilter,
    ) -> *mut GNUNET_CONTAINER_BloomFilter;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Free the space associated with a filter"]
    #[doc = " in memory, flush to drive if needed (do not"]
    #[doc = " free the space on the drive)."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    pub fn GNUNET_CONTAINER_bloomfilter_free(bf: *mut GNUNET_CONTAINER_BloomFilter);
}
extern "C" {
    #[doc = " Get the number of the addresses set per element in the bloom filter."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @return addresses set per element in the bf"]
    pub fn GNUNET_CONTAINER_bloomfilter_get_element_addresses(
        bf: *const GNUNET_CONTAINER_BloomFilter,
    ) -> usize;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Get size of the bloom filter."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @return number of bytes used for the data of the bloom filter"]
    pub fn GNUNET_CONTAINER_bloomfilter_get_size(bf: *const GNUNET_CONTAINER_BloomFilter) -> usize;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Reset a Bloom filter to empty."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    pub fn GNUNET_CONTAINER_bloomfilter_clear(bf: *mut GNUNET_CONTAINER_BloomFilter);
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " \"or\" the entries of the given raw data array with the"]
    #[doc = " data of the given Bloom filter.  Assumes that"]
    #[doc = " the @a size of the @a data array and the current filter"]
    #[doc = " match."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @param data data to OR-in"]
    #[doc = " @param size size of @a data"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_CONTAINER_bloomfilter_or(
        bf: *mut GNUNET_CONTAINER_BloomFilter,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " \"or\" the entries of the given raw data array with the"]
    #[doc = " data of the given Bloom filter.  Assumes that"]
    #[doc = " the size of the two filters matches."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @param to_or the bloomfilter to or-in"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_CONTAINER_bloomfilter_or2(
        bf: *mut GNUNET_CONTAINER_BloomFilter,
        to_or: *const GNUNET_CONTAINER_BloomFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup bloomfilter"]
    #[doc = " Resize a bloom filter.  Note that this operation"]
    #[doc = " is pretty costly.  Essentially, the Bloom filter"]
    #[doc = " needs to be completely re-build."]
    #[doc = ""]
    #[doc = " @param bf the filter"]
    #[doc = " @param iterator an iterator over all elements stored in the BF"]
    #[doc = " @param iterator_cls closure for @a iterator"]
    #[doc = " @param size the new size for the filter"]
    #[doc = " @param k the new number of #GNUNET_CRYPTO_hash-function to apply per element"]
    pub fn GNUNET_CONTAINER_bloomfilter_resize(
        bf: *mut GNUNET_CONTAINER_BloomFilter,
        iterator: GNUNET_CONTAINER_HashCodeIterator,
        iterator_cls: *mut ::std::os::raw::c_void,
        size: usize,
        k: ::std::os::raw::c_uint,
    );
}
#[doc = " @ingroup metadata"]
#[doc = " Meta data to associate with a file, directory or namespace."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MetaData {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Create a fresh meta data container."]
    #[doc = ""]
    #[doc = " @return empty meta-data container"]
    pub fn GNUNET_CONTAINER_meta_data_create() -> *mut GNUNET_CONTAINER_MetaData;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Duplicate a MetaData token."]
    #[doc = ""]
    #[doc = " @param md what to duplicate"]
    #[doc = " @return duplicate meta-data container"]
    pub fn GNUNET_CONTAINER_meta_data_duplicate(
        md: *const GNUNET_CONTAINER_MetaData,
    ) -> *mut GNUNET_CONTAINER_MetaData;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Free meta data."]
    #[doc = ""]
    #[doc = " @param md what to free"]
    pub fn GNUNET_CONTAINER_meta_data_destroy(md: *mut GNUNET_CONTAINER_MetaData);
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Test if two MDs are equal. We consider them equal if"]
    #[doc = " the meta types, formats and content match (we do not"]
    #[doc = " include the mime types and plugins names in this"]
    #[doc = " consideration)."]
    #[doc = ""]
    #[doc = " @param md1 first value to check"]
    #[doc = " @param md2 other value to check"]
    #[doc = " @return #GNUNET_YES if they are equal"]
    pub fn GNUNET_CONTAINER_meta_data_test_equal(
        md1: *const GNUNET_CONTAINER_MetaData,
        md2: *const GNUNET_CONTAINER_MetaData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Extend metadata."]
    #[doc = ""]
    #[doc = " @param md metadata to extend"]
    #[doc = " @param plugin_name name of the plugin that produced this value;"]
    #[doc = "        special values can be used (i.e. '&lt;zlib&gt;' for zlib being"]
    #[doc = "        used in the main libextractor library and yielding"]
    #[doc = "        meta data)."]
    #[doc = " @param type libextractor-type describing the meta data"]
    #[doc = " @param format basic format information about data"]
    #[doc = " @param data_mime_type mime-type of data (not of the original file);"]
    #[doc = "        can be NULL (if mime-type is not known)"]
    #[doc = " @param data actual meta-data found"]
    #[doc = " @param data_size number of bytes in data"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if this entry already exists"]
    #[doc = "         data_mime_type and plugin_name are not considered for \"exists\" checks"]
    pub fn GNUNET_CONTAINER_meta_data_insert(
        md: *mut GNUNET_CONTAINER_MetaData,
        plugin_name: *const ::std::os::raw::c_char,
        type_: EXTRACTOR_MetaType,
        format: EXTRACTOR_MetaFormat,
        data_mime_type: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Extend metadata.  Merges the meta data from the second argument"]
    #[doc = " into the first, discarding duplicate key-value pairs."]
    #[doc = ""]
    #[doc = " @param md metadata to extend"]
    #[doc = " @param in metadata to merge"]
    pub fn GNUNET_CONTAINER_meta_data_merge(
        md: *mut GNUNET_CONTAINER_MetaData,
        in_: *const GNUNET_CONTAINER_MetaData,
    );
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Remove an item."]
    #[doc = ""]
    #[doc = " @param md metadata to manipulate"]
    #[doc = " @param type type of the item to remove"]
    #[doc = " @param data specific value to remove, NULL to remove all"]
    #[doc = "        entries of the given type"]
    #[doc = " @param data_size number of bytes in data"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if the item does not exist in md"]
    pub fn GNUNET_CONTAINER_meta_data_delete(
        md: *mut GNUNET_CONTAINER_MetaData,
        type_: EXTRACTOR_MetaType,
        data: *const ::std::os::raw::c_char,
        data_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Remove all items in the container."]
    #[doc = ""]
    #[doc = " @param md metadata to manipulate"]
    pub fn GNUNET_CONTAINER_meta_data_clear(md: *mut GNUNET_CONTAINER_MetaData);
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Add the current time as the publication date"]
    #[doc = " to the meta-data."]
    #[doc = ""]
    #[doc = " @param md metadata to modify"]
    pub fn GNUNET_CONTAINER_meta_data_add_publication_date(md: *mut GNUNET_CONTAINER_MetaData);
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Iterate over MD entries."]
    #[doc = ""]
    #[doc = " @param md metadata to inspect"]
    #[doc = " @param iter function to call on each entry, return 0 to continue to iterate"]
    #[doc = "             and 1 to abort iteration in this function (GNU libextractor API!)"]
    #[doc = " @param iter_cls closure for @a iter"]
    #[doc = " @return number of entries"]
    pub fn GNUNET_CONTAINER_meta_data_iterate(
        md: *const GNUNET_CONTAINER_MetaData,
        iter: EXTRACTOR_MetaDataProcessor,
        iter_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Get the first MD entry of the given type.  Caller"]
    #[doc = " is responsible for freeing the return value."]
    #[doc = " Also, only meta data items that are strings (0-terminated)"]
    #[doc = " are returned by this function."]
    #[doc = ""]
    #[doc = " @param md metadata to inspect"]
    #[doc = " @param type type to look for"]
    #[doc = " @return NULL if no entry was found"]
    pub fn GNUNET_CONTAINER_meta_data_get_by_type(
        md: *const GNUNET_CONTAINER_MetaData,
        type_: EXTRACTOR_MetaType,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Get the first matching MD entry of the given types. Caller is"]
    #[doc = " responsible for freeing the return value.  Also, only meta data"]
    #[doc = " items that are strings (0-terminated) are returned by this"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param md metadata to inspect"]
    #[doc = " @param ... -1-terminated list of types"]
    #[doc = " @return NULL if we do not have any such entry,"]
    #[doc = "  otherwise client is responsible for freeing the value!"]
    pub fn GNUNET_CONTAINER_meta_data_get_first_by_types(
        md: *const GNUNET_CONTAINER_MetaData,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Get a thumbnail from the meta-data (if present).  Only matches meta"]
    #[doc = " data with mime type \"image\" and binary format."]
    #[doc = ""]
    #[doc = " @param md metadata to inspect"]
    #[doc = " @param thumb will be set to the thumbnail data.  Must be"]
    #[doc = "        freed by the caller!"]
    #[doc = " @return number of bytes in thumbnail, 0 if not available"]
    pub fn GNUNET_CONTAINER_meta_data_get_thumbnail(
        md: *const GNUNET_CONTAINER_MetaData,
        thumb: *mut *mut ::std::os::raw::c_uchar,
    ) -> usize;
}
#[doc = " @ingroup metadata"]
#[doc = " Serialize all of the data."]
pub const GNUNET_CONTAINER_MetaDataSerializationOptions_GNUNET_CONTAINER_META_DATA_SERIALIZE_FULL : GNUNET_CONTAINER_MetaDataSerializationOptions = 0 ;
#[doc = " @ingroup metadata"]
#[doc = " If not enough space is available, it is acceptable"]
#[doc = " to only serialize some of the metadata."]
pub const GNUNET_CONTAINER_MetaDataSerializationOptions_GNUNET_CONTAINER_META_DATA_SERIALIZE_PART : GNUNET_CONTAINER_MetaDataSerializationOptions = 1 ;
#[doc = " @ingroup metadata"]
#[doc = " Speed is of the essence, do not allow compression."]
pub const GNUNET_CONTAINER_MetaDataSerializationOptions_GNUNET_CONTAINER_META_DATA_SERIALIZE_NO_COMPRESS : GNUNET_CONTAINER_MetaDataSerializationOptions = 2 ;
#[doc = " @ingroup metadata"]
#[doc = " Options for metadata serialization."]
pub type GNUNET_CONTAINER_MetaDataSerializationOptions = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Serialize meta-data to target."]
    #[doc = ""]
    #[doc = " @param md metadata to serialize"]
    #[doc = " @param target where to write the serialized metadata;"]
    #[doc = "         *target can be NULL, in which case memory is allocated"]
    #[doc = " @param max maximum number of bytes available"]
    #[doc = " @param opt is it ok to just write SOME of the"]
    #[doc = "        meta-data to match the size constraint,"]
    #[doc = "        possibly discarding some data?"]
    #[doc = " @return number of bytes written on success,"]
    #[doc = "         -1 on error (typically: not enough"]
    #[doc = "         space)"]
    pub fn GNUNET_CONTAINER_meta_data_serialize(
        md: *const GNUNET_CONTAINER_MetaData,
        target: *mut *mut ::std::os::raw::c_char,
        max: usize,
        opt: GNUNET_CONTAINER_MetaDataSerializationOptions,
    ) -> isize;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Get the size of the full meta-data in serialized form."]
    #[doc = ""]
    #[doc = " @param md metadata to inspect"]
    #[doc = " @return number of bytes needed for serialization, -1 on error"]
    pub fn GNUNET_CONTAINER_meta_data_get_serialized_size(
        md: *const GNUNET_CONTAINER_MetaData,
    ) -> isize;
}
extern "C" {
    #[doc = " @ingroup metadata"]
    #[doc = " Deserialize meta-data.  Initializes md."]
    #[doc = ""]
    #[doc = " @param input serialized meta-data."]
    #[doc = " @param size number of bytes available"]
    #[doc = " @return MD on success, NULL on error (i.e."]
    #[doc = "         bad format)"]
    pub fn GNUNET_CONTAINER_meta_data_deserialize(
        input: *const ::std::os::raw::c_char,
        size: usize,
    ) -> *mut GNUNET_CONTAINER_MetaData;
}
#[doc = " @ingroup hashmap"]
#[doc = " Opaque handle for a HashMap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiHashMap {
    _unused: [u8; 0],
}
#[doc = " @ingroup hashmap"]
#[doc = " Opaque handle to an iterator over"]
#[doc = " a multihashmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiHashMapIterator {
    _unused: [u8; 0],
}
#[doc = " @ingroup hashmap"]
#[doc = " If a value with the given key exists, replace it.  Note that the"]
#[doc = " old value would NOT be freed by replace (the application has to"]
#[doc = " make sure that this happens if required)."]
pub const GNUNET_CONTAINER_MultiHashMapOption_GNUNET_CONTAINER_MULTIHASHMAPOPTION_REPLACE:
    GNUNET_CONTAINER_MultiHashMapOption = 0;
#[doc = " @ingroup hashmap"]
#[doc = " Allow multiple values with the same key."]
pub const GNUNET_CONTAINER_MultiHashMapOption_GNUNET_CONTAINER_MULTIHASHMAPOPTION_MULTIPLE:
    GNUNET_CONTAINER_MultiHashMapOption = 1;
#[doc = " @ingroup hashmap"]
#[doc = " There must only be one value per key; storing a value should fail"]
#[doc = " if a value under the same key already exists."]
pub const GNUNET_CONTAINER_MultiHashMapOption_GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY:
    GNUNET_CONTAINER_MultiHashMapOption = 2;
#[doc = " @ingroup hashmap There must only be one value per key, but don't"]
#[doc = " bother checking if a value already exists (faster than"]
#[doc = " #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY; implemented"]
#[doc = " just like #GNUNET_CONTAINER_MULTIHASHMAPOPTION_MULTIPLE but this"]
#[doc = " option documents better what is intended if"]
#[doc = " #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY is what is"]
#[doc = " desired)."]
pub const GNUNET_CONTAINER_MultiHashMapOption_GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_FAST:
    GNUNET_CONTAINER_MultiHashMapOption = 3;
#[doc = " @ingroup hashmap"]
#[doc = " Options for storing values in the HashMap."]
pub type GNUNET_CONTAINER_MultiHashMapOption = ::std::os::raw::c_uint;
#[doc = " @ingroup hashmap"]
#[doc = " Iterator over hash map entries."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param key current key code"]
#[doc = " @param value value in the hash map"]
#[doc = " @return #GNUNET_YES if we should continue to"]
#[doc = "         iterate,"]
#[doc = "         #GNUNET_NO if not."]
pub type GNUNET_CONTAINER_MulitHashMapIteratorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        key: *const GNUNET_HashCode,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create a multi hash map."]
    #[doc = ""]
    #[doc = " @param len initial size (map will grow as needed)"]
    #[doc = " @param do_not_copy_keys #GNUNET_NO is always safe and should be used by default;"]
    #[doc = "                         #GNUNET_YES means that on 'put', the 'key' does not have"]
    #[doc = "                         to be copied as the destination of the pointer is"]
    #[doc = "                         guaranteed to be life as long as the value is stored in"]
    #[doc = "                         the hashmap.  This can significantly reduce memory"]
    #[doc = "                         consumption, but of course is also a recipe for"]
    #[doc = "                         heap corruption if the assumption is not true.  Only"]
    #[doc = "                         use this if (1) memory use is important in this case and"]
    #[doc = "                         (2) you have triple-checked that the invariant holds"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CONTAINER_multihashmap_create(
        len: ::std::os::raw::c_uint,
        do_not_copy_keys: ::std::os::raw::c_int,
    ) -> *mut GNUNET_CONTAINER_MultiHashMap;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a hash map.  Will not free any values"]
    #[doc = " stored in the hash map!"]
    #[doc = ""]
    #[doc = " @param map the map"]
    pub fn GNUNET_CONTAINER_multihashmap_destroy(map: *mut GNUNET_CONTAINER_MultiHashMap);
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Given a key find a value in the map matching the key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key what to look for"]
    #[doc = " @return NULL if no value was found; note that"]
    #[doc = "   this is indistinguishable from values that just"]
    #[doc = "   happen to be NULL; use \"contains\" to test for"]
    #[doc = "   key-value pairs with value NULL"]
    pub fn GNUNET_CONTAINER_multihashmap_get(
        map: *const GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove the given key-value pair from the map.  Note that if the"]
    #[doc = " key-value pair is in the map multiple times, only one of the pairs"]
    #[doc = " will be removed."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key of the key-value pair"]
    #[doc = " @param value value of the key-value pair"]
    #[doc = " @return #GNUNET_YES on success, #GNUNET_NO if the key-value pair"]
    #[doc = "  is not in the map"]
    pub fn GNUNET_CONTAINER_multihashmap_remove(
        map: *mut GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove all entries for the given key from the map."]
    #[doc = " Note that the values would not be \"freed\"."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key identifies values to be removed"]
    #[doc = " @return number of values removed"]
    pub fn GNUNET_CONTAINER_multihashmap_remove_all(
        map: *mut GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove all entries from the map."]
    #[doc = " Note that the values would not be \"freed\"."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @return number of values removed"]
    pub fn GNUNET_CONTAINER_multihashmap_clear(
        map: *mut GNUNET_CONTAINER_MultiHashMap,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains any value under the given"]
    #[doc = " key (including values that are NULL)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multihashmap_contains(
        map: *const GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains the given value under the given"]
    #[doc = " key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @param value value to test for"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multihashmap_contains_value(
        map: *const GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Store a key-value pair in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key to use"]
    #[doc = " @param value value to use"]
    #[doc = " @param opt options for put"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_NO if a value was replaced (with REPLACE)"]
    #[doc = "         #GNUNET_SYSERR if #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY was the option and the"]
    #[doc = "                       value already exists"]
    pub fn GNUNET_CONTAINER_multihashmap_put(
        map: *mut GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
        value: *mut ::std::os::raw::c_void,
        opt: GNUNET_CONTAINER_MultiHashMapOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Get the number of key-value pairs in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @return the number of key value pairs"]
    pub fn GNUNET_CONTAINER_multihashmap_size(
        map: *const GNUNET_CONTAINER_MultiHashMap,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multihashmap_iterate(
        map: *mut GNUNET_CONTAINER_MultiHashMap,
        it: GNUNET_CONTAINER_MulitHashMapIteratorCallback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create an iterator for a multihashmap."]
    #[doc = " The iterator can be used to retrieve all the elements in the multihashmap"]
    #[doc = " one by one, without having to handle all elements at once (in contrast to"]
    #[doc = " #GNUNET_CONTAINER_multihashmap_iterate).  Note that the iterator can not be"]
    #[doc = " used anymore if elements have been removed from 'map' after the creation of"]
    #[doc = " the iterator, or 'map' has been destroyed.  Adding elements to 'map' may"]
    #[doc = " result in skipped or repeated elements."]
    #[doc = ""]
    #[doc = " @param map the map to create an iterator for"]
    #[doc = " @return an iterator over the given multihashmap @a map"]
    pub fn GNUNET_CONTAINER_multihashmap_iterator_create(
        map: *const GNUNET_CONTAINER_MultiHashMap,
    ) -> *mut GNUNET_CONTAINER_MultiHashMapIterator;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Retrieve the next element from the hash map at the iterator's"]
    #[doc = " position.  If there are no elements left, #GNUNET_NO is returned,"]
    #[doc = " and @a key and @a value are not modified.  This operation is only"]
    #[doc = " allowed if no elements have been removed from the multihashmap"]
    #[doc = " since the creation of @a iter, and the map has not been destroyed."]
    #[doc = " Adding elements may result in repeating or skipping elements."]
    #[doc = ""]
    #[doc = " @param iter the iterator to get the next element from"]
    #[doc = " @param key pointer to store the key in, can be NULL"]
    #[doc = " @param value pointer to store the value in, can be NULL"]
    #[doc = " @return #GNUNET_YES we returned an element,"]
    #[doc = "         #GNUNET_NO if we are out of elements"]
    pub fn GNUNET_CONTAINER_multihashmap_iterator_next(
        iter: *mut GNUNET_CONTAINER_MultiHashMapIterator,
        key: *mut GNUNET_HashCode,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a multihashmap iterator."]
    #[doc = ""]
    #[doc = " @param iter the iterator to destroy"]
    pub fn GNUNET_CONTAINER_multihashmap_iterator_destroy(
        iter: *mut GNUNET_CONTAINER_MultiHashMapIterator,
    );
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map that match a particular key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key that the entries must correspond to"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multihashmap_get_multiple(
        map: *mut GNUNET_CONTAINER_MultiHashMap,
        key: *const GNUNET_HashCode,
        it: GNUNET_CONTAINER_MulitHashMapIteratorCallback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Call @a it on a random value from the map, or not at all"]
    #[doc = " if the map is empty.  Note that this function has linear"]
    #[doc = " complexity (in the size of the map)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on a random entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed, zero or one."]
    pub fn GNUNET_CONTAINER_multihashmap_get_random(
        map: *const GNUNET_CONTAINER_MultiHashMap,
        it: GNUNET_CONTAINER_MulitHashMapIteratorCallback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " @ingroup hashmap"]
#[doc = " Iterator over hash map entries."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param key current public key"]
#[doc = " @param value value in the hash map"]
#[doc = " @return #GNUNET_YES if we should continue to"]
#[doc = "         iterate,"]
#[doc = "         #GNUNET_NO if not."]
pub type GNUNET_CONTAINER_PeerMapIterator = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        key: *const GNUNET_PeerIdentity,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Hash map from peer identities to values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiPeerMap {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create a multi peer map (hash map for public keys of peers)."]
    #[doc = ""]
    #[doc = " @param len initial size (map will grow as needed)"]
    #[doc = " @param do_not_copy_keys #GNUNET_NO is always safe and should be used by default;"]
    #[doc = "                         #GNUNET_YES means that on 'put', the 'key' does not have"]
    #[doc = "                         to be copied as the destination of the pointer is"]
    #[doc = "                         guaranteed to be life as long as the value is stored in"]
    #[doc = "                         the hashmap.  This can significantly reduce memory"]
    #[doc = "                         consumption, but of course is also a recipe for"]
    #[doc = "                         heap corruption if the assumption is not true.  Only"]
    #[doc = "                         use this if (1) memory use is important in this case and"]
    #[doc = "                         (2) you have triple-checked that the invariant holds"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CONTAINER_multipeermap_create(
        len: ::std::os::raw::c_uint,
        do_not_copy_keys: ::std::os::raw::c_int,
    ) -> *mut GNUNET_CONTAINER_MultiPeerMap;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a hash map.  Will not free any values"]
    #[doc = " stored in the hash map!"]
    #[doc = ""]
    #[doc = " @param map the map"]
    pub fn GNUNET_CONTAINER_multipeermap_destroy(map: *mut GNUNET_CONTAINER_MultiPeerMap);
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Given a key find a value in the map matching the key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key what to look for"]
    #[doc = " @return NULL if no value was found; note that"]
    #[doc = "   this is indistinguishable from values that just"]
    #[doc = "   happen to be NULL; use \"contains\" to test for"]
    #[doc = "   key-value pairs with value NULL"]
    pub fn GNUNET_CONTAINER_multipeermap_get(
        map: *const GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove the given key-value pair from the map.  Note that if the"]
    #[doc = " key-value pair is in the map multiple times, only one of the pairs"]
    #[doc = " will be removed."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key of the key-value pair"]
    #[doc = " @param value value of the key-value pair"]
    #[doc = " @return #GNUNET_YES on success, #GNUNET_NO if the key-value pair"]
    #[doc = "  is not in the map"]
    pub fn GNUNET_CONTAINER_multipeermap_remove(
        map: *mut GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove all entries for the given key from the map."]
    #[doc = " Note that the values would not be \"freed\"."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key identifies values to be removed"]
    #[doc = " @return number of values removed"]
    pub fn GNUNET_CONTAINER_multipeermap_remove_all(
        map: *mut GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains any value under the given"]
    #[doc = " key (including values that are NULL)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multipeermap_contains(
        map: *const GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains the given value under the given"]
    #[doc = " key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @param value value to test for"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multipeermap_contains_value(
        map: *const GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Store a key-value pair in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key to use"]
    #[doc = " @param value value to use"]
    #[doc = " @param opt options for put"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_NO if a value was replaced (with REPLACE)"]
    #[doc = "         #GNUNET_SYSERR if #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY was the option and the"]
    #[doc = "                       value already exists"]
    pub fn GNUNET_CONTAINER_multipeermap_put(
        map: *mut GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
        value: *mut ::std::os::raw::c_void,
        opt: GNUNET_CONTAINER_MultiHashMapOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Get the number of key-value pairs in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @return the number of key value pairs"]
    pub fn GNUNET_CONTAINER_multipeermap_size(
        map: *const GNUNET_CONTAINER_MultiPeerMap,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multipeermap_iterate(
        map: *mut GNUNET_CONTAINER_MultiPeerMap,
        it: GNUNET_CONTAINER_PeerMapIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiPeerMapIterator {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create an iterator for a multihashmap."]
    #[doc = " The iterator can be used to retrieve all the elements in the multihashmap"]
    #[doc = " one by one, without having to handle all elements at once (in contrast to"]
    #[doc = " #GNUNET_CONTAINER_multipeermap_iterate).  Note that the iterator can not be"]
    #[doc = " used anymore if elements have been removed from @a map after the creation of"]
    #[doc = " the iterator, or 'map' has been destroyed.  Adding elements to @a map may"]
    #[doc = " result in skipped or repeated elements."]
    #[doc = ""]
    #[doc = " @param map the map to create an iterator for"]
    #[doc = " @return an iterator over the given multihashmap @a map"]
    pub fn GNUNET_CONTAINER_multipeermap_iterator_create(
        map: *const GNUNET_CONTAINER_MultiPeerMap,
    ) -> *mut GNUNET_CONTAINER_MultiPeerMapIterator;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Retrieve the next element from the hash map at the iterator's"]
    #[doc = " position.  If there are no elements left, #GNUNET_NO is returned,"]
    #[doc = " and @a key and @a value are not modified.  This operation is only"]
    #[doc = " allowed if no elements have been removed from the multihashmap"]
    #[doc = " since the creation of @a iter, and the map has not been destroyed."]
    #[doc = " Adding elements may result in repeating or skipping elements."]
    #[doc = ""]
    #[doc = " @param iter the iterator to get the next element from"]
    #[doc = " @param key pointer to store the key in, can be NULL"]
    #[doc = " @param value pointer to store the value in, can be NULL"]
    #[doc = " @return #GNUNET_YES we returned an element,"]
    #[doc = "         #GNUNET_NO if we are out of elements"]
    pub fn GNUNET_CONTAINER_multipeermap_iterator_next(
        iter: *mut GNUNET_CONTAINER_MultiPeerMapIterator,
        key: *mut GNUNET_PeerIdentity,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a multipeermap iterator."]
    #[doc = ""]
    #[doc = " @param iter the iterator to destroy"]
    pub fn GNUNET_CONTAINER_multipeermap_iterator_destroy(
        iter: *mut GNUNET_CONTAINER_MultiPeerMapIterator,
    );
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map that match a particular key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key public key that the entries must correspond to"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multipeermap_get_multiple(
        map: *mut GNUNET_CONTAINER_MultiPeerMap,
        key: *const GNUNET_PeerIdentity,
        it: GNUNET_CONTAINER_PeerMapIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Call @a it on a random value from the map, or not at all"]
    #[doc = " if the map is empty.  Note that this function has linear"]
    #[doc = " complexity (in the size of the map)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on a random entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed, zero or one."]
    pub fn GNUNET_CONTAINER_multipeermap_get_random(
        map: *const GNUNET_CONTAINER_MultiPeerMap,
        it: GNUNET_CONTAINER_PeerMapIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " @ingroup hashmap"]
#[doc = " Iterator over hash map entries."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param key current public key"]
#[doc = " @param value value in the hash map"]
#[doc = " @return #GNUNET_YES if we should continue to"]
#[doc = "         iterate,"]
#[doc = "         #GNUNET_NO if not."]
pub type GNUNET_CONTAINER_ShortmapIterator = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        key: *const GNUNET_ShortHashCode,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Hash map from peer identities to values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiShortmap {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create a multi peer map (hash map for public keys of peers)."]
    #[doc = ""]
    #[doc = " @param len initial size (map will grow as needed)"]
    #[doc = " @param do_not_copy_keys #GNUNET_NO is always safe and should be used by default;"]
    #[doc = "                         #GNUNET_YES means that on 'put', the 'key' does not have"]
    #[doc = "                         to be copied as the destination of the pointer is"]
    #[doc = "                         guaranteed to be life as long as the value is stored in"]
    #[doc = "                         the hashmap.  This can significantly reduce memory"]
    #[doc = "                         consumption, but of course is also a recipe for"]
    #[doc = "                         heap corruption if the assumption is not true.  Only"]
    #[doc = "                         use this if (1) memory use is important in this case and"]
    #[doc = "                         (2) you have triple-checked that the invariant holds"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CONTAINER_multishortmap_create(
        len: ::std::os::raw::c_uint,
        do_not_copy_keys: ::std::os::raw::c_int,
    ) -> *mut GNUNET_CONTAINER_MultiShortmap;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a hash map.  Will not free any values"]
    #[doc = " stored in the hash map!"]
    #[doc = ""]
    #[doc = " @param map the map"]
    pub fn GNUNET_CONTAINER_multishortmap_destroy(map: *mut GNUNET_CONTAINER_MultiShortmap);
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Given a key find a value in the map matching the key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key what to look for"]
    #[doc = " @return NULL if no value was found; note that"]
    #[doc = "   this is indistinguishable from values that just"]
    #[doc = "   happen to be NULL; use \"contains\" to test for"]
    #[doc = "   key-value pairs with value NULL"]
    pub fn GNUNET_CONTAINER_multishortmap_get(
        map: *const GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove the given key-value pair from the map.  Note that if the"]
    #[doc = " key-value pair is in the map multiple times, only one of the pairs"]
    #[doc = " will be removed."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key of the key-value pair"]
    #[doc = " @param value value of the key-value pair"]
    #[doc = " @return #GNUNET_YES on success, #GNUNET_NO if the key-value pair"]
    #[doc = "  is not in the map"]
    pub fn GNUNET_CONTAINER_multishortmap_remove(
        map: *mut GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove all entries for the given key from the map."]
    #[doc = " Note that the values would not be \"freed\"."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key identifies values to be removed"]
    #[doc = " @return number of values removed"]
    pub fn GNUNET_CONTAINER_multishortmap_remove_all(
        map: *mut GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains any value under the given"]
    #[doc = " key (including values that are NULL)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multishortmap_contains(
        map: *const GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains the given value under the given"]
    #[doc = " key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @param value value to test for"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multishortmap_contains_value(
        map: *const GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Store a key-value pair in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key to use"]
    #[doc = " @param value value to use"]
    #[doc = " @param opt options for put"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_NO if a value was replaced (with REPLACE)"]
    #[doc = "         #GNUNET_SYSERR if #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY was the option and the"]
    #[doc = "                       value already exists"]
    pub fn GNUNET_CONTAINER_multishortmap_put(
        map: *mut GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
        value: *mut ::std::os::raw::c_void,
        opt: GNUNET_CONTAINER_MultiHashMapOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Get the number of key-value pairs in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @return the number of key value pairs"]
    pub fn GNUNET_CONTAINER_multishortmap_size(
        map: *const GNUNET_CONTAINER_MultiShortmap,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multishortmap_iterate(
        map: *mut GNUNET_CONTAINER_MultiShortmap,
        it: GNUNET_CONTAINER_ShortmapIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiShortmapIterator {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create an iterator for a multihashmap."]
    #[doc = " The iterator can be used to retrieve all the elements in the multihashmap"]
    #[doc = " one by one, without having to handle all elements at once (in contrast to"]
    #[doc = " #GNUNET_CONTAINER_multishortmap_iterate).  Note that the iterator can not be"]
    #[doc = " used anymore if elements have been removed from @a map after the creation of"]
    #[doc = " the iterator, or 'map' has been destroyed.  Adding elements to @a map may"]
    #[doc = " result in skipped or repeated elements."]
    #[doc = ""]
    #[doc = " @param map the map to create an iterator for"]
    #[doc = " @return an iterator over the given multihashmap @a map"]
    pub fn GNUNET_CONTAINER_multishortmap_iterator_create(
        map: *const GNUNET_CONTAINER_MultiShortmap,
    ) -> *mut GNUNET_CONTAINER_MultiShortmapIterator;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Retrieve the next element from the hash map at the iterator's"]
    #[doc = " position.  If there are no elements left, #GNUNET_NO is returned,"]
    #[doc = " and @a key and @a value are not modified.  This operation is only"]
    #[doc = " allowed if no elements have been removed from the multihashmap"]
    #[doc = " since the creation of @a iter, and the map has not been destroyed."]
    #[doc = " Adding elements may result in repeating or skipping elements."]
    #[doc = ""]
    #[doc = " @param iter the iterator to get the next element from"]
    #[doc = " @param key pointer to store the key in, can be NULL"]
    #[doc = " @param value pointer to store the value in, can be NULL"]
    #[doc = " @return #GNUNET_YES we returned an element,"]
    #[doc = "         #GNUNET_NO if we are out of elements"]
    pub fn GNUNET_CONTAINER_multishortmap_iterator_next(
        iter: *mut GNUNET_CONTAINER_MultiShortmapIterator,
        key: *mut GNUNET_ShortHashCode,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a multishortmap iterator."]
    #[doc = ""]
    #[doc = " @param iter the iterator to destroy"]
    pub fn GNUNET_CONTAINER_multishortmap_iterator_destroy(
        iter: *mut GNUNET_CONTAINER_MultiShortmapIterator,
    );
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map that match a particular key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key public key that the entries must correspond to"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multishortmap_get_multiple(
        map: *mut GNUNET_CONTAINER_MultiShortmap,
        key: *const GNUNET_ShortHashCode,
        it: GNUNET_CONTAINER_ShortmapIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Call @a it on a random value from the map, or not at all"]
    #[doc = " if the map is empty.  Note that this function has linear"]
    #[doc = " complexity (in the size of the map)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on a random entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed, zero or one."]
    pub fn GNUNET_CONTAINER_multishortmap_get_random(
        map: *const GNUNET_CONTAINER_MultiShortmap,
        it: GNUNET_CONTAINER_ShortmapIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " @ingroup hashmap"]
#[doc = " Iterator over uuid map entries."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param key current public key"]
#[doc = " @param value value in the hash map"]
#[doc = " @return #GNUNET_YES if we should continue to"]
#[doc = "         iterate,"]
#[doc = "         #GNUNET_NO if not."]
pub type GNUNET_CONTAINER_MultiUuidmapIteratorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        key: *const GNUNET_Uuid,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Hash map from peer identities to values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiUuidmap {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create a multi peer map (hash map for public keys of peers)."]
    #[doc = ""]
    #[doc = " @param len initial size (map will grow as needed)"]
    #[doc = " @param do_not_copy_keys #GNUNET_NO is always safe and should be used by default;"]
    #[doc = "                         #GNUNET_YES means that on 'put', the 'key' does not have"]
    #[doc = "                         to be copied as the destination of the pointer is"]
    #[doc = "                         guaranteed to be life as long as the value is stored in"]
    #[doc = "                         the hashmap.  This can significantly reduce memory"]
    #[doc = "                         consumption, but of course is also a recipe for"]
    #[doc = "                         heap corruption if the assumption is not true.  Only"]
    #[doc = "                         use this if (1) memory use is important in this case and"]
    #[doc = "                         (2) you have triple-checked that the invariant holds"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CONTAINER_multiuuidmap_create(
        len: ::std::os::raw::c_uint,
        do_not_copy_keys: ::std::os::raw::c_int,
    ) -> *mut GNUNET_CONTAINER_MultiUuidmap;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a hash map.  Will not free any values"]
    #[doc = " stored in the hash map!"]
    #[doc = ""]
    #[doc = " @param map the map"]
    pub fn GNUNET_CONTAINER_multiuuidmap_destroy(map: *mut GNUNET_CONTAINER_MultiUuidmap);
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Given a key find a value in the map matching the key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key what to look for"]
    #[doc = " @return NULL if no value was found; note that"]
    #[doc = "   this is indistinguishable from values that just"]
    #[doc = "   happen to be NULL; use \"contains\" to test for"]
    #[doc = "   key-value pairs with value NULL"]
    pub fn GNUNET_CONTAINER_multiuuidmap_get(
        map: *const GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove the given key-value pair from the map.  Note that if the"]
    #[doc = " key-value pair is in the map multiple times, only one of the pairs"]
    #[doc = " will be removed."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key of the key-value pair"]
    #[doc = " @param value value of the key-value pair"]
    #[doc = " @return #GNUNET_YES on success, #GNUNET_NO if the key-value pair"]
    #[doc = "  is not in the map"]
    pub fn GNUNET_CONTAINER_multiuuidmap_remove(
        map: *mut GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove all entries for the given key from the map."]
    #[doc = " Note that the values would not be \"freed\"."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key identifies values to be removed"]
    #[doc = " @return number of values removed"]
    pub fn GNUNET_CONTAINER_multiuuidmap_remove_all(
        map: *mut GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains any value under the given"]
    #[doc = " key (including values that are NULL)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multiuuidmap_contains(
        map: *const GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains the given value under the given"]
    #[doc = " key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @param value value to test for"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multiuuidmap_contains_value(
        map: *const GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Store a key-value pair in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key to use"]
    #[doc = " @param value value to use"]
    #[doc = " @param opt options for put"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_NO if a value was replaced (with REPLACE)"]
    #[doc = "         #GNUNET_SYSERR if #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY was the option and the"]
    #[doc = "                       value already exists"]
    pub fn GNUNET_CONTAINER_multiuuidmap_put(
        map: *mut GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
        value: *mut ::std::os::raw::c_void,
        opt: GNUNET_CONTAINER_MultiHashMapOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Get the number of key-value pairs in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @return the number of key value pairs"]
    pub fn GNUNET_CONTAINER_multiuuidmap_size(
        map: *const GNUNET_CONTAINER_MultiUuidmap,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multiuuidmap_iterate(
        map: *mut GNUNET_CONTAINER_MultiUuidmap,
        it: GNUNET_CONTAINER_MultiUuidmapIteratorCallback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiUuidmapIterator {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create an iterator for a multihashmap."]
    #[doc = " The iterator can be used to retrieve all the elements in the multihashmap"]
    #[doc = " one by one, without having to handle all elements at once (in contrast to"]
    #[doc = " #GNUNET_CONTAINER_multiuuidmap_iterate).  Note that the iterator can not be"]
    #[doc = " used anymore if elements have been removed from @a map after the creation of"]
    #[doc = " the iterator, or 'map' has been destroyed.  Adding elements to @a map may"]
    #[doc = " result in skipped or repeated elements."]
    #[doc = ""]
    #[doc = " @param map the map to create an iterator for"]
    #[doc = " @return an iterator over the given multihashmap @a map"]
    pub fn GNUNET_CONTAINER_multiuuidmap_iterator_create(
        map: *const GNUNET_CONTAINER_MultiUuidmap,
    ) -> *mut GNUNET_CONTAINER_MultiUuidmapIterator;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Retrieve the next element from the hash map at the iterator's"]
    #[doc = " position.  If there are no elements left, #GNUNET_NO is returned,"]
    #[doc = " and @a key and @a value are not modified.  This operation is only"]
    #[doc = " allowed if no elements have been removed from the multihashmap"]
    #[doc = " since the creation of @a iter, and the map has not been destroyed."]
    #[doc = " Adding elements may result in repeating or skipping elements."]
    #[doc = ""]
    #[doc = " @param iter the iterator to get the next element from"]
    #[doc = " @param key pointer to store the key in, can be NULL"]
    #[doc = " @param value pointer to store the value in, can be NULL"]
    #[doc = " @return #GNUNET_YES we returned an element,"]
    #[doc = "         #GNUNET_NO if we are out of elements"]
    pub fn GNUNET_CONTAINER_multiuuidmap_iterator_next(
        iter: *mut GNUNET_CONTAINER_MultiUuidmapIterator,
        key: *mut GNUNET_Uuid,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a multiuuidmap iterator."]
    #[doc = ""]
    #[doc = " @param iter the iterator to destroy"]
    pub fn GNUNET_CONTAINER_multiuuidmap_iterator_destroy(
        iter: *mut GNUNET_CONTAINER_MultiUuidmapIterator,
    );
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map that match a particular key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key public key that the entries must correspond to"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multiuuidmap_get_multiple(
        map: *mut GNUNET_CONTAINER_MultiUuidmap,
        key: *const GNUNET_Uuid,
        it: GNUNET_CONTAINER_MultiUuidmapIteratorCallback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Call @a it on a random value from the map, or not at all"]
    #[doc = " if the map is empty.  Note that this function has linear"]
    #[doc = " complexity (in the size of the map)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on a random entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed, zero or one."]
    pub fn GNUNET_CONTAINER_multiuuidmap_get_random(
        map: *const GNUNET_CONTAINER_MultiUuidmap,
        it: GNUNET_CONTAINER_MultiUuidmapIteratorCallback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " @ingroup hashmap"]
#[doc = " Opaque handle for the 32-bit key HashMap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiHashMap32 {
    _unused: [u8; 0],
}
#[doc = " @ingroup hashmap"]
#[doc = " Opaque handle to an iterator over"]
#[doc = " a 32-bit key multihashmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_MultiHashMap32Iterator {
    _unused: [u8; 0],
}
#[doc = " @ingroup hashmap"]
#[doc = " Iterator over hash map entries."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param key current key code"]
#[doc = " @param value value in the hash map"]
#[doc = " @return #GNUNET_YES if we should continue to"]
#[doc = "         iterate,"]
#[doc = "         #GNUNET_NO if not."]
pub type GNUNET_CONTAINER_MulitHashMapIterator32Callback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        key: u32,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Create a 32-bit key multi hash map."]
    #[doc = ""]
    #[doc = " @param len initial size (map will grow as needed)"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CONTAINER_multihashmap32_create(
        len: ::std::os::raw::c_uint,
    ) -> *mut GNUNET_CONTAINER_MultiHashMap32;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Destroy a 32-bit key hash map.  Will not free any values"]
    #[doc = " stored in the hash map!"]
    #[doc = ""]
    #[doc = " @param map the map"]
    pub fn GNUNET_CONTAINER_multihashmap32_destroy(map: *mut GNUNET_CONTAINER_MultiHashMap32);
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Get the number of key-value pairs in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @return the number of key value pairs"]
    pub fn GNUNET_CONTAINER_multihashmap32_size(
        map: *const GNUNET_CONTAINER_MultiHashMap32,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Given a key find a value in the map matching the key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key what to look for"]
    #[doc = " @return NULL if no value was found; note that"]
    #[doc = "   this is indistinguishable from values that just"]
    #[doc = "   happen to be NULL; use \"contains\" to test for"]
    #[doc = "   key-value pairs with value NULL"]
    pub fn GNUNET_CONTAINER_multihashmap32_get(
        map: *const GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multihashmap32_iterate(
        map: *mut GNUNET_CONTAINER_MultiHashMap32,
        it: GNUNET_CONTAINER_MulitHashMapIterator32Callback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove the given key-value pair from the map.  Note that if the"]
    #[doc = " key-value pair is in the map multiple times, only one of the pairs"]
    #[doc = " will be removed."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key of the key-value pair"]
    #[doc = " @param value value of the key-value pair"]
    #[doc = " @return #GNUNET_YES on success, #GNUNET_NO if the key-value pair"]
    #[doc = "  is not in the map"]
    pub fn GNUNET_CONTAINER_multihashmap32_remove(
        map: *mut GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Remove all entries for the given key from the map."]
    #[doc = " Note that the values would not be \"freed\"."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key identifies values to be removed"]
    #[doc = " @return number of values removed"]
    pub fn GNUNET_CONTAINER_multihashmap32_remove_all(
        map: *mut GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains any value under the given"]
    #[doc = " key (including values that are NULL)."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multihashmap32_contains(
        map: *const GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Check if the map contains the given value under the given"]
    #[doc = " key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key the key to test if a value exists for it"]
    #[doc = " @param value value to test for"]
    #[doc = " @return #GNUNET_YES if such a value exists,"]
    #[doc = "         #GNUNET_NO if not"]
    pub fn GNUNET_CONTAINER_multihashmap32_contains_value(
        map: *const GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
        value: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Store a key-value pair in the map."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key to use"]
    #[doc = " @param value value to use"]
    #[doc = " @param opt options for put"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_NO if a value was replaced (with REPLACE)"]
    #[doc = "         #GNUNET_SYSERR if #GNUNET_CONTAINER_MULTIHASHMAPOPTION_UNIQUE_ONLY was the option and the"]
    #[doc = "                       value already exists"]
    pub fn GNUNET_CONTAINER_multihashmap32_put(
        map: *mut GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
        value: *mut ::std::os::raw::c_void,
        opt: GNUNET_CONTAINER_MultiHashMapOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup hashmap"]
    #[doc = " Iterate over all entries in the map that match a particular key."]
    #[doc = ""]
    #[doc = " @param map the map"]
    #[doc = " @param key key that the entries must correspond to"]
    #[doc = " @param it function to call on each entry"]
    #[doc = " @param it_cls extra argument to @a it"]
    #[doc = " @return the number of key value pairs processed,"]
    #[doc = "         #GNUNET_SYSERR if it aborted iteration"]
    pub fn GNUNET_CONTAINER_multihashmap32_get_multiple(
        map: *mut GNUNET_CONTAINER_MultiHashMap32,
        key: u32,
        it: GNUNET_CONTAINER_MulitHashMapIterator32Callback,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create an iterator for a 32-bit multihashmap."]
    #[doc = " The iterator can be used to retrieve all the elements in the multihashmap"]
    #[doc = " one by one, without having to handle all elements at once (in contrast to"]
    #[doc = " #GNUNET_CONTAINER_multihashmap32_iterate).  Note that the iterator can not be"]
    #[doc = " used anymore if elements have been removed from 'map' after the creation of"]
    #[doc = " the iterator, or 'map' has been destroyed.  Adding elements to 'map' may"]
    #[doc = " result in skipped or repeated elements."]
    #[doc = ""]
    #[doc = " @param map the map to create an iterator for"]
    #[doc = " @return an iterator over the given multihashmap map"]
    pub fn GNUNET_CONTAINER_multihashmap32_iterator_create(
        map: *const GNUNET_CONTAINER_MultiHashMap32,
    ) -> *mut GNUNET_CONTAINER_MultiHashMap32Iterator;
}
extern "C" {
    #[doc = " Retrieve the next element from the hash map at the iterator's position."]
    #[doc = " If there are no elements left, GNUNET_NO is returned, and 'key' and 'value'"]
    #[doc = " are not modified."]
    #[doc = " This operation is only allowed if no elements have been removed from the"]
    #[doc = " multihashmap since the creation of 'iter', and the map has not been destroyed."]
    #[doc = " Adding elements may result in repeating or skipping elements."]
    #[doc = ""]
    #[doc = " @param iter the iterator to get the next element from"]
    #[doc = " @param key pointer to store the key in, can be NULL"]
    #[doc = " @param value pointer to store the value in, can be NULL"]
    #[doc = " @return #GNUNET_YES we returned an element,"]
    #[doc = "         #GNUNET_NO if we are out of elements"]
    pub fn GNUNET_CONTAINER_multihashmap32_iterator_next(
        iter: *mut GNUNET_CONTAINER_MultiHashMap32Iterator,
        key: *mut u32,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroy a 32-bit multihashmap iterator."]
    #[doc = ""]
    #[doc = " @param iter the iterator to destroy"]
    pub fn GNUNET_CONTAINER_multihashmap32_iterator_destroy(
        iter: *mut GNUNET_CONTAINER_MultiHashMapIterator,
    );
}
#[doc = " @ingroup heap"]
#[doc = " Cost by which elements in a heap can be ordered."]
pub type GNUNET_CONTAINER_HeapCostType = u64;
#[doc = " @ingroup heap"]
#[doc = " Heap with the maximum cost at the root."]
pub const GNUNET_CONTAINER_HeapOrder_GNUNET_CONTAINER_HEAP_ORDER_MAX: GNUNET_CONTAINER_HeapOrder =
    0;
#[doc = " @ingroup heap"]
#[doc = " Heap with the minimum cost at the root."]
pub const GNUNET_CONTAINER_HeapOrder_GNUNET_CONTAINER_HEAP_ORDER_MIN: GNUNET_CONTAINER_HeapOrder =
    1;
#[doc = " @ingroup heap"]
#[doc = " Heap type, either max or min."]
pub type GNUNET_CONTAINER_HeapOrder = ::std::os::raw::c_uint;
#[doc = " @ingroup heap"]
#[doc = " Handle to a Heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_Heap {
    _unused: [u8; 0],
}
#[doc = " @ingroup heap"]
#[doc = " Handle to a node in a heap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CONTAINER_HeapNode {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Create a new heap."]
    #[doc = ""]
    #[doc = " @param order how should the heap be sorted?"]
    #[doc = " @return handle to the heap"]
    pub fn GNUNET_CONTAINER_heap_create(
        order: GNUNET_CONTAINER_HeapOrder,
    ) -> *mut GNUNET_CONTAINER_Heap;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Destroys the heap.  Only call on a heap that"]
    #[doc = " is already empty."]
    #[doc = ""]
    #[doc = " @param heap heap to destroy"]
    pub fn GNUNET_CONTAINER_heap_destroy(heap: *mut GNUNET_CONTAINER_Heap);
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Get element stored at the root of @a heap."]
    #[doc = ""]
    #[doc = " @param heap  Heap to inspect."]
    #[doc = " @return Element at the root, or NULL if heap is empty."]
    pub fn GNUNET_CONTAINER_heap_peek(
        heap: *const GNUNET_CONTAINER_Heap,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get @a element and @a cost stored at the root of @a heap."]
    #[doc = ""]
    #[doc = " @param[in]  heap     Heap to inspect."]
    #[doc = " @param[out] element  Root element is returned here."]
    #[doc = " @param[out] cost     Cost of @a element is returned here."]
    #[doc = " @return #GNUNET_YES if an element is returned,"]
    #[doc = "         #GNUNET_NO  if the heap is empty."]
    pub fn GNUNET_CONTAINER_heap_peek2(
        heap: *const GNUNET_CONTAINER_Heap,
        element: *mut *mut ::std::os::raw::c_void,
        cost: *mut GNUNET_CONTAINER_HeapCostType,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Get the current size of the heap"]
    #[doc = ""]
    #[doc = " @param heap the heap to get the size of"]
    #[doc = " @return number of elements stored"]
    pub fn GNUNET_CONTAINER_heap_get_size(
        heap: *const GNUNET_CONTAINER_Heap,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Get the current cost of the node"]
    #[doc = ""]
    #[doc = " @param node the node to get the cost of"]
    #[doc = " @return cost of the node"]
    pub fn GNUNET_CONTAINER_heap_node_get_cost(
        node: *const GNUNET_CONTAINER_HeapNode,
    ) -> GNUNET_CONTAINER_HeapCostType;
}
#[doc = " @ingroup heap"]
#[doc = " Iterator for heap"]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param node internal node of the heap"]
#[doc = " @param element value stored at the node"]
#[doc = " @param cost cost associated with the node"]
#[doc = " @return #GNUNET_YES if we should continue to iterate,"]
#[doc = "         #GNUNET_NO if not."]
pub type GNUNET_CONTAINER_HeapIterator = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        node: *mut GNUNET_CONTAINER_HeapNode,
        element: *mut ::std::os::raw::c_void,
        cost: GNUNET_CONTAINER_HeapCostType,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Iterate over all entries in the heap."]
    #[doc = ""]
    #[doc = " @param heap the heap"]
    #[doc = " @param iterator function to call on each entry"]
    #[doc = " @param iterator_cls closure for @a iterator"]
    pub fn GNUNET_CONTAINER_heap_iterate(
        heap: *const GNUNET_CONTAINER_Heap,
        iterator: GNUNET_CONTAINER_HeapIterator,
        iterator_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Perform a random walk of the tree.  The walk is biased"]
    #[doc = " towards elements closer to the root of the tree (since"]
    #[doc = " each walk starts at the root and ends at a random leaf)."]
    #[doc = " The heap internally tracks the current position of the"]
    #[doc = " walk."]
    #[doc = ""]
    #[doc = " @param heap heap to walk"]
    #[doc = " @return data stored at the next random node in the walk;"]
    #[doc = "         NULL if the tree is empty."]
    pub fn GNUNET_CONTAINER_heap_walk_get_next(
        heap: *mut GNUNET_CONTAINER_Heap,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Inserts a new element into the heap."]
    #[doc = ""]
    #[doc = " @param heap heap to modify"]
    #[doc = " @param element element to insert"]
    #[doc = " @param cost cost for the element"]
    #[doc = " @return node for the new element"]
    pub fn GNUNET_CONTAINER_heap_insert(
        heap: *mut GNUNET_CONTAINER_Heap,
        element: *mut ::std::os::raw::c_void,
        cost: GNUNET_CONTAINER_HeapCostType,
    ) -> *mut GNUNET_CONTAINER_HeapNode;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Remove root of the heap."]
    #[doc = ""]
    #[doc = " @param heap heap to modify"]
    #[doc = " @return element data stored at the root node"]
    pub fn GNUNET_CONTAINER_heap_remove_root(
        heap: *mut GNUNET_CONTAINER_Heap,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Removes a node from the heap."]
    #[doc = ""]
    #[doc = " @param node node to remove"]
    #[doc = " @return element data stored at the node, NULL if heap is empty"]
    pub fn GNUNET_CONTAINER_heap_remove_node(
        node: *mut GNUNET_CONTAINER_HeapNode,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @ingroup heap"]
    #[doc = " Updates the cost of any node in the tree"]
    #[doc = ""]
    #[doc = " @param node node for which the cost is to be changed"]
    #[doc = " @param new_cost new cost for the node"]
    pub fn GNUNET_CONTAINER_heap_update_cost(
        node: *mut GNUNET_CONTAINER_HeapNode,
        new_cost: GNUNET_CONTAINER_HeapCostType,
    );
}
#[doc = " Handle for buffered reading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_BIO_ReadHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Open a file for reading."]
    #[doc = ""]
    #[doc = " @param fn file name to be opened"]
    #[doc = " @return IO handle on success, NULL on error"]
    pub fn GNUNET_BIO_read_open_file(
        fn_: *const ::std::os::raw::c_char,
    ) -> *mut GNUNET_BIO_ReadHandle;
}
extern "C" {
    #[doc = " Create a handle from an existing allocated buffer."]
    #[doc = ""]
    #[doc = " @param buffer the buffer to use as source"]
    #[doc = " @param size the total size in bytes of the buffer"]
    #[doc = " @return IO handle on success, NULL on error"]
    pub fn GNUNET_BIO_read_open_buffer(
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut GNUNET_BIO_ReadHandle;
}
extern "C" {
    #[doc = " Close an open handle.  Reports if any errors reading"]
    #[doc = " from the file were encountered."]
    #[doc = ""]
    #[doc = " @param h file handle"]
    #[doc = " @param emsg set to the error message"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_BIO_read_close(
        h: *mut GNUNET_BIO_ReadHandle,
        emsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read some contents into a buffer."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param result the buffer to write the result to"]
    #[doc = " @param len the number of bytes to read"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_BIO_read(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read 0-terminated string."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param result where to store the pointer to the (allocated) string"]
    #[doc = "        (note that *result could be set to NULL as well)"]
    #[doc = " @param max_length maximum allowed length for the string"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_BIO_read_string(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        result: *mut *mut ::std::os::raw::c_char,
        max_length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a metadata container."]
    #[doc = ""]
    #[doc = " @param h handle to an open file"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param result the buffer to store a pointer to the (allocated) metadata"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_BIO_read_meta_data(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        result: *mut *mut GNUNET_CONTAINER_MetaData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a float."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param f address of float to read"]
    pub fn GNUNET_BIO_read_float(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        f: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a double."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param f address of double to read"]
    pub fn GNUNET_BIO_read_double(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        f: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an (u)int32_t."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param i where to store the data"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_read_int32(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        i: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an (u)int64_t."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param i where to store the data"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_read_int64(
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        i: *mut i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Handle for buffered writing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_BIO_WriteHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Open a file for writing."]
    #[doc = ""]
    #[doc = " @param fn name of the file to be opened"]
    #[doc = " @return IO handle on success, NULL on error"]
    pub fn GNUNET_BIO_write_open_file(
        fn_: *const ::std::os::raw::c_char,
    ) -> *mut GNUNET_BIO_WriteHandle;
}
extern "C" {
    #[doc = " Create a handle backed by an in-memory buffer."]
    #[doc = ""]
    #[doc = " @return IO handle on success, NULL on error"]
    pub fn GNUNET_BIO_write_open_buffer() -> *mut GNUNET_BIO_WriteHandle;
}
extern "C" {
    #[doc = " Force a file-based buffered writer to flush its buffer."]
    #[doc = " If the handle does not use a file, this function returns #GNUNET_OK"]
    #[doc = " without doing anything."]
    #[doc = ""]
    #[doc = " @param h the IO handle"]
    #[doc = " @return #GNUNET_OK upon success.  Upon failure #GNUNET_SYSERR is returned"]
    #[doc = "         and the file is closed"]
    pub fn GNUNET_BIO_flush(h: *mut GNUNET_BIO_WriteHandle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the IO handle's contents."]
    #[doc = " If the handle doesn't use an in-memory buffer, this function returns"]
    #[doc = " #GNUNET_SYSERR."]
    #[doc = ""]
    #[doc = " @param h the IO handle"]
    #[doc = " @param emsg set to the (allocated) error message"]
    #[doc = "        if the handle has an error message the return value is #GNUNET_SYSERR"]
    #[doc = " @param contents where to store the pointer to the handle's contents"]
    #[doc = " @param size where to store the size of @e contents"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_BIO_get_buffer_contents(
        h: *mut GNUNET_BIO_WriteHandle,
        emsg: *mut *mut ::std::os::raw::c_char,
        contents: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close an IO handle."]
    #[doc = " If the handle was using a file, the file will be closed."]
    #[doc = ""]
    #[doc = " @param h file handle"]
    #[doc = " @param emsg set to the (allocated) error message"]
    #[doc = "        if the handle has an error message, the return value is #GNUNET_SYSERR"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_BIO_write_close(
        h: *mut GNUNET_BIO_WriteHandle,
        emsg: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a buffer to a handle."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param buffer the data to write"]
    #[doc = " @param n number of bytes to write"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_write(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_void,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a 0-terminated string."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param s string to write (can be NULL)"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_write_string(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a metadata container."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param m metadata to write"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_write_meta_data(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        m: *const GNUNET_CONTAINER_MetaData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a float."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param f float to write (must be a variable)"]
    pub fn GNUNET_BIO_write_float(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        f: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a double."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param f double to write (must be a variable)"]
    pub fn GNUNET_BIO_write_double(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        f: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an (u)int32_t."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param i 32-bit integer to write"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_write_int32(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        i: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an (u)int64_t."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param i 64-bit integer to write"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_BIO_write_int64(
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        i: i64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function used to deserialize data read from @a h and store it into @a"]
#[doc = " target."]
#[doc = ""]
#[doc = " @param cls closure (can be NULL)"]
#[doc = " @param h the IO handle to read from"]
#[doc = " @param what what is being read (for error message creation)"]
#[doc = " @param target where to store the data"]
#[doc = " @param target_size how many bytes can be written in @a target"]
#[doc = "        can be 0 if the size is unknown or is not fixed"]
#[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
pub type GNUNET_BIO_ReadHandler = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        h: *mut GNUNET_BIO_ReadHandle,
        what: *const ::std::os::raw::c_char,
        target: *mut ::std::os::raw::c_void,
        target_size: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure specifying a reading operation on an IO handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_BIO_ReadSpec {
    #[doc = " Function performing data deserialization."]
    pub rh: GNUNET_BIO_ReadHandler,
    #[doc = " Closure for @e rh. Can be NULL."]
    pub cls: *mut ::std::os::raw::c_void,
    #[doc = " What is being read (for error message creation)"]
    pub what: *const ::std::os::raw::c_char,
    #[doc = " Destination buffer. Can also be a pointer to a pointer, especially for"]
    #[doc = " dynamically allocated structures."]
    pub target: *mut ::std::os::raw::c_void,
    #[doc = " Size of @e target. Can be 0 if unknown or not fixed."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_GNUNET_BIO_ReadSpec() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_BIO_ReadSpec>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_BIO_ReadSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_BIO_ReadSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_BIO_ReadSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_ReadSpec>())).rh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_ReadSpec),
            "::",
            stringify!(rh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_ReadSpec>())).cls as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_ReadSpec),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_ReadSpec>())).what as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_ReadSpec),
            "::",
            stringify!(what)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_ReadSpec>())).target as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_ReadSpec),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_ReadSpec>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_ReadSpec),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = " Create the specification to read a certain amount of bytes."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param result the buffer to write the result to"]
    #[doc = " @param len the number of bytes to read"]
    #[doc = " @return the read spec"]
    pub fn GNUNET_BIO_read_spec_object(
        what: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Create the specification to read a 0-terminated string."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param result where to store the pointer to the (allocated) string"]
    #[doc = "        (note that *result could be set to NULL as well)"]
    #[doc = " @param max_length maximum allowed length for the string"]
    #[doc = " @return the read spec"]
    pub fn GNUNET_BIO_read_spec_string(
        what: *const ::std::os::raw::c_char,
        result: *mut *mut ::std::os::raw::c_char,
        max_length: usize,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Create the specification to read a metadata container."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param result the buffer to store a pointer to the (allocated) metadata"]
    #[doc = " @return the read spec"]
    pub fn GNUNET_BIO_read_spec_meta_data(
        what: *const ::std::os::raw::c_char,
        result: *mut *mut GNUNET_CONTAINER_MetaData,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Create the specification to read an (u)int32_t."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param i where to store the data"]
    #[doc = " @return the read spec"]
    pub fn GNUNET_BIO_read_spec_int32(
        what: *const ::std::os::raw::c_char,
        i: *mut i32,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Create the specification to read an (u)int64_t."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param i where to store the data"]
    #[doc = " @return the read spec"]
    pub fn GNUNET_BIO_read_spec_int64(
        what: *const ::std::os::raw::c_char,
        i: *mut i64,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Create the specification to read a float."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param f address of float to read"]
    pub fn GNUNET_BIO_read_spec_float(
        what: *const ::std::os::raw::c_char,
        f: *mut f32,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Create the specification to read a double."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param f address of double to read"]
    pub fn GNUNET_BIO_read_spec_double(
        what: *const ::std::os::raw::c_char,
        f: *mut f64,
    ) -> GNUNET_BIO_ReadSpec;
}
extern "C" {
    #[doc = " Execute the read specifications in order."]
    #[doc = ""]
    #[doc = " @param h the IO handle to read from"]
    #[doc = " @param rs array of read specs"]
    #[doc = "        the last element must be #GNUNET_BIO_read_spec_end"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_BIO_read_spec_commit(
        h: *mut GNUNET_BIO_ReadHandle,
        rs: *mut GNUNET_BIO_ReadSpec,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Function used to serialize data from a buffer and write it to @a h."]
#[doc = ""]
#[doc = " @param cls closure (can be NULL)"]
#[doc = " @param h the IO handle to write to"]
#[doc = " @param what what is being written (for error message creation)"]
#[doc = " @param source the data to write"]
#[doc = " @param source_size how many bytes should be written"]
#[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
pub type GNUNET_BIO_WriteHandler = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        h: *mut GNUNET_BIO_WriteHandle,
        what: *const ::std::os::raw::c_char,
        source: *mut ::std::os::raw::c_void,
        source_size: usize,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure specifying a writing operation on an IO handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_BIO_WriteSpec {
    #[doc = " Function performing data serialization."]
    pub wh: GNUNET_BIO_WriteHandler,
    #[doc = " Closure for @e rh. Can be NULL."]
    pub cls: *mut ::std::os::raw::c_void,
    #[doc = " What is being read (for error message creation)"]
    pub what: *const ::std::os::raw::c_char,
    #[doc = " Source buffer. The data in this buffer will be written to the handle."]
    pub source: *mut ::std::os::raw::c_void,
    #[doc = " Size of @e source. If it's smaller than the real size of @e source, only"]
    #[doc = " this many bytes will be written."]
    pub source_size: usize,
}
#[test]
fn bindgen_test_layout_GNUNET_BIO_WriteSpec() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_BIO_WriteSpec>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_BIO_WriteSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_BIO_WriteSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_BIO_WriteSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_WriteSpec>())).wh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_WriteSpec),
            "::",
            stringify!(wh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_WriteSpec>())).cls as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_WriteSpec),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_WriteSpec>())).what as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_WriteSpec),
            "::",
            stringify!(what)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_BIO_WriteSpec>())).source as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_WriteSpec),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_BIO_WriteSpec>())).source_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_BIO_WriteSpec),
            "::",
            stringify!(source_size)
        )
    );
}
extern "C" {
    #[doc = " Create the specification to read some bytes."]
    #[doc = ""]
    #[doc = " @param what describes what is being written (for error message creation)"]
    #[doc = " @param source the data to write"]
    #[doc = " @param size how many bytes should be written"]
    #[doc = " @return the write spec"]
    pub fn GNUNET_BIO_write_spec_object(
        what: *const ::std::os::raw::c_char,
        source: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Create the specification to write a 0-terminated string."]
    #[doc = ""]
    #[doc = " @param what describes what is being read (for error message creation)"]
    #[doc = " @param s string to write (can be NULL)"]
    #[doc = " @return the read spec"]
    pub fn GNUNET_BIO_write_spec_string(
        what: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Create the specification to write a metadata container."]
    #[doc = ""]
    #[doc = " @param what what is being written (for error message creation)"]
    #[doc = " @param m metadata to write"]
    #[doc = " @return the write spec"]
    pub fn GNUNET_BIO_write_spec_meta_data(
        what: *const ::std::os::raw::c_char,
        m: *const GNUNET_CONTAINER_MetaData,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Create the specification to write an (u)int32_t."]
    #[doc = ""]
    #[doc = " @param what describes what is being written (for error message creation)"]
    #[doc = " @param i pointer to a 32-bit integer"]
    #[doc = " @return the write spec"]
    pub fn GNUNET_BIO_write_spec_int32(
        what: *const ::std::os::raw::c_char,
        i: *mut i32,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Create the specification to write an (u)int64_t."]
    #[doc = ""]
    #[doc = " @param what describes what is being written (for error message creation)"]
    #[doc = " @param i pointer to a 64-bit integer"]
    #[doc = " @return the write spec"]
    pub fn GNUNET_BIO_write_spec_int64(
        what: *const ::std::os::raw::c_char,
        i: *mut i64,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Create the specification to write a float."]
    #[doc = ""]
    #[doc = " @param what describes what is being written (for error message creation)"]
    #[doc = " @param f pointer to a float"]
    #[doc = " @return the write spec"]
    pub fn GNUNET_BIO_write_spec_float(
        what: *const ::std::os::raw::c_char,
        f: *mut f32,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Create the specification to write an double."]
    #[doc = ""]
    #[doc = " @param what describes what is being written (for error message creation)"]
    #[doc = " @param f pointer to a double"]
    #[doc = " @return the write spec"]
    pub fn GNUNET_BIO_write_spec_double(
        what: *const ::std::os::raw::c_char,
        f: *mut f64,
    ) -> GNUNET_BIO_WriteSpec;
}
extern "C" {
    #[doc = " Execute the write specifications in order."]
    #[doc = ""]
    #[doc = " @param h the IO handle to write to"]
    #[doc = " @param ws array of write specs"]
    #[doc = "        the last element must be #GNUNET_BIO_write_spec_end"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_BIO_write_spec_commit(
        h: *mut GNUNET_BIO_WriteHandle,
        ws: *mut GNUNET_BIO_WriteSpec,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Dynamically growing buffer.  Can be used to construct"]
#[doc = " strings and other objects with dynamic size."]
#[doc = ""]
#[doc = " This structure should, in most cases, be stack-allocated and"]
#[doc = " zero-initialized, like:"]
#[doc = ""]
#[doc = "   struct GNUNET_Buffer my_buffer = { 0 };"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_Buffer {
    #[doc = " Capacity of the buffer."]
    pub capacity: usize,
    #[doc = " Current write position."]
    pub position: usize,
    #[doc = " Backing memory."]
    pub mem: *mut ::std::os::raw::c_char,
    #[doc = " Log a warning if the buffer is grown over its initially allocated capacity."]
    pub warn_grow: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GNUNET_Buffer() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_Buffer>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_Buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_Buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_Buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_Buffer>())).capacity as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_Buffer),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_Buffer>())).position as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_Buffer),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_Buffer>())).mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_Buffer),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_Buffer>())).warn_grow as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_Buffer),
            "::",
            stringify!(warn_grow)
        )
    );
}
extern "C" {
    #[doc = " Initialize a buffer with the given capacity."]
    #[doc = ""]
    #[doc = " When a buffer is allocated with this function, a warning is logged"]
    #[doc = " when the buffer exceeds the initial capacity."]
    #[doc = ""]
    #[doc = " @param buf the buffer to initialize"]
    #[doc = " @param capacity the capacity (in bytes) to allocate for @a buf"]
    pub fn GNUNET_buffer_prealloc(buf: *mut GNUNET_Buffer, capacity: usize);
}
extern "C" {
    #[doc = " Make sure that at least @a n bytes remaining in the buffer."]
    #[doc = ""]
    #[doc = " @param buf buffer to potentially grow"]
    #[doc = " @param n number of bytes that should be available to write"]
    pub fn GNUNET_buffer_ensure_remaining(buf: *mut GNUNET_Buffer, n: usize);
}
extern "C" {
    #[doc = " Write bytes to the buffer."]
    #[doc = ""]
    #[doc = " Grows the buffer if necessary."]
    #[doc = ""]
    #[doc = " @param buf buffer to write to"]
    #[doc = " @param data data to read from"]
    #[doc = " @param len number of bytes to copy from @a data to @a buf"]
    #[doc = ""]
    pub fn GNUNET_buffer_write(
        buf: *mut GNUNET_Buffer,
        data: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    #[doc = " Write a 0-terminated string to a buffer, excluding the 0-terminator."]
    #[doc = ""]
    #[doc = " Grows the buffer if necessary."]
    #[doc = ""]
    #[doc = " @param buf the buffer to write to"]
    #[doc = " @param str the string to write to @a buf"]
    pub fn GNUNET_buffer_write_str(buf: *mut GNUNET_Buffer, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Write data encoded via #GNUNET_STRINGS_data_to_string to the buffer."]
    #[doc = ""]
    #[doc = " Grows the buffer if necessary."]
    #[doc = ""]
    #[doc = " @param buf buffer to write to"]
    #[doc = " @param data data to read from"]
    #[doc = " @param data_len number of bytes to copy from @a data to @a buf"]
    pub fn GNUNET_buffer_write_data_encoded(
        buf: *mut GNUNET_Buffer,
        data: *const ::std::os::raw::c_void,
        data_len: usize,
    );
}
extern "C" {
    #[doc = " Write a path component to a buffer, ensuring that"]
    #[doc = " there is exactly one slash between the previous contents"]
    #[doc = " of the buffer and the new string."]
    #[doc = ""]
    #[doc = " @param buf buffer to write to"]
    #[doc = " @param str string containing the new path component"]
    pub fn GNUNET_buffer_write_path(buf: *mut GNUNET_Buffer, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Write a 0-terminated formatted string to a buffer, excluding the"]
    #[doc = " 0-terminator."]
    #[doc = ""]
    #[doc = " Grows the buffer if necessary."]
    #[doc = ""]
    #[doc = " @param buf the buffer to write to"]
    #[doc = " @param fmt format string"]
    #[doc = " @param ... format arguments"]
    pub fn GNUNET_buffer_write_fstr(
        buf: *mut GNUNET_Buffer,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Write a 0-terminated formatted string to a buffer, excluding the"]
    #[doc = " 0-terminator."]
    #[doc = ""]
    #[doc = " Grows the buffer if necessary."]
    #[doc = ""]
    #[doc = " @param buf the buffer to write to"]
    #[doc = " @param fmt format string"]
    #[doc = " @param args format argument list"]
    pub fn GNUNET_buffer_write_vfstr(
        buf: *mut GNUNET_Buffer,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[doc = " Clear the buffer and return the string it contained."]
    #[doc = " The caller is responsible to eventually #GNUNET_free"]
    #[doc = " the returned string."]
    #[doc = ""]
    #[doc = " The returned string is always 0-terminated."]
    #[doc = ""]
    #[doc = " @param buf the buffer to reap the string from"]
    #[doc = " @returns the buffer contained in the string"]
    pub fn GNUNET_buffer_reap_str(buf: *mut GNUNET_Buffer) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Clear the buffer and return its contents."]
    #[doc = " The caller is responsible to eventually #GNUNET_free"]
    #[doc = " the returned data."]
    #[doc = ""]
    #[doc = " @param buf the buffer to reap the contents from"]
    #[doc = " @param size where to store the size of the returned data"]
    #[doc = " @returns the data contained in the string"]
    pub fn GNUNET_buffer_reap(
        buf: *mut GNUNET_Buffer,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free the backing memory of the given buffer."]
    #[doc = " Does not free the memory of the buffer control structure,"]
    #[doc = " which is typically stack-allocated."]
    pub fn GNUNET_buffer_clear(buf: *mut GNUNET_Buffer);
}
#[doc = " Opaque reference to a task."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SCHEDULER_Task {
    _unused: [u8; 0],
}
#[doc = " This task is not ready."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_NONE: GNUNET_SCHEDULER_Reason = 0;
#[doc = " This is the very first task run during startup."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_STARTUP: GNUNET_SCHEDULER_Reason = 1;
#[doc = " We are shutting down and are running all shutdown-related tasks."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_SHUTDOWN: GNUNET_SCHEDULER_Reason = 2;
#[doc = " The specified timeout has expired."]
#[doc = " (also set if the delay given was 0)."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_TIMEOUT: GNUNET_SCHEDULER_Reason = 4;
#[doc = " The reading socket is ready."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_READ_READY: GNUNET_SCHEDULER_Reason = 8;
#[doc = " The writing socket is ready."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_WRITE_READY: GNUNET_SCHEDULER_Reason = 16;
#[doc = " The prerequisite task is done."]
pub const GNUNET_SCHEDULER_Reason_GNUNET_SCHEDULER_REASON_PREREQ_DONE: GNUNET_SCHEDULER_Reason = 32;
#[doc = " Reasons why the schedule may have triggered"]
#[doc = " the task now."]
pub type GNUNET_SCHEDULER_Reason = ::std::os::raw::c_uint;
#[doc = " @brief handle to a socket"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_NETWORK_Handle {
    _unused: [u8; 0],
}
#[doc = " @brief collection of IO descriptors"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_NETWORK_FDSet {
    #[doc = " Maximum number of any socket descriptor in the set (plus one)"]
    pub nsds: ::std::os::raw::c_int,
    #[doc = " Bitset with the descriptors."]
    pub sds: fd_set,
}
#[test]
fn bindgen_test_layout_GNUNET_NETWORK_FDSet() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_NETWORK_FDSet>(),
        136usize,
        concat!("Size of: ", stringify!(GNUNET_NETWORK_FDSet))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_NETWORK_FDSet>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_NETWORK_FDSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_NETWORK_FDSet>())).nsds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_NETWORK_FDSet),
            "::",
            stringify!(nsds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_NETWORK_FDSet>())).sds as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_NETWORK_FDSet),
            "::",
            stringify!(sds)
        )
    );
}
#[doc = " Handle used to manage a pipe."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DISK_PipeHandle {
    _unused: [u8; 0],
}
#[doc = " Handle represents an event."]
pub const GNUNET_FILE_Type_GNUNET_DISK_HANLDE_TYPE_EVENT: GNUNET_FILE_Type = 0;
#[doc = " Handle represents a file."]
pub const GNUNET_FILE_Type_GNUNET_DISK_HANLDE_TYPE_FILE: GNUNET_FILE_Type = 1;
#[doc = " Handle represents a pipe."]
pub const GNUNET_FILE_Type_GNUNET_DISK_HANLDE_TYPE_PIPE: GNUNET_FILE_Type = 2;
#[doc = " Type of a handle."]
pub type GNUNET_FILE_Type = ::std::os::raw::c_uint;
#[doc = " Handle used to access files (and pipes)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DISK_FileHandle {
    #[doc = " File handle on Unix-like systems."]
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GNUNET_DISK_FileHandle() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DISK_FileHandle>(),
        4usize,
        concat!("Size of: ", stringify!(GNUNET_DISK_FileHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DISK_FileHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_DISK_FileHandle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DISK_FileHandle>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DISK_FileHandle),
            "::",
            stringify!(fd)
        )
    );
}
extern "C" {
    #[doc = " Create a new configuration object."]
    #[doc = " @return fresh configuration object"]
    pub fn GNUNET_CONFIGURATION_create() -> *mut GNUNET_CONFIGURATION_Handle;
}
extern "C" {
    #[doc = " Duplicate an existing configuration object."]
    #[doc = ""]
    #[doc = " @param cfg configuration to duplicate"]
    #[doc = " @return duplicate configuration"]
    pub fn GNUNET_CONFIGURATION_dup(
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ) -> *mut GNUNET_CONFIGURATION_Handle;
}
extern "C" {
    #[doc = " Destroy configuration object."]
    #[doc = ""]
    #[doc = " @param cfg configuration to destroy"]
    pub fn GNUNET_CONFIGURATION_destroy(cfg: *mut GNUNET_CONFIGURATION_Handle);
}
extern "C" {
    #[doc = " Load configuration.  This function will first parse the"]
    #[doc = " defaults and then parse the specific configuration file"]
    #[doc = " to overwrite the defaults."]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param filename name of the configuration file, NULL to load defaults"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_load(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Load default configuration.  This function will parse the"]
    #[doc = " defaults from the given @a defaults_d directory."]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param defaults_d directory with the defaults"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_load_from(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        defaults_d: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Return GNUnet's default configuration.  A new configuration is allocated"]
    #[doc = " each time and it's up to the caller to destroy it when done.  This function"]
    #[doc = " returns GNUnet's configuration even when #GNUNET_OS_init has been called"]
    #[doc = " with a value different from #GNUNET_OS_project_data_default."]
    #[doc = ""]
    #[doc = " @return a freshly allocated configuration"]
    pub fn GNUNET_CONFIGURATION_default() -> *mut GNUNET_CONFIGURATION_Handle;
}
extern "C" {
    #[doc = " Parse a configuration file, add all of the options in the"]
    #[doc = " file to the configuration environment."]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param filename name of the configuration file"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_parse(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Serializes the given configuration."]
    #[doc = ""]
    #[doc = " @param cfg configuration to serialize"]
    #[doc = " @param size will be set to the size of the serialized memory block"]
    #[doc = " @return the memory block where the serialized configuration is"]
    #[doc = "           present. This memory should be freed by the caller"]
    pub fn GNUNET_CONFIGURATION_serialize(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " De-serializes configuration"]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param mem the memory block of serialized configuration"]
    #[doc = " @param size the size of the memory block"]
    #[doc = " @param allow_inline set to the base directory if we recursively load configuration"]
    #[doc = "          from inlined configurations; NULL if not and raise warnings"]
    #[doc = "          when we come across them"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_deserialize(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        mem: *const ::std::os::raw::c_char,
        size: usize,
        basedir: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Write configuration file."]
    #[doc = ""]
    #[doc = " @param cfg configuration to write"]
    #[doc = " @param filename where to write the configuration"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_write(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Write only configuration entries that have been changed to configuration file"]
    #[doc = ""]
    #[doc = " @param cfg_default default configuration"]
    #[doc = " @param cfg_new new configuration"]
    #[doc = " @param filename where to write the configuration diff between default and new"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_write_diffs(
        cfg_default: *const GNUNET_CONFIGURATION_Handle,
        cfg_new: *const GNUNET_CONFIGURATION_Handle,
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Compute configuration with only entries that have been changed"]
    #[doc = ""]
    #[doc = " @param cfg_default original configuration"]
    #[doc = " @param cfg_new new configuration"]
    #[doc = " @return configuration with only the differences, never NULL"]
    pub fn GNUNET_CONFIGURATION_get_diff(
        cfg_default: *const GNUNET_CONFIGURATION_Handle,
        cfg_new: *const GNUNET_CONFIGURATION_Handle,
    ) -> *mut GNUNET_CONFIGURATION_Handle;
}
extern "C" {
    #[doc = " Test if there are configuration options that were"]
    #[doc = " changed since the last save."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @return #GNUNET_NO if clean, #GNUNET_YES if dirty, #GNUNET_SYSERR on error (i.e. last save failed)"]
    pub fn GNUNET_CONFIGURATION_is_dirty(
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Signature of a function to be run with a configuration."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param cfg the configuration"]
#[doc = " @return status code"]
pub type GNUNET_CONFIGURATION_Callback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ) -> GNUNET_GenericReturnValue,
>;
extern "C" {
    #[doc = " Parse a configuration file @a filename and run the function"]
    #[doc = " @a cb with the resulting configuration object. Then free the"]
    #[doc = " configuration object and return the status value from @a cb."]
    #[doc = ""]
    #[doc = " @param filename configuration to parse, NULL for \"default\""]
    #[doc = " @param cb function to run"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return #GNUNET_SYSERR if parsing the configuration failed,"]
    #[doc = "   otherwise return value from @a cb."]
    pub fn GNUNET_CONFIGURATION_parse_and_run(
        filename: *const ::std::os::raw::c_char,
        cb: GNUNET_CONFIGURATION_Callback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Function to iterate over options."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param section name of the section"]
#[doc = " @param option name of the option"]
#[doc = " @param value value of the option"]
pub type GNUNET_CONFIGURATION_Iterator = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Function to iterate over section."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param section name of the section"]
pub type GNUNET_CONFIGURATION_Section_Iterator = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, section: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Iterate over all options in the configuration."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param iter function to call on each option"]
    #[doc = " @param iter_cls closure for @a iter"]
    pub fn GNUNET_CONFIGURATION_iterate(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        iter: GNUNET_CONFIGURATION_Iterator,
        iter_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Iterate over all sections in the configuration."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param iter function to call on each section"]
    #[doc = " @param iter_cls closure for @a iter"]
    pub fn GNUNET_CONFIGURATION_iterate_sections(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        iter: GNUNET_CONFIGURATION_Section_Iterator,
        iter_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Remove the given section and all options in it."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section name of the section to remove"]
    pub fn GNUNET_CONFIGURATION_remove_section(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Get a configuration value that should be a number."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param number where to store the numeric value of the option"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_number(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        number: *mut ::std::os::raw::c_ulonglong,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get a configuration value that should be a floating point number."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param number where to store the floating value of the option"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_float(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        number: *mut f32,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get a configuration value that should be a relative time."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param time set to the time value stored in the configuration"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_time(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        time: *mut GNUNET_TIME_Relative,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get a configuration value that should be a size in bytes."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param size set to the size in bytes as stored in the configuration"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_size(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_ulonglong,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Test if we have a value for a particular option"]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @return #GNUNET_YES if so, #GNUNET_NO if not."]
    pub fn GNUNET_CONFIGURATION_have_value(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get a configuration value that should be a string."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param value will be set to a freshly allocated configuration"]
    #[doc = "        value, or NULL if option is not specified"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_string(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get a configuration value that should be the name of a file"]
    #[doc = " or directory."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param value will be set to a freshly allocated configuration"]
    #[doc = "        value, or NULL if option is not specified"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_filename(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Iterate over the set of filenames stored in a configuration value."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param cb function to call on each filename"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return number of filenames iterated over, -1 on error"]
    pub fn GNUNET_CONFIGURATION_iterate_value_filenames(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        cb: GNUNET_FileNameCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Iterate over values of a section in the configuration."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section the section"]
    #[doc = " @param iter function to call on each option"]
    #[doc = " @param iter_cls closure for @a iter"]
    pub fn GNUNET_CONFIGURATION_iterate_section_values(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        iter: GNUNET_CONFIGURATION_Iterator,
        iter_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get a configuration value that should be in a set of"]
    #[doc = " predefined strings"]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param choices NULL-terminated list of legal values"]
    #[doc = " @param value will be set to an entry in the legal list,"]
    #[doc = "        or NULL if option is not specified and no default given"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_CONFIGURATION_get_value_choice(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        choices: *const *const ::std::os::raw::c_char,
        value: *mut *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get a configuration value that should be in a set of"]
    #[doc = " \"YES\" or \"NO\"."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @return #GNUNET_YES, #GNUNET_NO or if option has no valid value, #GNUNET_SYSERR"]
    pub fn GNUNET_CONFIGURATION_get_value_yesno(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get Crockford32-encoded fixed-size binary data from a configuration."]
    #[doc = ""]
    #[doc = " @param cfg configuration to access"]
    #[doc = " @param section section to access"]
    #[doc = " @param option option to access"]
    #[doc = " @param buf where to store the decoded binary result"]
    #[doc = " @param buf_size exact number of bytes to store in @a buf"]
    #[doc = " @return #GNUNET_OK on success"]
    #[doc = "         #GNUNET_NO is the value does not exist"]
    #[doc = "         #GNUNET_SYSERR on decoding error"]
    pub fn GNUNET_CONFIGURATION_get_data(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_void,
        buf_size: usize,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Expand an expression of the form \"$FOO/BAR\" to \"DIRECTORY/BAR\""]
    #[doc = " where either in the \"PATHS\" section or the environment \"FOO\" is"]
    #[doc = " set to \"DIRECTORY\".  We also support default expansion,"]
    #[doc = " i.e. ${VARIABLE:-default} will expand to $VARIABLE if VARIABLE is"]
    #[doc = " set in PATHS or the environment, and otherwise to \"default\".  Note"]
    #[doc = " that \"default\" itself can also be a $-expression, thus"]
    #[doc = " \"${VAR1:-{$VAR2}}\" will expand to VAR1 and if that is not defined"]
    #[doc = " to VAR2."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use for path expansion"]
    #[doc = " @param orig string to $-expand (will be freed!)  Note that multiple"]
    #[doc = "          $-expressions can be present in this string.  They will all be"]
    #[doc = "          $-expanded."]
    #[doc = " @return $-expanded string"]
    pub fn GNUNET_CONFIGURATION_expand_dollar(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        orig: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set a configuration value that should be a number."]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param number value to set"]
    pub fn GNUNET_CONFIGURATION_set_value_number(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        number: ::std::os::raw::c_ulonglong,
    );
}
extern "C" {
    #[doc = " Set a configuration value that should be a string."]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param value value to set"]
    pub fn GNUNET_CONFIGURATION_set_value_string(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Remove a filename from a configuration value that"]
    #[doc = " represents a list of filenames"]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param value filename to remove"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_SYSERR if the filename is not in the list"]
    pub fn GNUNET_CONFIGURATION_remove_value_filename(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Append a filename to a configuration value that"]
    #[doc = " represents a list of filenames"]
    #[doc = ""]
    #[doc = " @param cfg configuration to update"]
    #[doc = " @param section section of interest"]
    #[doc = " @param option option of interest"]
    #[doc = " @param value filename to append"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_SYSERR if the filename already in the list"]
    pub fn GNUNET_CONFIGURATION_append_value_filename(
        cfg: *mut GNUNET_CONFIGURATION_Handle,
        section: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Open the file for reading"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_READ: GNUNET_DISK_OpenFlags = 1;
#[doc = " Open the file for writing"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_WRITE: GNUNET_DISK_OpenFlags = 2;
#[doc = " Open the file for both reading and writing"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_READWRITE: GNUNET_DISK_OpenFlags = 3;
#[doc = " Fail if file already exists"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_FAILIFEXISTS: GNUNET_DISK_OpenFlags = 4;
#[doc = " Truncate file if it exists"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_TRUNCATE: GNUNET_DISK_OpenFlags = 8;
#[doc = " Create file if it doesn't exist"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_CREATE: GNUNET_DISK_OpenFlags = 16;
#[doc = " Append to the file"]
pub const GNUNET_DISK_OpenFlags_GNUNET_DISK_OPEN_APPEND: GNUNET_DISK_OpenFlags = 32;
#[doc = " Specifies how a file should be opened."]
pub type GNUNET_DISK_OpenFlags = ::std::os::raw::c_uint;
#[doc = " Read-only memory map."]
pub const GNUNET_DISK_MapType_GNUNET_DISK_MAP_TYPE_READ: GNUNET_DISK_MapType = 1;
#[doc = " Write-able memory map."]
pub const GNUNET_DISK_MapType_GNUNET_DISK_MAP_TYPE_WRITE: GNUNET_DISK_MapType = 2;
#[doc = " Read-write memory map."]
pub const GNUNET_DISK_MapType_GNUNET_DISK_MAP_TYPE_READWRITE: GNUNET_DISK_MapType = 3;
#[doc = " Specifies what type of memory map is desired."]
pub type GNUNET_DISK_MapType = ::std::os::raw::c_uint;
#[doc = " Nobody is allowed to do anything to the file."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_NONE: GNUNET_DISK_AccessPermissions = 0;
#[doc = " Owner can read."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_USER_READ: GNUNET_DISK_AccessPermissions =
    1;
#[doc = " Owner can write."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_USER_WRITE: GNUNET_DISK_AccessPermissions =
    2;
#[doc = " Owner can execute."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_USER_EXEC: GNUNET_DISK_AccessPermissions =
    4;
#[doc = " Group can read."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_GROUP_READ: GNUNET_DISK_AccessPermissions =
    8;
#[doc = " Group can write."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_GROUP_WRITE:
    GNUNET_DISK_AccessPermissions = 16;
#[doc = " Group can execute."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_GROUP_EXEC: GNUNET_DISK_AccessPermissions =
    32;
#[doc = " Everybody can read."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_OTHER_READ: GNUNET_DISK_AccessPermissions =
    64;
#[doc = " Everybody can write."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_OTHER_WRITE:
    GNUNET_DISK_AccessPermissions = 128;
#[doc = " Everybody can execute."]
pub const GNUNET_DISK_AccessPermissions_GNUNET_DISK_PERM_OTHER_EXEC: GNUNET_DISK_AccessPermissions =
    256;
#[doc = " File access permissions, UNIX-style."]
pub type GNUNET_DISK_AccessPermissions = ::std::os::raw::c_uint;
#[doc = " Seek an absolute position (from the start of the file)."]
pub const GNUNET_DISK_Seek_GNUNET_DISK_SEEK_SET: GNUNET_DISK_Seek = 0;
#[doc = " Seek a relative position (from the current offset)."]
pub const GNUNET_DISK_Seek_GNUNET_DISK_SEEK_CUR: GNUNET_DISK_Seek = 1;
#[doc = " Seek an absolute position from the end of the file."]
pub const GNUNET_DISK_Seek_GNUNET_DISK_SEEK_END: GNUNET_DISK_Seek = 2;
#[doc = " Constants for specifying how to seek.  Do not change values or order,"]
#[doc = " some of the code depends on the specific numeric values!"]
pub type GNUNET_DISK_Seek = ::std::os::raw::c_uint;
#[doc = " The reading-end of a pipe."]
pub const GNUNET_DISK_PipeEnd_GNUNET_DISK_PIPE_END_READ: GNUNET_DISK_PipeEnd = 0;
#[doc = " The writing-end of a pipe."]
pub const GNUNET_DISK_PipeEnd_GNUNET_DISK_PIPE_END_WRITE: GNUNET_DISK_PipeEnd = 1;
#[doc = " Enumeration identifying the two ends of a pipe."]
pub type GNUNET_DISK_PipeEnd = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Checks whether a handle is invalid"]
    #[doc = ""]
    #[doc = " @param h handle to check"]
    #[doc = " @return #GNUNET_YES if invalid, #GNUNET_NO if valid"]
    pub fn GNUNET_DISK_handle_invalid(
        h: *const GNUNET_DISK_FileHandle,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Check that fil corresponds to a filename"]
    #[doc = " (of a file that exists and that is not a directory)."]
    #[doc = ""]
    #[doc = " @param fil filename to check"]
    #[doc = " @return #GNUNET_YES if yes, #GNUNET_NO if not a file, #GNUNET_SYSERR if something"]
    #[doc = " else (will print an error message in that case, too)."]
    pub fn GNUNET_DISK_file_test(fil: *const ::std::os::raw::c_char) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Move a file out of the way (create a backup) by renaming it to \"orig.NUM~\""]
    #[doc = " where NUM is the smallest number that is not used yet."]
    #[doc = ""]
    #[doc = " @param fil name of the file to back up"]
    pub fn GNUNET_DISK_file_backup(fil: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Move the read/write pointer in a file"]
    #[doc = " @param h handle of an open file"]
    #[doc = " @param offset position to move to"]
    #[doc = " @param whence specification to which position the offset parameter relates to"]
    #[doc = " @return the new position on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_DISK_file_seek(
        h: *const GNUNET_DISK_FileHandle,
        offset: off_t,
        whence: GNUNET_DISK_Seek,
    ) -> off_t;
}
extern "C" {
    #[doc = " Get the size of the file (or directory) of the given file (in"]
    #[doc = " bytes)."]
    #[doc = ""]
    #[doc = " @param filename name of the file or directory"]
    #[doc = " @param size set to the size of the file (or,"]
    #[doc = "             in the case of directories, the sum"]
    #[doc = "             of all sizes of files in the directory)"]
    #[doc = " @param include_symbolic_links should symbolic links be"]
    #[doc = "        included?"]
    #[doc = " @param single_file_mode #GNUNET_YES to only get size of one file"]
    #[doc = "        and return #GNUNET_SYSERR for directories."]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_DISK_file_size(
        filename: *const ::std::os::raw::c_char,
        size: *mut u64,
        include_symbolic_links: ::std::os::raw::c_int,
        single_file_mode: ::std::os::raw::c_int,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Obtain some unique identifiers for the given file"]
    #[doc = " that can be used to identify it in the local system."]
    #[doc = " This function is used between GNUnet processes to"]
    #[doc = " quickly check if two files with the same absolute path"]
    #[doc = " are actually identical.  The two processes represent"]
    #[doc = " the same peer but may communicate over the network"]
    #[doc = " (and the file may be on an NFS volume).  This function"]
    #[doc = " may not be supported on all operating systems."]
    #[doc = ""]
    #[doc = " @param filename name of the file"]
    #[doc = " @param dev set to the device ID"]
    #[doc = " @param ino set to the inode ID"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_DISK_file_get_identifiers(
        filename: *const ::std::os::raw::c_char,
        dev: *mut u64,
        ino: *mut u64,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Create an (empty) temporary file on disk.  If the given name is not"]
    #[doc = " an absolute path, the current 'TMPDIR' will be prepended.  In any case,"]
    #[doc = " 6 random characters will be appended to the name to create a unique"]
    #[doc = " filename."]
    #[doc = ""]
    #[doc = " @param t component to use for the name;"]
    #[doc = "        does NOT contain \"XXXXXX\" or \"/tmp/\"."]
    #[doc = " @return NULL on error, otherwise name of fresh"]
    #[doc = "         file on disk in directory for temporary files"]
    pub fn GNUNET_DISK_mktemp(t: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create an (empty) temporary directory on disk.  If the given name is not an"]
    #[doc = " absolute path, the current 'TMPDIR' will be prepended.  In any case, 6"]
    #[doc = " random characters will be appended to the name to create a unique name."]
    #[doc = ""]
    #[doc = " @param t component to use for the name;"]
    #[doc = "        does NOT contain \"XXXXXX\" or \"/tmp/\"."]
    #[doc = " @return NULL on error, otherwise name of freshly created directory"]
    pub fn GNUNET_DISK_mkdtemp(t: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Open a file.  Note that the access permissions will only be"]
    #[doc = " used if a new file is created and if the underlying operating"]
    #[doc = " system supports the given permissions."]
    #[doc = ""]
    #[doc = " @param fn file name to be opened"]
    #[doc = " @param flags opening flags, a combination of GNUNET_DISK_OPEN_xxx bit flags"]
    #[doc = " @param perm permissions for the newly created file, use"]
    #[doc = "             #GNUNET_DISK_PERM_NONE if a file could not be created by this"]
    #[doc = "             call (because of flags)"]
    #[doc = " @return IO handle on success, NULL on error"]
    pub fn GNUNET_DISK_file_open(
        fn_: *const ::std::os::raw::c_char,
        flags: GNUNET_DISK_OpenFlags,
        perm: GNUNET_DISK_AccessPermissions,
    ) -> *mut GNUNET_DISK_FileHandle;
}
extern "C" {
    #[doc = " Get the size of an open file."]
    #[doc = ""]
    #[doc = " @param fh open file handle"]
    #[doc = " @param size where to write size of the file"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_DISK_file_handle_size(
        fh: *mut GNUNET_DISK_FileHandle,
        size: *mut off_t,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " No special options, use non-blocking read/write operations."]
pub const GNUNET_DISK_PipeFlags_GNUNET_DISK_PF_NONE: GNUNET_DISK_PipeFlags = 0;
#[doc = " Configure read end to block when reading if set."]
pub const GNUNET_DISK_PipeFlags_GNUNET_DISK_PF_BLOCKING_READ: GNUNET_DISK_PipeFlags = 1;
#[doc = " Configure write end to block when writing if set."]
pub const GNUNET_DISK_PipeFlags_GNUNET_DISK_PF_BLOCKING_WRITE: GNUNET_DISK_PipeFlags = 2;
#[doc = " Configure both pipe ends for blocking operations if set."]
pub const GNUNET_DISK_PipeFlags_GNUNET_DISK_PF_BLOCKING_RW: GNUNET_DISK_PipeFlags = 3;
#[doc = " Flags for #GNUNET_DISK_pipe()."]
pub type GNUNET_DISK_PipeFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Creates an interprocess channel"]
    #[doc = ""]
    #[doc = " @param pf how to configure the pipe"]
    #[doc = " @return handle to the new pipe, NULL on error"]
    pub fn GNUNET_DISK_pipe(pf: GNUNET_DISK_PipeFlags) -> *mut GNUNET_DISK_PipeHandle;
}
extern "C" {
    #[doc = " Creates a pipe object from a couple of file descriptors."]
    #[doc = " Useful for wrapping existing pipe FDs."]
    #[doc = ""]
    #[doc = " @param pf how to configure the pipe"]
    #[doc = " @param fd an array of two fd values. One of them may be -1 for read-only or write-only pipes"]
    #[doc = " @return handle to the new pipe, NULL on error"]
    pub fn GNUNET_DISK_pipe_from_fd(
        pf: GNUNET_DISK_PipeFlags,
        fd: *mut ::std::os::raw::c_int,
    ) -> *mut GNUNET_DISK_PipeHandle;
}
extern "C" {
    #[doc = " Closes an interprocess channel"]
    #[doc = " @param p pipe"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_DISK_pipe_close(p: *mut GNUNET_DISK_PipeHandle) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Closes one half of an interprocess channel"]
    #[doc = ""]
    #[doc = " @param p pipe to close end of"]
    #[doc = " @param end which end of the pipe to close"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_DISK_pipe_close_end(
        p: *mut GNUNET_DISK_PipeHandle,
        end: GNUNET_DISK_PipeEnd,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Detaches one of the ends from the pipe."]
    #[doc = " Detached end is a fully-functional FileHandle, it will"]
    #[doc = " not be affected by anything you do with the pipe afterwards."]
    #[doc = " Each end of a pipe can only be detched from it once (i.e."]
    #[doc = " it is not duplicated)."]
    #[doc = ""]
    #[doc = " @param p pipe to detach an end from"]
    #[doc = " @param end which end of the pipe to detach"]
    #[doc = " @return Detached end on success, NULL on failure"]
    #[doc = " (or if that end is not present or is closed)."]
    pub fn GNUNET_DISK_pipe_detach_end(
        p: *mut GNUNET_DISK_PipeHandle,
        end: GNUNET_DISK_PipeEnd,
    ) -> *mut GNUNET_DISK_FileHandle;
}
extern "C" {
    #[doc = " Close an open file."]
    #[doc = ""]
    #[doc = " @param h file handle"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_DISK_file_close(h: *mut GNUNET_DISK_FileHandle) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Get the handle to a particular pipe end"]
    #[doc = ""]
    #[doc = " @param p pipe"]
    #[doc = " @param n end to access"]
    #[doc = " @return handle for the respective end"]
    pub fn GNUNET_DISK_pipe_handle(
        p: *const GNUNET_DISK_PipeHandle,
        n: GNUNET_DISK_PipeEnd,
    ) -> *const GNUNET_DISK_FileHandle;
}
extern "C" {
    #[doc = " Update POSIX permissions mask of a file on disk.  If both argumets"]
    #[doc = " are #GNUNET_NO, the file is made world-read-write-executable (777)."]
    #[doc = " Does nothing on W32."]
    #[doc = ""]
    #[doc = " @param fn name of the file to update"]
    #[doc = " @param require_uid_match #GNUNET_YES means 700"]
    #[doc = " @param require_gid_match #GNUNET_YES means 770 unless @a require_uid_match is set"]
    pub fn GNUNET_DISK_fix_permissions(
        fn_: *const ::std::os::raw::c_char,
        require_uid_match: ::std::os::raw::c_int,
        require_gid_match: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get a handle from a native integer FD."]
    #[doc = ""]
    #[doc = " @param fno native integer file descriptor"]
    #[doc = " @return file handle corresponding to the descriptor"]
    pub fn GNUNET_DISK_get_handle_from_int_fd(
        fno: ::std::os::raw::c_int,
    ) -> *mut GNUNET_DISK_FileHandle;
}
extern "C" {
    #[doc = " Get a handle from a native FD."]
    #[doc = ""]
    #[doc = " @param fd native file descriptor"]
    #[doc = " @return file handle corresponding to the descriptor"]
    pub fn GNUNET_DISK_get_handle_from_native(fd: *mut FILE) -> *mut GNUNET_DISK_FileHandle;
}
extern "C" {
    #[doc = " Read the contents of a binary file into a buffer."]
    #[doc = ""]
    #[doc = " @param h handle to an open file"]
    #[doc = " @param result the buffer to write the result to"]
    #[doc = " @param len the maximum number of bytes to read"]
    #[doc = " @return the number of bytes read on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_DISK_file_read(
        h: *const GNUNET_DISK_FileHandle,
        result: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Read the contents of a binary file into a buffer."]
    #[doc = " Guarantees not to block (returns GNUNET_SYSERR and sets errno to EAGAIN"]
    #[doc = " when no data can be read)."]
    #[doc = ""]
    #[doc = " @param h handle to an open file"]
    #[doc = " @param result the buffer to write the result to"]
    #[doc = " @param len the maximum number of bytes to read"]
    #[doc = " @return the number of bytes read on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_DISK_file_read_non_blocking(
        h: *const GNUNET_DISK_FileHandle,
        result: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Read the contents of a binary file into a buffer."]
    #[doc = ""]
    #[doc = " @param fn file name"]
    #[doc = " @param result the buffer to write the result to"]
    #[doc = " @param len the maximum number of bytes to read"]
    #[doc = " @return number of bytes read, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_DISK_fn_read(
        fn_: *const ::std::os::raw::c_char,
        result: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Write a buffer to a file."]
    #[doc = ""]
    #[doc = " @param h handle to open file"]
    #[doc = " @param buffer the data to write"]
    #[doc = " @param n number of bytes to write"]
    #[doc = " @return number of bytes written on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_DISK_file_write(
        h: *const GNUNET_DISK_FileHandle,
        buffer: *const ::std::os::raw::c_void,
        n: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Write a buffer to a file, blocking, if necessary."]
    #[doc = ""]
    #[doc = " @param h handle to open file"]
    #[doc = " @param buffer the data to write"]
    #[doc = " @param n number of bytes to write"]
    #[doc = " @return number of bytes written on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_DISK_file_write_blocking(
        h: *const GNUNET_DISK_FileHandle,
        buffer: *const ::std::os::raw::c_void,
        n: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Write a buffer to a file atomically.  The directory is created if"]
    #[doc = " necessary.  Fail if @a filename already exists or if not exactly @a buf"]
    #[doc = " with @a buf_size bytes could be written to @a filename."]
    #[doc = ""]
    #[doc = " @param fn file name"]
    #[doc = " @param buf the data to write"]
    #[doc = " @param buf_size number of bytes to write from @a buf"]
    #[doc = " @param mode file permissions"]
    #[doc = " @return #GNUNET_OK on success,"]
    #[doc = "         #GNUNET_NO if a file existed under @a filename"]
    #[doc = "         #GNUNET_SYSERR on failure"]
    pub fn GNUNET_DISK_fn_write(
        fn_: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        buf_size: usize,
        mode: GNUNET_DISK_AccessPermissions,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Copy a file."]
    #[doc = ""]
    #[doc = " @param src file to copy"]
    #[doc = " @param dst destination file name"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_DISK_file_copy(
        src: *const ::std::os::raw::c_char,
        dst: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Scan a directory for files."]
    #[doc = ""]
    #[doc = " @param dir_name the name of the directory"]
    #[doc = " @param callback the method to call for each file"]
    #[doc = " @param callback_cls closure for @a callback"]
    #[doc = " @return the number of files found, -1 on error"]
    pub fn GNUNET_DISK_directory_scan(
        dir_name: *const ::std::os::raw::c_char,
        callback: GNUNET_FileNameCallback,
        callback_cls: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create the directory structure for storing"]
    #[doc = " a file."]
    #[doc = ""]
    #[doc = " @param filename name of a file in the directory"]
    #[doc = " @returns #GNUNET_OK on success, #GNUNET_SYSERR on failure,"]
    #[doc = "          #GNUNET_NO if directory exists but is not writeable"]
    pub fn GNUNET_DISK_directory_create_for_file(
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Test if @a fil is a directory and listable. Optionally, also check if the"]
    #[doc = " directory is readable.  Will not print an error message if the directory does"]
    #[doc = " not exist.  Will log errors if #GNUNET_SYSERR is returned (i.e., a file exists"]
    #[doc = " with the same name)."]
    #[doc = ""]
    #[doc = " @param fil filename to test"]
    #[doc = " @param is_readable #GNUNET_YES to additionally check if @a fil is readable;"]
    #[doc = "          #GNUNET_NO to disable this check"]
    #[doc = " @return #GNUNET_YES if yes, #GNUNET_NO if not; #GNUNET_SYSERR if it"]
    #[doc = "           does not exist or `stat`ed"]
    pub fn GNUNET_DISK_directory_test(
        fil: *const ::std::os::raw::c_char,
        is_readable: ::std::os::raw::c_int,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Remove all files in a directory (rm -rf). Call with caution."]
    #[doc = ""]
    #[doc = " @param filename the file to remove"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_DISK_directory_remove(
        filename: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Remove the directory given under @a option in"]
    #[doc = " section [PATHS] in configuration under @a cfg_filename"]
    #[doc = ""]
    #[doc = " @param cfg_filename configuration file to parse"]
    #[doc = " @param option option with the dir name to purge"]
    pub fn GNUNET_DISK_purge_cfg_dir(
        cfg_filename: *const ::std::os::raw::c_char,
        option: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Implementation of \"mkdir -p\""]
    #[doc = ""]
    #[doc = " @param dir the directory to create"]
    #[doc = " @returns #GNUNET_SYSERR on failure, #GNUNET_OK otherwise"]
    pub fn GNUNET_DISK_directory_create(
        dir: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " @brief Removes special characters as ':' from a filename."]
    #[doc = " @param fn the filename to canonicalize"]
    pub fn GNUNET_DISK_filename_canonicalize(fn_: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @brief Change owner of a file"]
    #[doc = " @param filename file to change"]
    #[doc = " @param user new owner of the file"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_DISK_file_change_owner(
        filename: *const ::std::os::raw::c_char,
        user: *const ::std::os::raw::c_char,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Opaque handle for a memory-mapping operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DISK_MapHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Map a file into memory."]
    #[doc = ""]
    #[doc = " @param h open file handle"]
    #[doc = " @param m handle to the new mapping (will be set)"]
    #[doc = " @param access access specification, GNUNET_DISK_MAP_TYPE_xxx"]
    #[doc = " @param len size of the mapping"]
    #[doc = " @return pointer to the mapped memory region, NULL on failure"]
    pub fn GNUNET_DISK_file_map(
        h: *const GNUNET_DISK_FileHandle,
        m: *mut *mut GNUNET_DISK_MapHandle,
        access: GNUNET_DISK_MapType,
        len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Unmap a file"]
    #[doc = ""]
    #[doc = " @param h mapping handle"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_DISK_file_unmap(h: *mut GNUNET_DISK_MapHandle) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Write file changes to disk"]
    #[doc = ""]
    #[doc = " @param h handle to an open file"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_DISK_file_sync(h: *const GNUNET_DISK_FileHandle) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Test if the given protocol family is supported by this system."]
    #[doc = ""]
    #[doc = " @param pf protocol family to test (PF_INET, PF_INET6, PF_UNIX)"]
    #[doc = " @return #GNUNET_OK if the PF is supported"]
    pub fn GNUNET_NETWORK_test_pf(pf: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a unixpath that is too long (larger than UNIX_PATH_MAX),"]
    #[doc = " shorten it to an acceptable length while keeping it unique"]
    #[doc = " and making sure it remains a valid filename (if possible)."]
    #[doc = ""]
    #[doc = " @param unixpath long path, will be freed (or same pointer returned"]
    #[doc = "        with moved 0-termination)."]
    #[doc = " @return shortened unixpath, NULL on error"]
    pub fn GNUNET_NETWORK_shorten_unixpath(
        unixpath: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " If services crash, they can leave a unix domain socket file on the"]
    #[doc = " disk. This needs to be manually removed, because otherwise both"]
    #[doc = " bind() and connect() for the respective address will fail.  In this"]
    #[doc = " function, we test if such a left-over file exists, and if so,"]
    #[doc = " remove it (unless there is a listening service at the address)."]
    #[doc = ""]
    #[doc = " @param un unix domain socket address to check"]
    pub fn GNUNET_NETWORK_unix_precheck(un: *const sockaddr_un);
}
extern "C" {
    #[doc = " Accept a new connection on a socket.  Configure it for non-blocking"]
    #[doc = " IO and mark it as non-inheritable to child processes (set the"]
    #[doc = " close-on-exec flag)."]
    #[doc = ""]
    #[doc = " @param desc bound socket"]
    #[doc = " @param address address of the connecting peer, may be NULL"]
    #[doc = " @param address_len length of address"]
    #[doc = " @return client socket"]
    pub fn GNUNET_NETWORK_socket_accept(
        desc: *const GNUNET_NETWORK_Handle,
        address: *mut sockaddr,
        address_len: *mut socklen_t,
    ) -> *mut GNUNET_NETWORK_Handle;
}
extern "C" {
    #[doc = " Box a native socket (and check that it is a socket)."]
    #[doc = ""]
    #[doc = " @param fd socket to box"]
    #[doc = " @return NULL on error (including not supported on target platform)"]
    pub fn GNUNET_NETWORK_socket_box_native(
        fd: ::std::os::raw::c_int,
    ) -> *mut GNUNET_NETWORK_Handle;
}
extern "C" {
    #[doc = " Set if a socket should use blocking or non-blocking IO."]
    #[doc = ""]
    #[doc = " @param fd socket"]
    #[doc = " @param doBlock blocking mode"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_NETWORK_socket_set_blocking(
        fd: *mut GNUNET_NETWORK_Handle,
        doBlock: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Bind a socket to a particular address."]
    #[doc = ""]
    #[doc = " @param desc socket to bind"]
    #[doc = " @param address address to be bound"]
    #[doc = " @param address_len length of @a address"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_bind(
        desc: *mut GNUNET_NETWORK_Handle,
        address: *const sockaddr,
        address_len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a socket."]
    #[doc = ""]
    #[doc = " @param desc socket to close"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_close(desc: *mut GNUNET_NETWORK_Handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Only free memory of a socket, keep the file descriptor untouched."]
    #[doc = ""]
    #[doc = " @param desc socket"]
    pub fn GNUNET_NETWORK_socket_free_memory_only_(desc: *mut GNUNET_NETWORK_Handle);
}
extern "C" {
    #[doc = " Connect a socket to some remote address."]
    #[doc = ""]
    #[doc = " @param desc socket to connect"]
    #[doc = " @param address peer address"]
    #[doc = " @param address_len of @a address"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_connect(
        desc: *const GNUNET_NETWORK_Handle,
        address: *const sockaddr,
        address_len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get socket options"]
    #[doc = ""]
    #[doc = " @param desc socket to inspect"]
    #[doc = " @param level protocol level of the option"]
    #[doc = " @param optname identifier of the option"]
    #[doc = " @param optval options"]
    #[doc = " @param optlen length of optval"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_getsockopt(
        desc: *const GNUNET_NETWORK_Handle,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Listen on a socket"]
    #[doc = ""]
    #[doc = " @param desc socket to start listening on"]
    #[doc = " @param backlog length of the listen queue"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_listen(
        desc: *const GNUNET_NETWORK_Handle,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " How much data is available to be read on this descriptor?"]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @returns #GNUNET_SYSERR if no data is available, or on error!"]
    pub fn GNUNET_NETWORK_socket_recvfrom_amount(desc: *const GNUNET_NETWORK_Handle) -> isize;
}
extern "C" {
    #[doc = " Read data from a socket (always non-blocking)."]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @param buffer buffer"]
    #[doc = " @param length length of buffer"]
    #[doc = " @param src_addr either the source to recv from, or all zeroes"]
    #[doc = "        to be filled in by recvfrom"]
    #[doc = " @param addrlen length of the addr"]
    pub fn GNUNET_NETWORK_socket_recvfrom(
        desc: *const GNUNET_NETWORK_Handle,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Read data from a connected socket (always non-blocking)."]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @param buffer buffer"]
    #[doc = " @param length length of buffer"]
    #[doc = " @return number of bytes read"]
    pub fn GNUNET_NETWORK_socket_recv(
        desc: *const GNUNET_NETWORK_Handle,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Check if sockets meet certain conditions."]
    #[doc = ""]
    #[doc = " @param rfds set of sockets to be checked for readability"]
    #[doc = " @param wfds set of sockets to be checked for writability"]
    #[doc = " @param efds set of sockets to be checked for exceptions"]
    #[doc = " @param timeout relative value when to return"]
    #[doc = " @return number of selected sockets, #GNUNET_SYSERR on error"]
    pub fn GNUNET_NETWORK_socket_select(
        rfds: *mut GNUNET_NETWORK_FDSet,
        wfds: *mut GNUNET_NETWORK_FDSet,
        efds: *mut GNUNET_NETWORK_FDSet,
        timeout: GNUNET_TIME_Relative,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send data (always non-blocking)."]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @param buffer data to send"]
    #[doc = " @param length size of the buffer"]
    #[doc = " @return number of bytes sent, #GNUNET_SYSERR on error"]
    pub fn GNUNET_NETWORK_socket_send(
        desc: *const GNUNET_NETWORK_Handle,
        buffer: *const ::std::os::raw::c_void,
        length: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Send data to a particular destination (always non-blocking)."]
    #[doc = " This function only works for UDP sockets."]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @param message data to send"]
    #[doc = " @param length size of the data in @a message"]
    #[doc = " @param dest_addr destination address"]
    #[doc = " @param dest_len length of @a dest_addr"]
    #[doc = " @return number of bytes sent, #GNUNET_SYSERR on error"]
    pub fn GNUNET_NETWORK_socket_sendto(
        desc: *const GNUNET_NETWORK_Handle,
        message: *const ::std::os::raw::c_void,
        length: usize,
        dest_addr: *const sockaddr,
        dest_len: socklen_t,
    ) -> isize;
}
extern "C" {
    #[doc = " Set socket option"]
    #[doc = ""]
    #[doc = " @param fd socket"]
    #[doc = " @param level protocol level of the option"]
    #[doc = " @param option_name option identifier"]
    #[doc = " @param option_value value to set"]
    #[doc = " @param option_len size of @a option_value"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_setsockopt(
        fd: *mut GNUNET_NETWORK_Handle,
        level: ::std::os::raw::c_int,
        option_name: ::std::os::raw::c_int,
        option_value: *const ::std::os::raw::c_void,
        option_len: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Shut down socket operations"]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @param how type of shutdown"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_shutdown(
        desc: *mut GNUNET_NETWORK_Handle,
        how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Disable the \"CORK\" feature for communication with the given socket,"]
    #[doc = " forcing the OS to immediately flush the buffer on transmission"]
    #[doc = " instead of potentially buffering multiple messages.  Essentially"]
    #[doc = " reduces the OS send buffers to zero."]
    #[doc = ""]
    #[doc = " @param desc socket"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_NETWORK_socket_disable_corking(
        desc: *mut GNUNET_NETWORK_Handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new socket.   Configure it for non-blocking IO and"]
    #[doc = " mark it as non-inheritable to child processes (set the"]
    #[doc = " close-on-exec flag)."]
    #[doc = ""]
    #[doc = " @param domain domain of the socket"]
    #[doc = " @param type socket type"]
    #[doc = " @param protocol network protocol"]
    #[doc = " @return new socket, NULL on error"]
    pub fn GNUNET_NETWORK_socket_create(
        domain: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> *mut GNUNET_NETWORK_Handle;
}
extern "C" {
    #[doc = " Reset FD set (clears all file descriptors)."]
    #[doc = ""]
    #[doc = " @param fds fd set to clear"]
    pub fn GNUNET_NETWORK_fdset_zero(fds: *mut GNUNET_NETWORK_FDSet);
}
extern "C" {
    #[doc = " Add a socket to the FD set"]
    #[doc = ""]
    #[doc = " @param fds fd set"]
    #[doc = " @param desc socket to add"]
    pub fn GNUNET_NETWORK_fdset_set(
        fds: *mut GNUNET_NETWORK_FDSet,
        desc: *const GNUNET_NETWORK_Handle,
    );
}
extern "C" {
    #[doc = " Check whether a socket is part of the fd set"]
    #[doc = ""]
    #[doc = " @param fds fd set"]
    #[doc = " @param desc socket"]
    #[doc = " @return #GNUNET_YES if the socket is in the set"]
    pub fn GNUNET_NETWORK_fdset_isset(
        fds: *const GNUNET_NETWORK_FDSet,
        desc: *const GNUNET_NETWORK_Handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add one fd set to another (computes the union)."]
    #[doc = ""]
    #[doc = " @param dst the fd set to add to"]
    #[doc = " @param src the fd set to add from"]
    pub fn GNUNET_NETWORK_fdset_add(
        dst: *mut GNUNET_NETWORK_FDSet,
        src: *const GNUNET_NETWORK_FDSet,
    );
}
extern "C" {
    #[doc = " Copy one fd set to another"]
    #[doc = ""]
    #[doc = " @param to destination"]
    #[doc = " @param from source"]
    pub fn GNUNET_NETWORK_fdset_copy(
        to: *mut GNUNET_NETWORK_FDSet,
        from: *const GNUNET_NETWORK_FDSet,
    );
}
extern "C" {
    #[doc = " Return file descriptor for this network handle"]
    #[doc = ""]
    #[doc = " @param desc wrapper to process"]
    #[doc = " @return POSIX file descriptor"]
    pub fn GNUNET_NETWORK_get_fd(desc: *const GNUNET_NETWORK_Handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the sockaddr for this network handle"]
    #[doc = ""]
    #[doc = " @param desc wrapper to process"]
    #[doc = " @return POSIX file descriptor"]
    pub fn GNUNET_NETWORK_get_addr(desc: *const GNUNET_NETWORK_Handle) -> *mut sockaddr;
}
extern "C" {
    #[doc = " Return sockaddr length for this network handle"]
    #[doc = ""]
    #[doc = " @param desc wrapper to process"]
    #[doc = " @return socklen_t for sockaddr"]
    pub fn GNUNET_NETWORK_get_addrlen(desc: *const GNUNET_NETWORK_Handle) -> socklen_t;
}
extern "C" {
    #[doc = " Copy a native fd set into the GNUnet representation."]
    #[doc = ""]
    #[doc = " @param to destination"]
    #[doc = " @param from native source set"]
    #[doc = " @param nfds the biggest socket number in from + 1"]
    pub fn GNUNET_NETWORK_fdset_copy_native(
        to: *mut GNUNET_NETWORK_FDSet,
        from: *const fd_set,
        nfds: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set a native fd in a set"]
    #[doc = ""]
    #[doc = " @param to destination"]
    #[doc = " @param nfd native FD to set"]
    pub fn GNUNET_NETWORK_fdset_set_native(
        to: *mut GNUNET_NETWORK_FDSet,
        nfd: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Test native fd in a set"]
    #[doc = ""]
    #[doc = " @param to set to test, NULL for empty set"]
    #[doc = " @param nfd native FD to test, -1 for none"]
    #[doc = " @return #GNUNET_YES if to contains nfd"]
    pub fn GNUNET_NETWORK_fdset_test_native(
        to: *const GNUNET_NETWORK_FDSet,
        nfd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a file handle to the fd set"]
    #[doc = ""]
    #[doc = " @param fds fd set"]
    #[doc = " @param h the file handle to add"]
    pub fn GNUNET_NETWORK_fdset_handle_set(
        fds: *mut GNUNET_NETWORK_FDSet,
        h: *const GNUNET_DISK_FileHandle,
    );
}
extern "C" {
    #[doc = " Add a file handle to the fd set"]
    #[doc = " On W32: ensure that the handle is first in the array."]
    #[doc = ""]
    #[doc = " @param fds fd set"]
    #[doc = " @param h the file handle to add"]
    pub fn GNUNET_NETWORK_fdset_handle_set_first(
        fds: *mut GNUNET_NETWORK_FDSet,
        h: *const GNUNET_DISK_FileHandle,
    );
}
extern "C" {
    #[doc = " Check if a file handle is part of an fd set"]
    #[doc = ""]
    #[doc = " @param fds fd set"]
    #[doc = " @param h file handle"]
    #[doc = " @return #GNUNET_YES if the file handle is part of the set"]
    pub fn GNUNET_NETWORK_fdset_handle_isset(
        fds: *const GNUNET_NETWORK_FDSet,
        h: *const GNUNET_DISK_FileHandle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks if two fd sets overlap"]
    #[doc = ""]
    #[doc = " @param fds1 first fd set"]
    #[doc = " @param fds2 second fd set"]
    #[doc = " @return #GNUNET_YES if they do overlap, #GNUNET_NO otherwise"]
    pub fn GNUNET_NETWORK_fdset_overlap(
        fds1: *const GNUNET_NETWORK_FDSet,
        fds2: *const GNUNET_NETWORK_FDSet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates an fd set"]
    #[doc = ""]
    #[doc = " @return a new fd set"]
    pub fn GNUNET_NETWORK_fdset_create() -> *mut GNUNET_NETWORK_FDSet;
}
extern "C" {
    #[doc = " Releases the associated memory of an fd set"]
    #[doc = ""]
    #[doc = " @param fds fd set"]
    pub fn GNUNET_NETWORK_fdset_destroy(fds: *mut GNUNET_NETWORK_FDSet);
}
extern "C" {
    #[doc = " Test if the given @a port is available."]
    #[doc = ""]
    #[doc = " @param ipproto transport protocol to test (i.e. IPPROTO_TCP)"]
    #[doc = " @param port port number to test"]
    #[doc = " @return #GNUNET_OK if the port is available, #GNUNET_NO if not"]
    pub fn GNUNET_NETWORK_test_port_free(
        ipproto: ::std::os::raw::c_int,
        port: u16,
    ) -> ::std::os::raw::c_int;
}
#[doc = " No event (useful for timeout)."]
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_NONE: GNUNET_SCHEDULER_EventType = 0;
#[doc = " Data available for reading."]
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_IN: GNUNET_SCHEDULER_EventType = 1;
#[doc = " Buffer available for writing."]
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_OUT: GNUNET_SCHEDULER_EventType = 2;
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_HUP: GNUNET_SCHEDULER_EventType = 4;
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_ERR: GNUNET_SCHEDULER_EventType = 8;
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_PRI: GNUNET_SCHEDULER_EventType = 16;
pub const GNUNET_SCHEDULER_EventType_GNUNET_SCHEDULER_ET_NVAL: GNUNET_SCHEDULER_EventType = 32;
#[doc = " Possible events on FDs, used as a bitmask."]
#[doc = " Modelled after GPollFD."]
pub type GNUNET_SCHEDULER_EventType = ::std::os::raw::c_uint;
#[doc = " Information about an event relating to a file descriptor/socket."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SCHEDULER_FdInfo {
    #[doc = " GNUnet network socket the event is about, matches @a sock,"]
    #[doc = " NULL if this is about a file handle or if no network"]
    #[doc = " handle was given to the scheduler originally."]
    pub fd: *const GNUNET_NETWORK_Handle,
    #[doc = " GNUnet file handle the event is about, matches @a sock,"]
    #[doc = " NULL if this is about a network socket or if no network"]
    #[doc = " handle was given to the scheduler originally."]
    pub fh: *const GNUNET_DISK_FileHandle,
    #[doc = " Type of the event that was generated related to @e sock."]
    pub et: GNUNET_SCHEDULER_EventType,
    #[doc = " Underlying OS handle the event was about."]
    pub sock: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GNUNET_SCHEDULER_FdInfo() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_SCHEDULER_FdInfo>(),
        24usize,
        concat!("Size of: ", stringify!(GNUNET_SCHEDULER_FdInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_SCHEDULER_FdInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_SCHEDULER_FdInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_FdInfo>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_FdInfo),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_FdInfo>())).fh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_FdInfo),
            "::",
            stringify!(fh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_FdInfo>())).et as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_FdInfo),
            "::",
            stringify!(et)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_FdInfo>())).sock as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_FdInfo),
            "::",
            stringify!(sock)
        )
    );
}
#[doc = " Context information passed to each scheduler task."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SCHEDULER_TaskContext {
    #[doc = " Reason why the task is run now"]
    pub reason: GNUNET_SCHEDULER_Reason,
    #[doc = " Length of the following array."]
    pub fds_len: ::std::os::raw::c_uint,
    #[doc = " Array of length @e fds_len with information about ready FDs."]
    #[doc = " Note that we use the same format regardless of the internal"]
    #[doc = " event loop that was used.  The given array should only contain"]
    #[doc = " information about file descriptors relevant to the current task."]
    pub fds: *const GNUNET_SCHEDULER_FdInfo,
    #[doc = " Set of file descriptors ready for reading; note that additional"]
    #[doc = " bits may be set that were not in the original request."]
    #[doc = " @deprecated"]
    pub read_ready: *const GNUNET_NETWORK_FDSet,
    #[doc = " Set of file descriptors ready for writing; note that additional"]
    #[doc = " bits may be set that were not in the original request."]
    #[doc = " @deprecated"]
    pub write_ready: *const GNUNET_NETWORK_FDSet,
}
#[test]
fn bindgen_test_layout_GNUNET_SCHEDULER_TaskContext() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_SCHEDULER_TaskContext>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_SCHEDULER_TaskContext))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_SCHEDULER_TaskContext>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_SCHEDULER_TaskContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_SCHEDULER_TaskContext>())).reason as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_TaskContext),
            "::",
            stringify!(reason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_SCHEDULER_TaskContext>())).fds_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_TaskContext),
            "::",
            stringify!(fds_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_SCHEDULER_TaskContext>())).fds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_TaskContext),
            "::",
            stringify!(fds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_SCHEDULER_TaskContext>())).read_ready as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_TaskContext),
            "::",
            stringify!(read_ready)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_SCHEDULER_TaskContext>())).write_ready as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_TaskContext),
            "::",
            stringify!(write_ready)
        )
    );
}
extern "C" {
    #[doc = " Function used by event-loop implementations to signal the scheduler"]
    #[doc = " that a particular @a task is ready due to an event specified in the"]
    #[doc = " et field of @a fdi."]
    #[doc = ""]
    #[doc = " This function will then queue the task to notify the application"]
    #[doc = " that the task is ready (with the respective priority)."]
    #[doc = ""]
    #[doc = " @param task the task that is ready"]
    #[doc = " @param fdi information about the related FD"]
    pub fn GNUNET_SCHEDULER_task_ready(
        task: *mut GNUNET_SCHEDULER_Task,
        fdi: *mut GNUNET_SCHEDULER_FdInfo,
    );
}
#[doc = " Handle to the scheduler's state to be used by the driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SCHEDULER_Handle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Function called by external event loop implementations to tell the"]
    #[doc = " scheduler to run some of the tasks that are ready. Must be called"]
    #[doc = " only after #GNUNET_SCHEDULER_driver_init has been called and before"]
    #[doc = " #GNUNET_SCHEDULER_driver_done is called."]
    #[doc = " This function may return even though there are tasks left to run"]
    #[doc = " just to give other tasks a chance as well.  If we return #GNUNET_YES,"]
    #[doc = " the event loop implementation should call this function again as"]
    #[doc = " soon as possible, while if we return #GNUNET_NO it must block until"]
    #[doc = " either the operating system has more work (the scheduler has no more"]
    #[doc = " work to do right now) or the timeout set by the scheduler (using the"]
    #[doc = " set_wakeup callback) is reached."]
    #[doc = ""]
    #[doc = " @param sh scheduler handle that was returned by"]
    #[doc = "        #GNUNET_SCHEDULER_driver_init"]
    #[doc = " @return #GNUNET_YES if there are more tasks that are ready,"]
    #[doc = "         and thus we would like to run more (yield to avoid"]
    #[doc = "         blocking other activities for too long) #GNUNET_NO"]
    #[doc = "         if we are done running tasks (yield to block)"]
    pub fn GNUNET_SCHEDULER_do_work(sh: *mut GNUNET_SCHEDULER_Handle) -> ::std::os::raw::c_int;
}
#[doc = " API an external event loop has to implement for"]
#[doc = " #GNUNET_SCHEDULER_driver_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SCHEDULER_Driver {
    #[doc = " Closure to pass to the functions in this struct."]
    pub cls: *mut ::std::os::raw::c_void,
    #[doc = " Add a @a task to be run if the conditions specified in the"]
    #[doc = " et field of the given @a fdi are satisfied. The et field will"]
    #[doc = " be cleared after this call and the driver is expected to set"]
    #[doc = " the type of the actual event before passing @a fdi to"]
    #[doc = " #GNUNET_SCHEDULER_task_ready."]
    #[doc = ""]
    #[doc = " @param cls closure"]
    #[doc = " @param task task to add"]
    #[doc = " @param fdi conditions to watch for"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    #[doc = "   (i.e. @a fdi too high or invalid)"]
    pub add: ::std::option::Option<
        unsafe extern "C" fn(
            cls: *mut ::std::os::raw::c_void,
            task: *mut GNUNET_SCHEDULER_Task,
            fdi: *mut GNUNET_SCHEDULER_FdInfo,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Delete a @a task from the set of tasks to be run. A task may"]
    #[doc = " comprise multiple FdInfo entries previously added with the add"]
    #[doc = " function. The driver is expected to delete them all."]
    #[doc = ""]
    #[doc = " @param cls closure"]
    #[doc = " @param task task to delete"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    #[doc = "   (i.e. @a task does not match prior @e add call)"]
    pub del: ::std::option::Option<
        unsafe extern "C" fn(
            cls: *mut ::std::os::raw::c_void,
            task: *mut GNUNET_SCHEDULER_Task,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set time at which we definitively want to get a wakeup call."]
    #[doc = ""]
    #[doc = " @param cls closure"]
    #[doc = " @param dt time when we want to wake up next"]
    pub set_wakeup: ::std::option::Option<
        unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, dt: GNUNET_TIME_Absolute),
    >,
}
#[test]
fn bindgen_test_layout_GNUNET_SCHEDULER_Driver() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_SCHEDULER_Driver>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_SCHEDULER_Driver))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_SCHEDULER_Driver>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_SCHEDULER_Driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_Driver>())).cls as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_Driver),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_Driver>())).add as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_Driver),
            "::",
            stringify!(add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_SCHEDULER_Driver>())).del as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_Driver),
            "::",
            stringify!(del)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_SCHEDULER_Driver>())).set_wakeup as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_SCHEDULER_Driver),
            "::",
            stringify!(set_wakeup)
        )
    );
}
#[doc = " Signature of the main function of a task."]
#[doc = ""]
#[doc = " @param cls closure"]
pub type GNUNET_SCHEDULER_TaskCallback =
    ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Function called by external event loop implementations to initialize"]
    #[doc = " the scheduler. An external implementation has to provide @a driver"]
    #[doc = " which contains callbacks for the scheduler (see definition of struct"]
    #[doc = " #GNUNET_SCHEDULER_Driver). The callbacks are used to instruct the"]
    #[doc = " external implementation to watch for events. If it detects any of"]
    #[doc = " those events it is expected to call #GNUNET_SCHEDULER_do_work to let"]
    #[doc = " the scheduler handle it. If an event is related to a specific task"]
    #[doc = " (e.g. the scheduler gave instructions to watch a file descriptor),"]
    #[doc = " the external implementation is expected to mark that task ready"]
    #[doc = " before by calling #GNUNET_SCHEDULER_task_ready."]
    #[doc = ""]
    #[doc = " This function has to be called before any tasks are scheduled and"]
    #[doc = " before GNUNET_SCHEDULER_do_work is called for the first time. It"]
    #[doc = " allocates resources that have to be freed again by calling"]
    #[doc = " #GNUNET_SCHEDULER_driver_done."]
    #[doc = ""]
    #[doc = " This function installs the same signal handlers as"]
    #[doc = " #GNUNET_SCHEDULER_run. This means SIGTERM (and other similar signals)"]
    #[doc = " will induce a call to #GNUNET_SCHEDULER_shutdown during the next"]
    #[doc = " call to #GNUNET_SCHEDULER_do_work. As a result, SIGTERM causes all"]
    #[doc = " active tasks to be scheduled with reason"]
    #[doc = " #GNUNET_SCHEDULER_REASON_SHUTDOWN. (However, tasks added afterwards"]
    #[doc = " will execute normally!). Note that any particular signal will only"]
    #[doc = " shut down one scheduler; applications should always only create a"]
    #[doc = " single scheduler."]
    #[doc = ""]
    #[doc = " @param driver to use for the event loop"]
    #[doc = " @return handle to be passed to #GNUNET_SCHEDULER_do_work and"]
    #[doc = "         #GNUNET_SCHEDULER_driver_done"]
    pub fn GNUNET_SCHEDULER_driver_init(
        driver: *const GNUNET_SCHEDULER_Driver,
    ) -> *mut GNUNET_SCHEDULER_Handle;
}
extern "C" {
    #[doc = " Counter-part of #GNUNET_SCHEDULER_driver_init. Has to be called"]
    #[doc = " by external event loop implementations after the scheduler has"]
    #[doc = " shut down. This is the case if both of the following conditions"]
    #[doc = " are met:"]
    #[doc = ""]
    #[doc = " - all tasks the scheduler has added through the driver's add"]
    #[doc = "   callback have been removed again through the driver's del"]
    #[doc = "   callback"]
    #[doc = " - the timeout the scheduler has set through the driver's"]
    #[doc = "   add_wakeup callback is FOREVER"]
    #[doc = ""]
    #[doc = " @param sh the handle returned by #GNUNET_SCHEDULER_driver_init"]
    pub fn GNUNET_SCHEDULER_driver_done(sh: *mut GNUNET_SCHEDULER_Handle);
}
extern "C" {
    #[doc = " Obtain the driver for using select() as the event loop."]
    #[doc = ""]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_SCHEDULER_driver_select() -> *mut GNUNET_SCHEDULER_Driver;
}
#[doc = " Signature of the select function used by the scheduler."]
#[doc = " #GNUNET_NETWORK_socket_select matches it."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param rfds set of sockets to be checked for readability"]
#[doc = " @param wfds set of sockets to be checked for writability"]
#[doc = " @param efds set of sockets to be checked for exceptions"]
#[doc = " @param timeout relative value when to return"]
#[doc = " @return number of selected sockets, #GNUNET_SYSERR on error"]
pub type GNUNET_SCHEDULER_select = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        rfds: *mut GNUNET_NETWORK_FDSet,
        wfds: *mut GNUNET_NETWORK_FDSet,
        efds: *mut GNUNET_NETWORK_FDSet,
        timeout: GNUNET_TIME_Relative,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Initialize and run scheduler.  This function will return when all"]
    #[doc = " tasks have completed.  On systems with signals, receiving a SIGTERM"]
    #[doc = " (and other similar signals) will cause #GNUNET_SCHEDULER_shutdown"]
    #[doc = " to be run after the active task is complete.  As a result, SIGTERM"]
    #[doc = " causes all shutdown tasks to be scheduled with reason"]
    #[doc = " #GNUNET_SCHEDULER_REASON_SHUTDOWN.  (However, tasks added"]
    #[doc = " afterwards will execute normally!).  Note that any particular"]
    #[doc = " signal will only shut down one scheduler; applications should"]
    #[doc = " always only create a single scheduler."]
    #[doc = ""]
    #[doc = " @param task task to run first (and immediately)"]
    #[doc = " @param task_cls closure of @a task"]
    pub fn GNUNET_SCHEDULER_run(
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Initialize and run scheduler.  This function will return when all"]
    #[doc = " tasks have completed.  When @ install_signals is GNUNET_YES, then"]
    #[doc = " this function behaves in the same was as GNUNET_SCHEDULER_run does."]
    #[doc = " If @ install_signals is GNUNET_NO then no signal handlers are"]
    #[doc = " installed."]
    #[doc = ""]
    #[doc = " @param install_signals whether to install signals (GNUNET_YES/NO)"]
    #[doc = " @param task task to run first (and immediately)"]
    #[doc = " @param task_cls closure of @a task"]
    pub fn GNUNET_SCHEDULER_run_with_optional_signals(
        install_signals: ::std::os::raw::c_int,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Request the shutdown of a scheduler.  Marks all tasks"]
    #[doc = " awaiting shutdown as ready. Note that tasks"]
    #[doc = " scheduled with #GNUNET_SCHEDULER_add_shutdown() AFTER this call"]
    #[doc = " will be delayed until the next shutdown signal."]
    pub fn GNUNET_SCHEDULER_shutdown();
}
extern "C" {
    #[doc = " Get information about the current load of this scheduler.  Use this"]
    #[doc = " function to determine if an elective task should be added or simply"]
    #[doc = " dropped (if the decision should be made based on the number of"]
    #[doc = " tasks ready to run)."]
    #[doc = ""]
    #[doc = " @param p priority-level to query, use KEEP to query the level"]
    #[doc = "          of the current task, use COUNT to get the sum over"]
    #[doc = "          all priority levels"]
    #[doc = " @return number of tasks pending right now"]
    pub fn GNUNET_SCHEDULER_get_load(p: GNUNET_SCHEDULER_Priority) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Obtain the reasoning why the current task was"]
    #[doc = " started."]
    #[doc = ""]
    #[doc = " @return task context with information why the current task is run"]
    pub fn GNUNET_SCHEDULER_get_task_context() -> *const GNUNET_SCHEDULER_TaskContext;
}
extern "C" {
    #[doc = " Cancel the task with the specified identifier."]
    #[doc = " The task must not yet have run. Only allowed to be called as long as the"]
    #[doc = " scheduler is running, that is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param task id of the task to cancel"]
    #[doc = " @return original closure of the task"]
    pub fn GNUNET_SCHEDULER_cancel(task: *mut GNUNET_SCHEDULER_Task)
        -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Continue the current execution with the given function.  This is"]
    #[doc = " similar to the other \"add\" functions except that there is no delay"]
    #[doc = " and the reason code can be specified."]
    #[doc = ""]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure for @a task"]
    #[doc = " @param reason reason for task invocation"]
    #[doc = " @param priority priority to use for the task"]
    pub fn GNUNET_SCHEDULER_add_with_reason_and_priority(
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
        reason: GNUNET_SCHEDULER_Reason,
        priority: GNUNET_SCHEDULER_Priority,
    );
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified priority."]
    #[doc = ""]
    #[doc = " @param prio how important is the new task?"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_with_priority(
        prio: GNUNET_SCHEDULER_Priority,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run as soon as possible. Note that this"]
    #[doc = " does not guarantee that this will be the next task that is being"]
    #[doc = " run, as other tasks with higher priority (or that are already ready"]
    #[doc = " to run) might get to run first.  Just as with delays, clients must"]
    #[doc = " not rely on any particular order of execution between tasks"]
    #[doc = " scheduled concurrently."]
    #[doc = ""]
    #[doc = " The task will be run with the DEFAULT priority."]
    #[doc = ""]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_now(
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run on shutdown, that is when a CTRL-C"]
    #[doc = " signal is received, or when #GNUNET_SCHEDULER_shutdown() is being"]
    #[doc = " invoked."]
    #[doc = ""]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_shutdown(
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run as soon as possible with the"]
    #[doc = " (transitive) ignore-shutdown flag either explicitly set or"]
    #[doc = " explicitly enabled.  This task (and all tasks created from it,"]
    #[doc = " other than by another call to this function) will either count or"]
    #[doc = " not count for the 'lifeness' of the process.  This API is only"]
    #[doc = " useful in a few special cases."]
    #[doc = ""]
    #[doc = " @param lifeness #GNUNET_YES if the task counts for lifeness, #GNUNET_NO if not."]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_now_with_lifeness(
        lifeness: ::std::os::raw::c_int,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay.  The task"]
    #[doc = " will be scheduled for execution once the delay has expired. It"]
    #[doc = " will be run with the DEFAULT priority."]
    #[doc = ""]
    #[doc = " @param delay with which the operation should be run"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_delayed(
        delay: GNUNET_TIME_Relative,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run at the specified time.  The task"]
    #[doc = " will be scheduled for execution once specified time has been"]
    #[doc = " reached. It will be run with the DEFAULT priority."]
    #[doc = ""]
    #[doc = " @param at time at which this operation should run"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_at(
        at: GNUNET_TIME_Absolute,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay.  The task"]
    #[doc = " will be scheduled for execution once the delay has expired."]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param priority priority to use for the task"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_delayed_with_priority(
        delay: GNUNET_TIME_Relative,
        priority: GNUNET_SCHEDULER_Priority,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run at the specified time.  The task"]
    #[doc = " will be scheduled for execution at time @a at."]
    #[doc = ""]
    #[doc = " @param at time when the operation should run"]
    #[doc = " @param priority priority to use for the task"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_at_with_priority(
        at: GNUNET_TIME_Absolute,
        priority: GNUNET_SCHEDULER_Priority,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when the"]
    #[doc = " specified file descriptor is ready for reading.  The delay can be"]
    #[doc = " used as a timeout on the socket being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or the"]
    #[doc = " socket operation is ready.  It will be run with the DEFAULT priority."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param rfd read file-descriptor"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_read_net(
        delay: GNUNET_TIME_Relative,
        rfd: *mut GNUNET_NETWORK_Handle,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified priority and to be"]
    #[doc = " run after the specified delay or when the specified file descriptor"]
    #[doc = " is ready for reading.  The delay can be used as a timeout on the"]
    #[doc = " socket being ready.  The task will be scheduled for execution once"]
    #[doc = " either the delay has expired or the socket operation is ready.  It"]
    #[doc = " will be run with the DEFAULT priority."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param priority priority to use for the task"]
    #[doc = " @param rfd read file-descriptor"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_read_net_with_priority(
        delay: GNUNET_TIME_Relative,
        priority: GNUNET_SCHEDULER_Priority,
        rfd: *mut GNUNET_NETWORK_Handle,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when the"]
    #[doc = " specified file descriptor is ready for writing.  The delay can be"]
    #[doc = " used as a timeout on the socket being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or the"]
    #[doc = " socket operation is ready.  It will be run with the priority of"]
    #[doc = " the calling task."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param wfd write file-descriptor"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_write_net(
        delay: GNUNET_TIME_Relative,
        wfd: *mut GNUNET_NETWORK_Handle,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when the"]
    #[doc = " specified file descriptor is ready.  The delay can be"]
    #[doc = " used as a timeout on the socket being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or the"]
    #[doc = " socket operation is ready."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param priority priority of the task"]
    #[doc = " @param fd file-descriptor"]
    #[doc = " @param on_read whether to poll the file-descriptor for readability"]
    #[doc = " @param on_write whether to poll the file-descriptor for writability"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until \"task\" is started!"]
    pub fn GNUNET_SCHEDULER_add_net_with_priority(
        delay: GNUNET_TIME_Relative,
        priority: GNUNET_SCHEDULER_Priority,
        fd: *mut GNUNET_NETWORK_Handle,
        on_read: ::std::os::raw::c_int,
        on_write: ::std::os::raw::c_int,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when the"]
    #[doc = " specified file descriptor is ready for reading.  The delay can be"]
    #[doc = " used as a timeout on the socket being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or the"]
    #[doc = " socket operation is ready. It will be run with the DEFAULT priority."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param rfd read file-descriptor"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_read_file(
        delay: GNUNET_TIME_Relative,
        rfd: *const GNUNET_DISK_FileHandle,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when the"]
    #[doc = " specified file descriptor is ready for writing.  The delay can be"]
    #[doc = " used as a timeout on the socket being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or the"]
    #[doc = " socket operation is ready. It will be run with the DEFAULT priority."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param wfd write file-descriptor"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_write_file(
        delay: GNUNET_TIME_Relative,
        wfd: *const GNUNET_DISK_FileHandle,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when the"]
    #[doc = " specified file descriptor is ready.  The delay can be"]
    #[doc = " used as a timeout on the socket being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or the"]
    #[doc = " socket operation is ready."]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param delay when should this operation time out?"]
    #[doc = " @param priority priority of the task"]
    #[doc = " @param fd file-descriptor"]
    #[doc = " @param on_read whether to poll the file-descriptor for readability"]
    #[doc = " @param on_write whether to poll the file-descriptor for writability"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_file_with_priority(
        delay: GNUNET_TIME_Relative,
        priority: GNUNET_SCHEDULER_Priority,
        fd: *const GNUNET_DISK_FileHandle,
        on_read: ::std::os::raw::c_int,
        on_write: ::std::os::raw::c_int,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Schedule a new task to be run with a specified delay or when any of"]
    #[doc = " the specified file descriptor sets is ready.  The delay can be used"]
    #[doc = " as a timeout on the socket(s) being ready.  The task will be"]
    #[doc = " scheduled for execution once either the delay has expired or any of"]
    #[doc = " the socket operations is ready.  This is the most general"]
    #[doc = " function of the \"add\" family.  Note that the \"prerequisite_task\""]
    #[doc = " must be satisfied in addition to any of the other conditions.  In"]
    #[doc = " other words, the task will be started when"]
    #[doc = " <code>"]
    #[doc = " (prerequisite-run)"]
    #[doc = " && (delay-ready"]
    #[doc = "     || any-rs-ready"]
    #[doc = "     || any-ws-ready) )"]
    #[doc = " </code>"]
    #[doc = " Only allowed to be called as long as the scheduler is running, that"]
    #[doc = " is one of the following conditions is met:"]
    #[doc = ""]
    #[doc = " - #GNUNET_SCHEDULER_run has been called and has not returned yet"]
    #[doc = " - #GNUNET_SCHEDULER_driver_init has been run and"]
    #[doc = "   #GNUNET_SCHEDULER_driver_done has not been called yet"]
    #[doc = ""]
    #[doc = " @param prio how important is this task?"]
    #[doc = " @param delay how long should we wait?"]
    #[doc = " @param rs set of file descriptors we want to read (can be NULL)"]
    #[doc = " @param ws set of file descriptors we want to write (can be NULL)"]
    #[doc = " @param task main function of the task"]
    #[doc = " @param task_cls closure of @a task"]
    #[doc = " @return unique task identifier for the job"]
    #[doc = "         only valid until @a task is started!"]
    pub fn GNUNET_SCHEDULER_add_select(
        prio: GNUNET_SCHEDULER_Priority,
        delay: GNUNET_TIME_Relative,
        rs: *const GNUNET_NETWORK_FDSet,
        ws: *const GNUNET_NETWORK_FDSet,
        task: GNUNET_SCHEDULER_TaskCallback,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_SCHEDULER_Task;
}
extern "C" {
    #[doc = " Sets the select function to use in the scheduler (scheduler_select)."]
    #[doc = ""]
    #[doc = " @param new_select new select function to use (NULL to reset to default)"]
    #[doc = " @param new_select_cls closure for @a new_select"]
    pub fn GNUNET_SCHEDULER_set_select(
        new_select: GNUNET_SCHEDULER_select,
        new_select_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Change the async scope for the currently executing task and (transitively)"]
    #[doc = " for all tasks scheduled by the current task after calling this function."]
    #[doc = " Nested tasks can begin their own nested async scope."]
    #[doc = ""]
    #[doc = " Once the current task is finished, the async scope ID is reset to"]
    #[doc = " its previous value."]
    #[doc = ""]
    #[doc = " Must only be called from a running task."]
    #[doc = ""]
    #[doc = " @param aid the asynchronous scope id to enter"]
    pub fn GNUNET_SCHEDULER_begin_async_scope(aid: *mut GNUNET_AsyncScopeId);
}
extern "C" {
    #[doc = " Implementation of the #GNUNET_MQ_extract_nexted_mh macro."]
    #[doc = ""]
    #[doc = " @param mh message header to extract nested message header from"]
    #[doc = " @param base_size size of the message before the nested message's header appears"]
    #[doc = " @return pointer to the nested message, does not copy the message"]
    #[doc = "         OR NULL in case of a malformed message."]
    pub fn GNUNET_MQ_extract_nested_mh_(
        mh: *const GNUNET_MessageHeader,
        base_size: u16,
    ) -> *const GNUNET_MessageHeader;
}
#[doc = " Opaque handle to an envelope."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_MQ_Envelope {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Obtain message contained in envelope."]
    #[doc = ""]
    #[doc = " @param env the envelope"]
    #[doc = " @return message contained in the envelope"]
    pub fn GNUNET_MQ_env_get_msg(env: *const GNUNET_MQ_Envelope) -> *const GNUNET_MessageHeader;
}
extern "C" {
    #[doc = " Return next envelope in queue."]
    #[doc = ""]
    #[doc = " @param env a queued envelope"]
    #[doc = " @return next one, or NULL"]
    pub fn GNUNET_MQ_env_next(env: *const GNUNET_MQ_Envelope) -> *const GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Implementation of the #GNUNET_MQ_msg_nested_mh macro."]
    #[doc = ""]
    #[doc = " @param mhp pointer to the message header pointer that will be changed to allocate at"]
    #[doc = "        the newly allocated space for the message."]
    #[doc = " @param base_size size of the data before the nested message"]
    #[doc = " @param type type of the message in the envelope"]
    #[doc = " @param nested_mh the message to append to the message after base_size"]
    pub fn GNUNET_MQ_msg_nested_mh_(
        mhp: *mut *mut GNUNET_MessageHeader,
        base_size: u16,
        type_: u16,
        nested_mh: *const GNUNET_MessageHeader,
    ) -> *mut GNUNET_MQ_Envelope;
}
#[doc = " Opaque handle to a message queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_MQ_Handle {
    _unused: [u8; 0],
}
#[doc = " Failed to read message from the network."]
#[doc = " FIXME: Likely not properly distinguished"]
#[doc = " from TIMEOUT case in the code!"]
pub const GNUNET_MQ_Error_GNUNET_MQ_ERROR_READ: GNUNET_MQ_Error = 1;
#[doc = " FIXME: document!"]
pub const GNUNET_MQ_Error_GNUNET_MQ_ERROR_WRITE: GNUNET_MQ_Error = 2;
#[doc = " FIXME: document!"]
pub const GNUNET_MQ_Error_GNUNET_MQ_ERROR_TIMEOUT: GNUNET_MQ_Error = 4;
#[doc = " We received a message that was malformed and thus"]
#[doc = " could not be passed to its handler."]
pub const GNUNET_MQ_Error_GNUNET_MQ_ERROR_MALFORMED: GNUNET_MQ_Error = 8;
#[doc = " We received a message for which we have no matching"]
#[doc = " handler."]
pub const GNUNET_MQ_Error_GNUNET_MQ_ERROR_NO_MATCH: GNUNET_MQ_Error = 16;
#[doc = " Error codes for the queue."]
pub type GNUNET_MQ_Error = ::std::os::raw::c_uint;
#[doc = " Lowest priority, i.e. background traffic (i.e. NSE, FS)."]
#[doc = " This is the default!"]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PRIO_BACKGROUND: GNUNET_MQ_PriorityPreferences =
    0;
#[doc = " Best-effort traffic (i.e. CADET relay, DHT)"]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PRIO_BEST_EFFORT: GNUNET_MQ_PriorityPreferences =
    1;
#[doc = " Urgent traffic (local peer, i.e. Conversation)."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PRIO_URGENT: GNUNET_MQ_PriorityPreferences = 2;
#[doc = " Highest priority, control traffic (i.e. CORE/CADET KX)."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PRIO_CRITICAL_CONTROL:
    GNUNET_MQ_PriorityPreferences = 3;
#[doc = " Bit mask to apply to extract the priority bits."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PRIORITY_MASK: GNUNET_MQ_PriorityPreferences = 3;
#[doc = " Flag to indicate that unreliable delivery is acceptable.  This"]
#[doc = " means TRANSPORT will not attempt to receive an"]
#[doc = " acknowledgment. CORE will just pass this flag through.  CADET"]
#[doc = " will use unreliable delivery if this flag is set."]
#[doc = ""]
#[doc = " Note that even without this flag, messages may be lost by"]
#[doc = " TRANSPORT and CORE."]
#[doc = ""]
#[doc = " Thus, how \"strong\" the semantics of reliable delivery are depends"]
#[doc = " on the layer!"]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PREF_UNRELIABLE: GNUNET_MQ_PriorityPreferences =
    16;
#[doc = " Flag to indicate that low latency is important.  This flag must"]
#[doc = " generally not be used in combination with"]
#[doc = " #GNUNET_MQ_PREF_CORKING_ALLOWED as it would be a contradiction."]
#[doc = " When this flags is set, the envelope may skip forward in the"]
#[doc = " queue (depending on priority) and also TRANSPORT should attempt"]
#[doc = " to pick a communicator with particularly low latency."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PREF_LOW_LATENCY: GNUNET_MQ_PriorityPreferences =
    32;
#[doc = " Flag to indicate that CORKing is acceptable. This allows the"]
#[doc = " receiver to delay transmission in hope of combining this message"]
#[doc = " with other messages into a larger transmission with less"]
#[doc = " per-message overhead."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PREF_CORK_ALLOWED: GNUNET_MQ_PriorityPreferences =
    64;
#[doc = " Flag to indicate that high bandwidth is desired. This flag"]
#[doc = " indicates that the method chosen for transmission should focus on"]
#[doc = " overall goodput.  It rarely makes sense to combine this flag with"]
#[doc = " #GNUNET_MQ_PREF_LOW_LATENCY."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PREF_GOODPUT: GNUNET_MQ_PriorityPreferences = 128;
#[doc = " Flag to indicate that out-of-order delivery is OK."]
pub const GNUNET_MQ_PriorityPreferences_GNUNET_MQ_PREF_OUT_OF_ORDER: GNUNET_MQ_PriorityPreferences =
    256;
#[doc = " Per envelope preferences and priorities."]
pub type GNUNET_MQ_PriorityPreferences = ::std::os::raw::c_uint;
#[doc = " Called when a message has been received."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param msg the received message"]
pub type GNUNET_MQ_MessageCallback = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, msg: *const GNUNET_MessageHeader),
>;
#[doc = " Called when a message needs to be validated."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param msg the received message"]
#[doc = " @return #GNUNET_OK if the message is well-formed,"]
#[doc = "         #GNUNET_SYSERR if not"]
pub type GNUNET_MQ_MessageValidationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        msg: *const GNUNET_MessageHeader,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Signature of functions implementing the"]
#[doc = " sending functionality of a message queue."]
#[doc = ""]
#[doc = " @param mq the message queue"]
#[doc = " @param msg the message to send"]
#[doc = " @param impl_state state of the implementation"]
pub type GNUNET_MQ_SendImpl = ::std::option::Option<
    unsafe extern "C" fn(
        mq: *mut GNUNET_MQ_Handle,
        msg: *const GNUNET_MessageHeader,
        impl_state: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Signature of functions implementing the"]
#[doc = " destruction of a message queue."]
#[doc = " Implementations must not free @a mq, but should"]
#[doc = " take care of @a impl_state."]
#[doc = ""]
#[doc = " @param mq the message queue to destroy"]
#[doc = " @param impl_state state of the implementation"]
pub type GNUNET_MQ_DestroyImpl = ::std::option::Option<
    unsafe extern "C" fn(mq: *mut GNUNET_MQ_Handle, impl_state: *mut ::std::os::raw::c_void),
>;
#[doc = " Implementation function that cancels the currently sent message."]
#[doc = ""]
#[doc = " @param mq message queue"]
#[doc = " @param impl_state state specific to the implementation"]
pub type GNUNET_MQ_CancelImpl = ::std::option::Option<
    unsafe extern "C" fn(mq: *mut GNUNET_MQ_Handle, impl_state: *mut ::std::os::raw::c_void),
>;
#[doc = " Generic error handler, called with the appropriate"]
#[doc = " error code and the same closure specified at the creation of"]
#[doc = " the message queue."]
#[doc = " Not every message queue implementation supports an error handler."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param error error code"]
pub type GNUNET_MQ_ErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, error: GNUNET_MQ_Error),
>;
extern "C" {
    #[doc = " Insert @a env into the envelope DLL starting at @a env_head"]
    #[doc = " Note that @a env must not be in any MQ while this function"]
    #[doc = " is used with DLLs defined outside of the MQ module.  This"]
    #[doc = " is just in case some application needs to also manage a"]
    #[doc = " FIFO of envelopes independent of MQ itself and wants to"]
    #[doc = " re-use the pointers internal to @a env.  Use with caution."]
    #[doc = ""]
    #[doc = " @param[in|out] env_head of envelope DLL"]
    #[doc = " @param[in|out] env_tail tail of envelope DLL"]
    #[doc = " @param[in|out] env element to insert at the tail"]
    pub fn GNUNET_MQ_dll_insert_head(
        env_head: *mut *mut GNUNET_MQ_Envelope,
        env_tail: *mut *mut GNUNET_MQ_Envelope,
        env: *mut GNUNET_MQ_Envelope,
    );
}
extern "C" {
    #[doc = " Insert @a env into the envelope DLL starting at @a env_head"]
    #[doc = " Note that @a env must not be in any MQ while this function"]
    #[doc = " is used with DLLs defined outside of the MQ module.  This"]
    #[doc = " is just in case some application needs to also manage a"]
    #[doc = " FIFO of envelopes independent of MQ itself and wants to"]
    #[doc = " re-use the pointers internal to @a env.  Use with caution."]
    #[doc = ""]
    #[doc = " @param[in|out] env_head of envelope DLL"]
    #[doc = " @param[in|out] env_tail tail of envelope DLL"]
    #[doc = " @param[in|out] env element to insert at the tail"]
    pub fn GNUNET_MQ_dll_insert_tail(
        env_head: *mut *mut GNUNET_MQ_Envelope,
        env_tail: *mut *mut GNUNET_MQ_Envelope,
        env: *mut GNUNET_MQ_Envelope,
    );
}
extern "C" {
    #[doc = " Remove @a env from the envelope DLL starting at @a env_head."]
    #[doc = " Note that @a env must not be in any MQ while this function"]
    #[doc = " is used with DLLs defined outside of the MQ module. This"]
    #[doc = " is just in case some application needs to also manage a"]
    #[doc = " FIFO of envelopes independent of MQ itself and wants to"]
    #[doc = " re-use the pointers internal to @a env.  Use with caution."]
    #[doc = ""]
    #[doc = " @param[in|out] env_head of envelope DLL"]
    #[doc = " @param[in|out] env_tail tail of envelope DLL"]
    #[doc = " @param[in|out] env element to remove from the DLL"]
    pub fn GNUNET_MQ_dll_remove(
        env_head: *mut *mut GNUNET_MQ_Envelope,
        env_tail: *mut *mut GNUNET_MQ_Envelope,
        env: *mut GNUNET_MQ_Envelope,
    );
}
extern "C" {
    #[doc = " Copy an array of handlers."]
    #[doc = ""]
    #[doc = " Useful if the array has been declared in local memory and needs to be"]
    #[doc = " persisted for future use."]
    #[doc = ""]
    #[doc = " @param handlers Array of handlers to be copied."]
    #[doc = " @return A newly allocated array of handlers."]
    #[doc = "         Needs to be freed with #GNUNET_free."]
    pub fn GNUNET_MQ_copy_handlers(
        handlers: *const GNUNET_MQ_MessageHandler,
    ) -> *mut GNUNET_MQ_MessageHandler;
}
extern "C" {
    #[doc = " Copy an array of handlers, appending AGPL handler."]
    #[doc = ""]
    #[doc = " Useful if the array has been declared in local memory and needs to be"]
    #[doc = " persisted for future use."]
    #[doc = ""]
    #[doc = " @param handlers Array of handlers to be copied. Can be NULL (nothing done)."]
    #[doc = " @param agpl_handler function to call for AGPL handling"]
    #[doc = " @param agpl_cls closure for @a agpl_handler"]
    #[doc = " @return A newly allocated array of handlers."]
    #[doc = "         Needs to be freed with #GNUNET_free."]
    pub fn GNUNET_MQ_copy_handlers2(
        handlers: *const GNUNET_MQ_MessageHandler,
        agpl_handler: GNUNET_MQ_MessageCallback,
        agpl_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_MQ_MessageHandler;
}
extern "C" {
    #[doc = " Count the handlers in a handler array."]
    #[doc = ""]
    #[doc = " @param handlers Array of handlers to be counted."]
    #[doc = " @return The number of handlers in the array."]
    pub fn GNUNET_MQ_count_handlers(
        handlers: *const GNUNET_MQ_MessageHandler,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " Message handler for a specific message type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_MQ_MessageHandler {
    #[doc = " Callback to validate a message of the specified @e type."]
    #[doc = " The closure given to @e mv will be this struct (not @e ctx)."]
    #[doc = " Using NULL means only size-validation using"]
    #[doc = " @e expected_size.  In this case, @e expected_size must"]
    #[doc = " be non-zero."]
    pub mv: GNUNET_MQ_MessageValidationCallback,
    #[doc = " Callback, called every time a new message of"]
    #[doc = " the specified @e type has been received."]
    #[doc = " The closure given to @e mv will be this struct (not @e ctx)."]
    pub cb: GNUNET_MQ_MessageCallback,
    #[doc = " Closure for @e mv and @e cb."]
    pub cls: *mut ::std::os::raw::c_void,
    #[doc = " Type of the message this handler covers, in host byte order."]
    pub type_: u16,
    #[doc = " Expected size of messages of this type.  Minimum size of the"]
    #[doc = " message if @e mv is non-NULL.  Messages of the given type will be"]
    #[doc = " discarded (and the connection closed with an error reported to"]
    #[doc = " the application) if they do not have the right size."]
    pub expected_size: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_MQ_MessageHandler() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_MQ_MessageHandler>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_MQ_MessageHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_MQ_MessageHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_MQ_MessageHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_MQ_MessageHandler>())).mv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MQ_MessageHandler),
            "::",
            stringify!(mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_MQ_MessageHandler>())).cb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MQ_MessageHandler),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_MQ_MessageHandler>())).cls as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MQ_MessageHandler),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_MQ_MessageHandler>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MQ_MessageHandler),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_MQ_MessageHandler>())).expected_size as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_MQ_MessageHandler),
            "::",
            stringify!(expected_size)
        )
    );
}
extern "C" {
    #[doc = " Call the message message handler that was registered"]
    #[doc = " for the type of the given message in the given @a handlers list."]
    #[doc = ""]
    #[doc = " This function is indented to be used for the implementation"]
    #[doc = " of message queues."]
    #[doc = ""]
    #[doc = " @param handlers a set of handlers"]
    #[doc = " @param mh message to dispatch"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_NO if no handler matched,"]
    #[doc = "         #GNUNET_SYSERR if message was rejected by check function"]
    pub fn GNUNET_MQ_handle_message(
        handlers: *const GNUNET_MQ_MessageHandler,
        mh: *const GNUNET_MessageHeader,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new envelope."]
    #[doc = ""]
    #[doc = " @param mhp message header to store the allocated message header in, can be NULL"]
    #[doc = " @param size size of the message to allocate"]
    #[doc = " @param type type of the message, will be set in the allocated message"]
    #[doc = " @return the allocated MQ message"]
    pub fn GNUNET_MQ_msg_(
        mhp: *mut *mut GNUNET_MessageHeader,
        size: u16,
        type_: u16,
    ) -> *mut GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Create a new envelope by copying an existing message."]
    #[doc = ""]
    #[doc = " @param hdr header of the message to copy"]
    #[doc = " @return envelope containing @a hdr"]
    pub fn GNUNET_MQ_msg_copy(hdr: *const GNUNET_MessageHeader) -> *mut GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Discard the message queue message, free all"]
    #[doc = " allocated resources. Must be called in the event"]
    #[doc = " that a message is created but should not actually be sent."]
    #[doc = ""]
    #[doc = " @param mqm the message to discard"]
    pub fn GNUNET_MQ_discard(mqm: *mut GNUNET_MQ_Envelope);
}
extern "C" {
    #[doc = " Function to obtain the current envelope"]
    #[doc = " from within #GNUNET_MQ_SendImpl implementations."]
    #[doc = ""]
    #[doc = " @param mq message queue to interrogate"]
    #[doc = " @return the current envelope"]
    pub fn GNUNET_MQ_get_current_envelope(mq: *mut GNUNET_MQ_Handle) -> *mut GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Function to copy an envelope.  The envelope must not yet"]
    #[doc = " be in any queue or have any options or callbacks set."]
    #[doc = ""]
    #[doc = " @param env envelope to copy"]
    #[doc = " @return copy of @a env"]
    pub fn GNUNET_MQ_env_copy(env: *mut GNUNET_MQ_Envelope) -> *mut GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Function to obtain the last envelope in the queue."]
    #[doc = ""]
    #[doc = " @param mq message queue to interrogate"]
    #[doc = " @return the last envelope in the queue"]
    pub fn GNUNET_MQ_get_last_envelope(mq: *mut GNUNET_MQ_Handle) -> *mut GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Set application-specific options for this envelope."]
    #[doc = " Overrides the options set for the queue with"]
    #[doc = " #GNUNET_MQ_set_options() for this message only."]
    #[doc = ""]
    #[doc = " @param env message to set options for"]
    #[doc = " @param pp priority and preferences to set for @a env"]
    pub fn GNUNET_MQ_env_set_options(
        env: *mut GNUNET_MQ_Envelope,
        pp: GNUNET_MQ_PriorityPreferences,
    );
}
extern "C" {
    #[doc = " Get performance preferences set for this envelope."]
    #[doc = ""]
    #[doc = " @param env message to set options for"]
    #[doc = " @return priority and preferences to use"]
    pub fn GNUNET_MQ_env_get_options(env: *mut GNUNET_MQ_Envelope)
        -> GNUNET_MQ_PriorityPreferences;
}
extern "C" {
    #[doc = " Combine performance preferences set for different"]
    #[doc = " envelopes that are being combined into one larger envelope."]
    #[doc = ""]
    #[doc = " @param p1 one set of preferences"]
    #[doc = " @param p2 second set of preferences"]
    #[doc = " @return combined priority and preferences to use"]
    pub fn GNUNET_MQ_env_combine_options(
        p1: GNUNET_MQ_PriorityPreferences,
        p2: GNUNET_MQ_PriorityPreferences,
    ) -> GNUNET_MQ_PriorityPreferences;
}
extern "C" {
    #[doc = " Remove the first envelope that has not yet been sent from the message"]
    #[doc = " queue and return it."]
    #[doc = ""]
    #[doc = " @param mq queue to remove envelope from"]
    #[doc = " @return NULL if queue is empty (or has no envelope that is not under transmission)"]
    pub fn GNUNET_MQ_unsent_head(mq: *mut GNUNET_MQ_Handle) -> *mut GNUNET_MQ_Envelope;
}
extern "C" {
    #[doc = " Set application-specific options for this queue."]
    #[doc = ""]
    #[doc = " @param mq message queue to set options for"]
    #[doc = " @param pp priority and preferences to use by default"]
    pub fn GNUNET_MQ_set_options(mq: *mut GNUNET_MQ_Handle, pp: GNUNET_MQ_PriorityPreferences);
}
extern "C" {
    #[doc = " Obtain the current length of the message queue."]
    #[doc = ""]
    #[doc = " @param mq queue to inspect"]
    #[doc = " @return number of queued, non-transmitted messages"]
    pub fn GNUNET_MQ_get_length(mq: *mut GNUNET_MQ_Handle) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Send a message with the given message queue."]
    #[doc = " May only be called once per message."]
    #[doc = ""]
    #[doc = " @param mq message queue"]
    #[doc = " @param ev the envelope with the message to send."]
    pub fn GNUNET_MQ_send(mq: *mut GNUNET_MQ_Handle, ev: *mut GNUNET_MQ_Envelope);
}
extern "C" {
    #[doc = " Send a copy of a message with the given message queue."]
    #[doc = " Can be called repeatedly on the same envelope."]
    #[doc = ""]
    #[doc = " @param mq message queue"]
    #[doc = " @param ev the envelope with the message to send."]
    pub fn GNUNET_MQ_send_copy(mq: *mut GNUNET_MQ_Handle, ev: *const GNUNET_MQ_Envelope);
}
extern "C" {
    #[doc = " Cancel sending the message. Message must have been sent with"]
    #[doc = " #GNUNET_MQ_send before.  May not be called after the notify sent"]
    #[doc = " callback has been called"]
    #[doc = ""]
    #[doc = " @param ev queued envelope to cancel"]
    pub fn GNUNET_MQ_send_cancel(ev: *mut GNUNET_MQ_Envelope);
}
extern "C" {
    #[doc = " Associate the assoc_data in @a mq with a unique request id."]
    #[doc = ""]
    #[doc = " @param mq message queue, id will be unique for the queue"]
    #[doc = " @param assoc_data to associate"]
    pub fn GNUNET_MQ_assoc_add(
        mq: *mut GNUNET_MQ_Handle,
        assoc_data: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Get the data associated with a @a request_id in a queue"]
    #[doc = ""]
    #[doc = " @param mq the message queue with the association"]
    #[doc = " @param request_id the request id we are interested in"]
    #[doc = " @return the associated data"]
    pub fn GNUNET_MQ_assoc_get(
        mq: *mut GNUNET_MQ_Handle,
        request_id: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove the association for a @a request_id"]
    #[doc = ""]
    #[doc = " @param mq the message queue with the association"]
    #[doc = " @param request_id the request id we want to remove"]
    #[doc = " @return the associated data"]
    pub fn GNUNET_MQ_assoc_remove(
        mq: *mut GNUNET_MQ_Handle,
        request_id: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Create a message queue for the specified handlers."]
    #[doc = ""]
    #[doc = " @param send function the implements sending messages"]
    #[doc = " @param destroy function that implements destroying the queue"]
    #[doc = " @param cancel function that implements canceling a message"]
    #[doc = " @param impl_state for the queue, passed to @a send, @a destroy and @a cancel"]
    #[doc = " @param handlers array of message handlers"]
    #[doc = " @param error_handler handler for read and write errors"]
    #[doc = " @param cls closure for message handlers and error handler"]
    #[doc = " @return a new message queue"]
    pub fn GNUNET_MQ_queue_for_callbacks(
        send: GNUNET_MQ_SendImpl,
        destroy: GNUNET_MQ_DestroyImpl,
        cancel: GNUNET_MQ_CancelImpl,
        impl_state: *mut ::std::os::raw::c_void,
        handlers: *const GNUNET_MQ_MessageHandler,
        error_handler: GNUNET_MQ_ErrorHandler,
        cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_MQ_Handle;
}
extern "C" {
    #[doc = " Change the closure argument in all of the `handlers` of the"]
    #[doc = " @a mq."]
    #[doc = ""]
    #[doc = " @param mq to modify"]
    #[doc = " @param handlers_cls new closure to use"]
    pub fn GNUNET_MQ_set_handlers_closure(
        mq: *mut GNUNET_MQ_Handle,
        handlers_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Call a callback once the envelope has been sent, that is,"]
    #[doc = " sending it can not be canceled anymore."]
    #[doc = " There can be only one notify sent callback per envelope."]
    #[doc = ""]
    #[doc = " @param ev message to call the notify callback for"]
    #[doc = " @param cb the notify callback"]
    #[doc = " @param cb_cls closure for the callback"]
    pub fn GNUNET_MQ_notify_sent(
        ev: *mut GNUNET_MQ_Envelope,
        cb: GNUNET_SCHEDULER_TaskCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Destroy the message queue."]
    #[doc = ""]
    #[doc = " @param mq message queue to destroy"]
    pub fn GNUNET_MQ_destroy(mq: *mut GNUNET_MQ_Handle);
}
#[doc = " Handle we return for callbacks registered to be"]
#[doc = " notified when #GNUNET_MQ_destroy() is called on a queue."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_MQ_DestroyNotificationHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Register function to be called whenever @a mq is being"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " @param mq message queue to watch"]
    #[doc = " @param cb function to call on @a mq destruction"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle for #GNUNET_MQ_destroy_notify_cancel()."]
    pub fn GNUNET_MQ_destroy_notify(
        mq: *mut GNUNET_MQ_Handle,
        cb: GNUNET_SCHEDULER_TaskCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_MQ_DestroyNotificationHandle;
}
extern "C" {
    #[doc = " Cancel registration from #GNUNET_MQ_destroy_notify()."]
    #[doc = ""]
    #[doc = " @param dnh handle for registration to cancel"]
    pub fn GNUNET_MQ_destroy_notify_cancel(dnh: *mut GNUNET_MQ_DestroyNotificationHandle);
}
extern "C" {
    #[doc = " Call the message message handler that was registered"]
    #[doc = " for the type of the given message in the given message queue."]
    #[doc = ""]
    #[doc = " This function is indented to be used for the implementation"]
    #[doc = " of message queues."]
    #[doc = ""]
    #[doc = " @param mq message queue with the handlers"]
    #[doc = " @param mh message to dispatch"]
    pub fn GNUNET_MQ_inject_message(mq: *mut GNUNET_MQ_Handle, mh: *const GNUNET_MessageHeader);
}
extern "C" {
    #[doc = " Call the error handler of a message queue with the given"]
    #[doc = " error code.  If there is no error handler, log a warning."]
    #[doc = ""]
    #[doc = " This function is intended to be used for the implementation"]
    #[doc = " of message queues."]
    #[doc = ""]
    #[doc = " @param mq message queue"]
    #[doc = " @param error the error type"]
    pub fn GNUNET_MQ_inject_error(mq: *mut GNUNET_MQ_Handle, error: GNUNET_MQ_Error);
}
extern "C" {
    #[doc = " Call the send implementation for the next queued message, if any."]
    #[doc = " Calls the send notification for the current message unless"]
    #[doc = " #GNUNET_MQ_impl_send_in_flight was called for this envelope."]
    #[doc = ""]
    #[doc = " Only useful for implementing message queues, results in undefined"]
    #[doc = " behavior if not used carefully."]
    #[doc = ""]
    #[doc = " @param mq message queue to send the next message with"]
    pub fn GNUNET_MQ_impl_send_continue(mq: *mut GNUNET_MQ_Handle);
}
extern "C" {
    #[doc = " Call the send notification for the current message, but do not"]
    #[doc = " try to send the next message until #gnunet_mq_impl_send_continue"]
    #[doc = " is called."]
    #[doc = ""]
    #[doc = " Only useful for implementing message queues, results in undefined"]
    #[doc = " behavior if not used carefully."]
    #[doc = ""]
    #[doc = " @param mq message queue to send the next message with"]
    pub fn GNUNET_MQ_impl_send_in_flight(mq: *mut GNUNET_MQ_Handle);
}
extern "C" {
    #[doc = " Get the implementation state associated with the"]
    #[doc = " message queue."]
    #[doc = ""]
    #[doc = " While the GNUNET_MQ_Impl* callbacks receive the"]
    #[doc = " implementation state, continuations that are scheduled"]
    #[doc = " by the implementation function often only have one closure"]
    #[doc = " argument, with this function it is possible to get at the"]
    #[doc = " implementation state when only passing the `struct GNUNET_MQ_Handle`"]
    #[doc = " as closure."]
    #[doc = ""]
    #[doc = " @param mq message queue with the current message"]
    #[doc = " @return message to send, never NULL"]
    pub fn GNUNET_MQ_impl_state(mq: *mut GNUNET_MQ_Handle) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the message that should currently be sent."]
    #[doc = " Fails if there is no current message."]
    #[doc = " Only useful for implementing message queues,"]
    #[doc = " results in undefined behavior if not used carefully."]
    #[doc = ""]
    #[doc = " @param mq message queue with the current message"]
    #[doc = " @return message to send, never NULL"]
    pub fn GNUNET_MQ_impl_current(mq: *mut GNUNET_MQ_Handle) -> *const GNUNET_MessageHeader;
}
#[doc = " No preference was expressed."]
pub const GNUNET_MQ_PreferenceKind_GNUNET_MQ_PREFERENCE_NONE: GNUNET_MQ_PreferenceKind = 0;
#[doc = " The preferred transmission for this envelope focuses on"]
#[doc = " maximizing bandwidth."]
pub const GNUNET_MQ_PreferenceKind_GNUNET_MQ_PREFERENCE_BANDWIDTH: GNUNET_MQ_PreferenceKind = 1;
#[doc = " The preferred transmission for this envelope foces on"]
#[doc = " minimizing latency."]
pub const GNUNET_MQ_PreferenceKind_GNUNET_MQ_PREFERENCE_LATENCY: GNUNET_MQ_PreferenceKind = 2;
#[doc = " The preferred transmission for this envelope foces on"]
#[doc = " reliability."]
pub const GNUNET_MQ_PreferenceKind_GNUNET_MQ_PREFERENCE_RELIABILITY: GNUNET_MQ_PreferenceKind = 3;
#[doc = " Enum defining all known preference categories."]
#[doc = ""]
#[doc = " @deprecated will be replaced by `enum GNUNET_MQ_PriorityPreference`"]
pub type GNUNET_MQ_PreferenceKind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Convert an `enum GNUNET_MQ_PreferenceType` to a string"]
    #[doc = ""]
    #[doc = " @param type the preference type"]
    #[doc = " @return a string or NULL if invalid"]
    #[doc = ""]
    #[doc = " @deprecated will be replaced by `enum GNUNET_MQ_PriorityPreference`"]
    pub fn GNUNET_MQ_preference_to_string(
        type_: GNUNET_MQ_PreferenceKind,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if the port or UNIXPATH of the given @a service_name"]
    #[doc = " is in use and thus (most likely) the respective service is up."]
    #[doc = ""]
    #[doc = " @param cfg our configuration"]
    #[doc = " @param service_name name of the service to connect to"]
    #[doc = " @return #GNUNET_YES if the service is (likely) up (or running remotely),"]
    #[doc = "         #GNUNET_NO if the service is (definitively) down,"]
    #[doc = "         #GNUNET_SYSERR if the configuration does not give us"]
    #[doc = "          the necessary information about the service, or if"]
    #[doc = "          we could not check (i.e. socket() failed)"]
    pub fn GNUNET_CLIENT_test(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        service_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a message queue to connect to a GNUnet service."]
    #[doc = " If handlers are specified, receive messages from the connection."]
    #[doc = ""]
    #[doc = " @param connection the client connection"]
    #[doc = " @param handlers handlers for receiving messages, can be NULL"]
    #[doc = " @param error_handler error handler"]
    #[doc = " @param error_handler_cls closure for the @a error_handler"]
    #[doc = " @return the message queue, NULL on error"]
    pub fn GNUNET_CLIENT_connect(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        service_name: *const ::std::os::raw::c_char,
        handlers: *const GNUNET_MQ_MessageHandler,
        error_handler: GNUNET_MQ_ErrorHandler,
        error_handler_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_MQ_Handle;
}
#[doc = " @brief General context for command line processors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_GETOPT_CommandLineProcessorContext {
    #[doc = " Name of the application"]
    pub binaryName: *const ::std::os::raw::c_char,
    #[doc = " Name of application with option summary"]
    pub binaryOptions: *const ::std::os::raw::c_char,
    #[doc = " Array with all command line options."]
    pub allOptions: *const GNUNET_GETOPT_CommandLineOption,
    #[doc = " Original command line"]
    pub argv: *const *mut ::std::os::raw::c_char,
    #[doc = " Total number of argv's."]
    pub argc: ::std::os::raw::c_uint,
    #[doc = " Current argument."]
    pub currentArgument: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_GNUNET_GETOPT_CommandLineProcessorContext() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_GETOPT_CommandLineProcessorContext>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_GETOPT_CommandLineProcessorContext>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineProcessorContext>())).binaryName
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext),
            "::",
            stringify!(binaryName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineProcessorContext>())).binaryOptions
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext),
            "::",
            stringify!(binaryOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineProcessorContext>())).allOptions
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext),
            "::",
            stringify!(allOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineProcessorContext>())).argv as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineProcessorContext>())).argc as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineProcessorContext>())).currentArgument
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineProcessorContext),
            "::",
            stringify!(currentArgument)
        )
    );
}
#[doc = " @brief Process a command line option"]
#[doc = ""]
#[doc = " @param ctx context for all options"]
#[doc = " @param scls specific closure (for this processor)"]
#[doc = " @param option long name of the option (i.e. \"config\" for --config)"]
#[doc = " @param value argument, NULL if none was given"]
#[doc = " @return #GNUNET_OK to continue processing other options, #GNUNET_SYSERR to abort"]
pub type GNUNET_GETOPT_CommandLineOptionProcessor = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut GNUNET_GETOPT_CommandLineProcessorContext,
        scls: *mut ::std::os::raw::c_void,
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief Definition of a command line option."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_GETOPT_CommandLineOption {
    #[doc = " Short name of the option."]
    pub shortName: ::std::os::raw::c_char,
    #[doc = " Long name of the option (may not be NULL)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Name of the argument for the user in help text"]
    pub argumentHelp: *const ::std::os::raw::c_char,
    #[doc = " Help text for the option (description)"]
    pub description: *const ::std::os::raw::c_char,
    #[doc = " Is an argument required?  #GNUNET_NO (includes optional) or"]
    #[doc = " #GNUNET_YES (required)"]
    pub require_argument: ::std::os::raw::c_int,
    #[doc = " Is the presence of this option mandatory?"]
    pub option_mandatory: ::std::os::raw::c_int,
    #[doc = " Is the option exclusive?"]
    pub option_exclusive: ::std::os::raw::c_int,
    #[doc = " Handler for the option."]
    pub processor: GNUNET_GETOPT_CommandLineOptionProcessor,
    #[doc = " Function to call on @e scls to clean up after processing all"]
    #[doc = " the arguments. Can be NULL."]
    pub cleaner: ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void)>,
    #[doc = " Specific closure to pass to the processor."]
    pub scls: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_GNUNET_GETOPT_CommandLineOption() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_GETOPT_CommandLineOption>(),
        72usize,
        concat!("Size of: ", stringify!(GNUNET_GETOPT_CommandLineOption))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_GETOPT_CommandLineOption>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_GETOPT_CommandLineOption))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).shortName as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(shortName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).argumentHelp as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(argumentHelp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).description as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).require_argument as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(require_argument)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).option_mandatory as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(option_mandatory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).option_exclusive as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(option_exclusive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).processor as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(processor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).cleaner as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(cleaner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_GETOPT_CommandLineOption>())).scls as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_GETOPT_CommandLineOption),
            "::",
            stringify!(scls)
        )
    );
}
extern "C" {
    #[doc = " Defining the option to print the command line"]
    #[doc = " help text (-h option)."]
    #[doc = ""]
    #[doc = " @param about string with brief description of the application"]
    pub fn GNUNET_GETOPT_option_help(
        about: *const ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a `long long` with an offset to add to the current"]
    #[doc = " system time to construct the time seen by the application. Used for"]
    #[doc = " debugging / testing."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param[out] val set to the time specified at the command line"]
    pub fn GNUNET_GETOPT_option_timetravel(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Define the option to print the version of"]
    #[doc = " the application (-v option)"]
    #[doc = ""]
    #[doc = " @param version string with the version number"]
    pub fn GNUNET_GETOPT_option_version(
        version: *const ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify log file name (-l option)"]
    #[doc = ""]
    #[doc = " @param[out] logfn set to the name of the logfile"]
    pub fn GNUNET_GETOPT_option_logfile(
        logfn: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a string."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] str set to the string"]
    pub fn GNUNET_GETOPT_option_string(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a filename (automatically path expanded)."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] str set to the string"]
    pub fn GNUNET_GETOPT_option_filename(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        str_: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a binary value using Crockford"]
    #[doc = " Base32 encoding."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val binary value decoded from Crockford Base32-encoded argument"]
    #[doc = " @param val_size size of @a val in bytes"]
    pub fn GNUNET_GETOPT_option_base32_fixed_size(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_void,
        val_size: usize,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a flag (which internally means setting"]
    #[doc = " an integer to 1/#GNUNET_YES/#GNUNET_OK."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to 1 if the option is present"]
    pub fn GNUNET_GETOPT_option_flag(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_int,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify an `unsigned int`."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to the value specified at the command line"]
    pub fn GNUNET_GETOPT_option_uint(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_uint,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify an uint16_t."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to the value specified at the command line"]
    pub fn GNUNET_GETOPT_option_uint16(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut u16,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify an `unsigned long long`."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to the value specified at the command line"]
    pub fn GNUNET_GETOPT_option_ulong(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_ulonglong,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a `struct GNUNET_TIME_Relative`"]
    #[doc = " (using human-readable \"fancy\" time)."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to the time specified at the command line"]
    pub fn GNUNET_GETOPT_option_relative_time(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut GNUNET_TIME_Relative,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify a `struct GNUNET_TIME_Absolute`"]
    #[doc = " (using human-readable \"fancy\" time)."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to the time specified at the command line"]
    pub fn GNUNET_GETOPT_option_absolute_time(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        argumentHelp: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut GNUNET_TIME_Absolute,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Increment @a val each time the option flag is given by one."]
    #[doc = ""]
    #[doc = " @param shortName short name of the option"]
    #[doc = " @param name long name of the option"]
    #[doc = " @param argumentHelp help text for the option argument"]
    #[doc = " @param description long help text for the option"]
    #[doc = " @param[out] val set to 1 if the option is present"]
    pub fn GNUNET_GETOPT_option_increment_uint(
        shortName: ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        val: *mut ::std::os::raw::c_uint,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Define the '-L' log level option.  Note that we do not check"]
    #[doc = " that the log level is valid here."]
    #[doc = ""]
    #[doc = " @param[out] level set to the log level"]
    pub fn GNUNET_GETOPT_option_loglevel(
        level: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Define the '-V' verbosity option.  Using the option more"]
    #[doc = " than once increments @a level each time."]
    #[doc = ""]
    #[doc = " @param[out] level set to the verbosity level"]
    pub fn GNUNET_GETOPT_option_verbose(
        level: *mut ::std::os::raw::c_uint,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Allow user to specify configuration file name (-c option)"]
    #[doc = ""]
    #[doc = " @param[out] fn set to the name of the configuration file"]
    pub fn GNUNET_GETOPT_option_cfgfile(
        fn_: *mut *mut ::std::os::raw::c_char,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Make the given option mandatory."]
    #[doc = ""]
    #[doc = " @param opt option to modify"]
    #[doc = " @return @a opt with the mandatory flag set."]
    pub fn GNUNET_GETOPT_option_mandatory(
        opt: GNUNET_GETOPT_CommandLineOption,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Make the given option mutually exclusive with other options."]
    #[doc = ""]
    #[doc = " @param opt option to modify"]
    #[doc = " @return @a opt with the exclusive flag set."]
    pub fn GNUNET_GETOPT_option_exclusive(
        opt: GNUNET_GETOPT_CommandLineOption,
    ) -> GNUNET_GETOPT_CommandLineOption;
}
extern "C" {
    #[doc = " Parse the command line."]
    #[doc = ""]
    #[doc = " @param binaryOptions Name of application with option summary"]
    #[doc = " @param allOptions defined options and handlers"]
    #[doc = " @param argc number of arguments in @a argv"]
    #[doc = " @param argv actual arguments"]
    #[doc = " @return index into argv with first non-option"]
    #[doc = "   argument, or #GNUNET_SYSERR on error"]
    pub fn GNUNET_GETOPT_run(
        binaryOptions: *const ::std::os::raw::c_char,
        allOptions: *const GNUNET_GETOPT_CommandLineOption,
        argc: ::std::os::raw::c_uint,
        argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Handle to a message stream tokenizer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_MessageStreamTokenizer {
    _unused: [u8; 0],
}
#[doc = " Functions with this signature are called whenever a"]
#[doc = " complete message is received by the tokenizer."]
#[doc = ""]
#[doc = " Do not call #GNUNET_mst_destroy from within"]
#[doc = " the scope of this callback."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param message the actual message"]
#[doc = " @return #GNUNET_OK on success,"]
#[doc = "     #GNUNET_NO to stop further processing due to disconnect (no error)"]
#[doc = "     #GNUNET_SYSERR to stop further processing due to error"]
pub type GNUNET_MessageTokenizerCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        message: *const GNUNET_MessageHeader,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Create a message stream tokenizer."]
    #[doc = ""]
    #[doc = " @param cb function to call on completed messages"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle to tokenizer"]
    pub fn GNUNET_MST_create(
        cb: GNUNET_MessageTokenizerCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_MessageStreamTokenizer;
}
extern "C" {
    #[doc = " Add incoming data to the receive buffer and call the"]
    #[doc = " callback for all complete messages."]
    #[doc = ""]
    #[doc = " @param mst tokenizer to use"]
    #[doc = " @param buf input data to add"]
    #[doc = " @param size number of bytes in @a buf"]
    #[doc = " @param purge should any excess bytes in the buffer be discarded"]
    #[doc = "       (i.e. for packet-based services like UDP)"]
    #[doc = " @param one_shot only call callback once, keep rest of message in buffer"]
    #[doc = " @return #GNUNET_OK if we are done processing (need more data)"]
    #[doc = "         #GNUNET_NO if one_shot was set and we have another message ready"]
    #[doc = "         #GNUNET_SYSERR if the data stream is corrupt"]
    pub fn GNUNET_MST_from_buffer(
        mst: *mut GNUNET_MessageStreamTokenizer,
        buf: *const ::std::os::raw::c_char,
        size: usize,
        purge: ::std::os::raw::c_int,
        one_shot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add incoming data to the receive buffer and call the"]
    #[doc = " callback for all complete messages."]
    #[doc = ""]
    #[doc = " @param mst tokenizer to use"]
    #[doc = " @param buf input data to add"]
    #[doc = " @param size number of bytes in @a buf"]
    #[doc = " @param purge should any excess bytes in the buffer be discarded"]
    #[doc = "       (i.e. for packet-based services like UDP)"]
    #[doc = " @param one_shot only call callback once, keep rest of message in buffer"]
    #[doc = " @return #GNUNET_OK if we are done processing (need more data)"]
    #[doc = "         #GNUNET_NO if one_shot was set and we have another message ready"]
    #[doc = "         #GNUNET_SYSERR if the data stream is corrupt"]
    pub fn GNUNET_MST_read(
        mst: *mut GNUNET_MessageStreamTokenizer,
        sock: *mut GNUNET_NETWORK_Handle,
        purge: ::std::os::raw::c_int,
        one_shot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain the next message from the @a mst, assuming that"]
    #[doc = " there are more unprocessed messages in the internal buffer"]
    #[doc = " of the @a mst."]
    #[doc = ""]
    #[doc = " @param mst tokenizer to use"]
    #[doc = " @param one_shot only call callback once, keep rest of message in buffer"]
    #[doc = " @return #GNUNET_OK if we are done processing (need more data)"]
    #[doc = "         #GNUNET_NO if one_shot was set and we have another message ready"]
    #[doc = "         #GNUNET_SYSERR if the data stream is corrupt"]
    pub fn GNUNET_MST_next(
        mst: *mut GNUNET_MessageStreamTokenizer,
        one_shot: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destroys a tokenizer."]
    #[doc = ""]
    #[doc = " @param mst tokenizer to destroy"]
    pub fn GNUNET_MST_destroy(mst: *mut GNUNET_MessageStreamTokenizer);
}
#[doc = " The handle to a helper process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_HELPER_Handle {
    _unused: [u8; 0],
}
#[doc = " Callback that will be called when the helper process dies. This is not called"]
#[doc = " when the helper process is stopped using GNUNET_HELPER_stop()"]
#[doc = ""]
#[doc = " @param cls the closure from GNUNET_HELPER_start()"]
pub type GNUNET_HELPER_ExceptionCallback =
    ::std::option::Option<unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[doc = " Starts a helper and begins reading from it. The helper process is"]
    #[doc = " restarted when it dies except when it is stopped using GNUNET_HELPER_stop()"]
    #[doc = " or when the exp_cb callback is not NULL."]
    #[doc = ""]
    #[doc = " @param with_control_pipe does the helper support the use of a control pipe for signalling?"]
    #[doc = " @param binary_name name of the binary to run"]
    #[doc = " @param binary_argv NULL-terminated list of arguments to give when starting the binary (this"]
    #[doc = "                    argument must not be modified by the client for"]
    #[doc = "                     the lifetime of the helper handle)"]
    #[doc = " @param cb function to call if we get messages from the helper"]
    #[doc = " @param exp_cb the exception callback to call. Set this to NULL if the helper"]
    #[doc = "          process has to be restarted automatically when it dies/crashes"]
    #[doc = " @param cb_cls closure for the above callbacks"]
    #[doc = " @return the new Handle, NULL on error"]
    pub fn GNUNET_HELPER_start(
        with_control_pipe: ::std::os::raw::c_int,
        binary_name: *const ::std::os::raw::c_char,
        binary_argv: *const *mut ::std::os::raw::c_char,
        cb: GNUNET_MessageTokenizerCallback,
        exp_cb: GNUNET_HELPER_ExceptionCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_HELPER_Handle;
}
extern "C" {
    #[doc = " Sends termination signal to the helper process.  The helper process is not"]
    #[doc = " reaped; call GNUNET_HELPER_wait() for reaping the dead helper process."]
    #[doc = ""]
    #[doc = " @param h the helper handle"]
    #[doc = " @param soft_kill if #GNUNET_YES, signals termination by closing the helper's"]
    #[doc = "          stdin; #GNUNET_NO to signal termination by sending SIGTERM to helper"]
    #[doc = " @return #GNUNET_OK on success; #GNUNET_SYSERR on error"]
    pub fn GNUNET_HELPER_kill(
        h: *mut GNUNET_HELPER_Handle,
        soft_kill: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reap the helper process.  This call is blocking (!).  The helper process"]
    #[doc = " should either be sent a termination signal before or should be dead before"]
    #[doc = " calling this function"]
    #[doc = ""]
    #[doc = " @param h the helper handle"]
    #[doc = " @return #GNUNET_OK on success; #GNUNET_SYSERR on error"]
    pub fn GNUNET_HELPER_wait(h: *mut GNUNET_HELPER_Handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free's the resources occupied by the helper handle"]
    #[doc = ""]
    #[doc = " @param h the helper handle to free"]
    pub fn GNUNET_HELPER_destroy(h: *mut GNUNET_HELPER_Handle);
}
extern "C" {
    #[doc = " Kills the helper, closes the pipe, frees the handle and calls wait() on the"]
    #[doc = " helper process"]
    #[doc = ""]
    #[doc = " @param h handle to helper to stop"]
    #[doc = " @param soft_kill if #GNUNET_YES, signals termination by closing the helper's"]
    #[doc = "          stdin; #GNUNET_NO to signal termination by sending SIGTERM to helper"]
    pub fn GNUNET_HELPER_stop(h: *mut GNUNET_HELPER_Handle, soft_kill: ::std::os::raw::c_int);
}
#[doc = " Continuation function."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param result #GNUNET_OK on success,"]
#[doc = "               #GNUNET_NO if helper process died"]
#[doc = "               #GNUNET_SYSERR during GNUNET_HELPER_destroy"]
pub type GNUNET_HELPER_Continuation = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, result: ::std::os::raw::c_int),
>;
#[doc = " Handle to cancel 'send'"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_HELPER_SendHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Send an message to the helper."]
    #[doc = ""]
    #[doc = " @param h helper to send message to"]
    #[doc = " @param msg message to send"]
    #[doc = " @param can_drop can the message be dropped if there is already one in the queue?"]
    #[doc = " @param cont continuation to run once the message is out (#GNUNET_OK on success, #GNUNET_NO"]
    #[doc = "             if the helper process died, #GNUNET_SYSERR during #GNUNET_HELPER_destroy)."]
    #[doc = " @param cont_cls closure for @a cont"]
    #[doc = " @return NULL if the message was dropped,"]
    #[doc = "         otherwise handle to cancel @a cont (actual transmission may"]
    #[doc = "         not be abortable)"]
    pub fn GNUNET_HELPER_send(
        h: *mut GNUNET_HELPER_Handle,
        msg: *const GNUNET_MessageHeader,
        can_drop: ::std::os::raw::c_int,
        cont: GNUNET_HELPER_Continuation,
        cont_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_HELPER_SendHandle;
}
extern "C" {
    #[doc = " Cancel a #GNUNET_HELPER_send operation.  If possible, transmitting"]
    #[doc = " the message is also aborted, but at least 'cont' won't be called."]
    #[doc = ""]
    #[doc = " @param sh operation to cancel"]
    pub fn GNUNET_HELPER_send_cancel(sh: *mut GNUNET_HELPER_SendHandle);
}
#[doc = " The notification context is the key datastructure for a convenience"]
#[doc = " API used for transmission of notifications to the subscriber until the"]
#[doc = " subscriber disconnects (or the notification context is destroyed, in"]
#[doc = " which case we disconnect these subscribers).  Essentially, all"]
#[doc = " (notification) messages are queued up until the subscriber is able to"]
#[doc = " read them."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_NotificationContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new notification context."]
    #[doc = ""]
    #[doc = " @param queue_length maximum number of messages to keep in"]
    #[doc = "        the notification queue; optional messages are dropped"]
    #[doc = "        if the queue gets longer than this number of messages"]
    #[doc = " @return handle to the notification context"]
    pub fn GNUNET_notification_context_create(
        queue_length: ::std::os::raw::c_uint,
    ) -> *mut GNUNET_NotificationContext;
}
extern "C" {
    #[doc = " Destroy the context, force disconnect for all subscribers."]
    #[doc = ""]
    #[doc = " @param nc context to destroy."]
    pub fn GNUNET_notification_context_destroy(nc: *mut GNUNET_NotificationContext);
}
extern "C" {
    #[doc = " Add a subscriber to the notification context."]
    #[doc = ""]
    #[doc = " @param nc context to modify"]
    #[doc = " @param mq message queue add"]
    pub fn GNUNET_notification_context_add(
        nc: *mut GNUNET_NotificationContext,
        mq: *mut GNUNET_MQ_Handle,
    );
}
extern "C" {
    #[doc = " Send a message to all subscribers of this context."]
    #[doc = ""]
    #[doc = " @param nc context to modify"]
    #[doc = " @param msg message to send"]
    #[doc = " @param can_drop can this message be dropped due to queue length limitations"]
    pub fn GNUNET_notification_context_broadcast(
        nc: *mut GNUNET_NotificationContext,
        msg: *const GNUNET_MessageHeader,
        can_drop: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Return active number of subscribers in this context."]
    #[doc = ""]
    #[doc = " @param nc context to query"]
    #[doc = " @return number of current subscribers"]
    pub fn GNUNET_notification_context_get_size(
        nc: *mut GNUNET_NotificationContext,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " Operations handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_OP_Handle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create new operations handle."]
    pub fn GNUNET_OP_create() -> *mut GNUNET_OP_Handle;
}
extern "C" {
    #[doc = " Destroy operations handle."]
    pub fn GNUNET_OP_destroy(h: *mut GNUNET_OP_Handle);
}
extern "C" {
    #[doc = " Get a unique operation ID to distinguish between asynchronous requests."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "        Operations handle."]
    #[doc = ""]
    #[doc = " @return Operation ID to use."]
    pub fn GNUNET_OP_get_next_id(h: *mut GNUNET_OP_Handle) -> u64;
}
extern "C" {
    #[doc = " Find operation by ID."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "        Operations handle."]
    #[doc = " @param op_id"]
    #[doc = "        Operation ID to look up."]
    #[doc = " @param[out] result_cb"]
    #[doc = "        If an operation was found, its result callback is returned here."]
    #[doc = " @param[out] cls"]
    #[doc = "        If an operation was found, its closure is returned here."]
    #[doc = " @param[out] ctx"]
    #[doc = "        User context."]
    #[doc = ""]
    #[doc = " @return #GNUNET_YES if an operation was found,"]
    #[doc = "         #GNUNET_NO  if not found."]
    pub fn GNUNET_OP_get(
        h: *mut GNUNET_OP_Handle,
        op_id: u64,
        result_cb: *mut GNUNET_ResultCallback,
        cls: *mut *mut ::std::os::raw::c_void,
        ctx: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a new operation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "        Operations handle."]
    #[doc = " @param result_cb"]
    #[doc = "        Function to call with the result of the operation."]
    #[doc = " @param cls"]
    #[doc = "        Closure for @a result_cb."]
    #[doc = " @param ctx"]
    #[doc = "        User context."]
    #[doc = ""]
    #[doc = " @return ID of the new operation."]
    pub fn GNUNET_OP_add(
        h: *mut GNUNET_OP_Handle,
        result_cb: GNUNET_ResultCallback,
        cls: *mut ::std::os::raw::c_void,
        ctx: *mut ::std::os::raw::c_void,
    ) -> u64;
}
extern "C" {
    #[doc = " Call the result callback of an operation and remove it."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "        Operations handle."]
    #[doc = " @param op_id"]
    #[doc = "        Operation ID."]
    #[doc = " @param result_code"]
    #[doc = "        Result of the operation."]
    #[doc = " @param data"]
    #[doc = "        Data result of the operation."]
    #[doc = " @param data_size"]
    #[doc = "        Size of @a data."]
    #[doc = " @param[out] ctx"]
    #[doc = "        User context."]
    #[doc = ""]
    #[doc = " @return #GNUNET_YES if the operation was found and removed,"]
    #[doc = "         #GNUNET_NO  if the operation was not found."]
    pub fn GNUNET_OP_result(
        h: *mut GNUNET_OP_Handle,
        op_id: u64,
        result_code: i64,
        data: *const ::std::os::raw::c_void,
        data_size: u16,
        ctx: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove / cancel an operation."]
    #[doc = ""]
    #[doc = " @param h"]
    #[doc = "        Operations handle."]
    #[doc = " @param op_id"]
    #[doc = "        Operation ID."]
    #[doc = ""]
    #[doc = " @return #GNUNET_YES if the operation was found and removed,"]
    #[doc = "         #GNUNET_NO  if the operation was not found."]
    pub fn GNUNET_OP_remove(h: *mut GNUNET_OP_Handle, op_id: u64) -> ::std::os::raw::c_int;
}
#[doc = " No standard streams should be inherited."]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_INHERIT_STD_NONE: GNUNET_OS_InheritStdioFlags = 0;
#[doc = " When this flag is set, the child process will"]
#[doc = " inherit stdin of the parent."]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_INHERIT_STD_IN: GNUNET_OS_InheritStdioFlags = 1;
#[doc = " When this flag is set, the child process will"]
#[doc = " inherit stdout of the parent."]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_INHERIT_STD_OUT: GNUNET_OS_InheritStdioFlags = 2;
#[doc = " When this flag is set, the child process will"]
#[doc = " inherit stderr of the parent."]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_INHERIT_STD_ERR: GNUNET_OS_InheritStdioFlags = 4;
#[doc = " When these flags are set, the child process will"]
#[doc = " inherit stdout and stderr of the parent."]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_INHERIT_STD_OUT_AND_ERR:
    GNUNET_OS_InheritStdioFlags = 6;
#[doc = " Use this option to have all of the standard streams"]
#[doc = " (stdin, stdout and stderror) be inherited."]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_INHERIT_STD_ALL: GNUNET_OS_InheritStdioFlags = 7;
#[doc = " Should a pipe be used to send signals to the child?"]
pub const GNUNET_OS_InheritStdioFlags_GNUNET_OS_USE_PIPE_CONTROL: GNUNET_OS_InheritStdioFlags = 8;
#[doc = " Flags that determine which of the standard streams"]
#[doc = " should be inherited by the child process."]
pub type GNUNET_OS_InheritStdioFlags = ::std::os::raw::c_uint;
#[doc = " Process information (OS-dependent)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_OS_Process {
    _unused: [u8; 0],
}
#[doc = " Return the \"PREFIX\" directory given to configure."]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_PREFIX: GNUNET_OS_InstallationPathKind = 0;
#[doc = " Return the directory where the program binaries are installed. (bin/)"]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_BINDIR: GNUNET_OS_InstallationPathKind = 1;
#[doc = " Return the directory where libraries are installed. (lib/gnunet/)"]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_LIBDIR: GNUNET_OS_InstallationPathKind = 2;
#[doc = " Return the directory where data is installed (share/gnunet/)"]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_DATADIR: GNUNET_OS_InstallationPathKind = 3;
#[doc = " Return the directory where translations are installed (share/locale/)"]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_LOCALEDIR: GNUNET_OS_InstallationPathKind =
    4;
#[doc = " Return the installation directory of this application, not"]
#[doc = " the one of the overall GNUnet installation (in case they"]
#[doc = " are different)."]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_SELF_PREFIX: GNUNET_OS_InstallationPathKind =
    5;
#[doc = " Return the prefix of the path with application icons (share/icons/)."]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_ICONDIR: GNUNET_OS_InstallationPathKind = 6;
#[doc = " Return the prefix of the path with documentation files, including the"]
#[doc = " license (share/doc/gnunet/)."]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_DOCDIR: GNUNET_OS_InstallationPathKind = 7;
#[doc = " Return the directory where helper binaries are installed (lib/gnunet/libexec/)"]
pub const GNUNET_OS_InstallationPathKind_GNUNET_OS_IPK_LIBEXECDIR: GNUNET_OS_InstallationPathKind =
    8;
#[doc = " Possible installation paths to request"]
pub type GNUNET_OS_InstallationPathKind = ::std::os::raw::c_uint;
#[doc = " The process is not known to the OS (or at"]
#[doc = " least not one of our children)."]
pub const GNUNET_OS_ProcessStatusType_GNUNET_OS_PROCESS_UNKNOWN: GNUNET_OS_ProcessStatusType = 0;
#[doc = " The process is still running."]
pub const GNUNET_OS_ProcessStatusType_GNUNET_OS_PROCESS_RUNNING: GNUNET_OS_ProcessStatusType = 1;
#[doc = " The process is paused (but could be resumed)."]
pub const GNUNET_OS_ProcessStatusType_GNUNET_OS_PROCESS_STOPPED: GNUNET_OS_ProcessStatusType = 2;
#[doc = " The process exited with a return code."]
pub const GNUNET_OS_ProcessStatusType_GNUNET_OS_PROCESS_EXITED: GNUNET_OS_ProcessStatusType = 3;
#[doc = " The process was killed by a signal."]
pub const GNUNET_OS_ProcessStatusType_GNUNET_OS_PROCESS_SIGNALED: GNUNET_OS_ProcessStatusType = 4;
#[doc = " Process status types"]
pub type GNUNET_OS_ProcessStatusType = ::std::os::raw::c_uint;
#[doc = " Project-specific data used to help the OS subsystem"]
#[doc = " find installation paths."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_OS_ProjectData {
    #[doc = " Name of a library that is installed in the \"lib/\" directory of"]
    #[doc = " the project, such as \"libgnunetutil\".  Used to locate the"]
    #[doc = " installation by scanning dependencies of the current process."]
    pub libname: *const ::std::os::raw::c_char,
    #[doc = " Name of the project that is used in the \"libexec\" prefix, For"]
    #[doc = " example, \"gnunet\".  Certain helper binaries are then expected to"]
    #[doc = " be installed in \"$PREFIX/libexec/gnunet/\" and resources in"]
    #[doc = " \"$PREFIX/share/gnunet/\"."]
    pub project_dirname: *const ::std::os::raw::c_char,
    #[doc = " Name of a project-specific binary that should be in \"$PREFIX/bin/\"."]
    #[doc = " Used to determine installation path from $PATH variable."]
    #[doc = " For example \"gnunet-arm\".  On W32, \".exe\" should be omitted."]
    pub binary_name: *const ::std::os::raw::c_char,
    #[doc = " Name of an environment variable that can be used to override"]
    #[doc = " installation path detection, for example \"GNUNET_PREFIX\"."]
    pub env_varname: *const ::std::os::raw::c_char,
    #[doc = " Alternative name of an environment variable that can be used to"]
    #[doc = " override installation path detection, if \"env_varname\" is not"]
    #[doc = " set. Again, for example, \"GNUNET_PREFIX\"."]
    pub env_varname_alt: *const ::std::os::raw::c_char,
    #[doc = " Name of an environment variable that can be used to override"]
    #[doc = " the location from which default configuration files are loaded"]
    #[doc = " from, for example \"GNUNET_BASE_CONFIG\"."]
    pub base_config_varname: *const ::std::os::raw::c_char,
    #[doc = " E-mail address for reporting bugs."]
    pub bug_email: *const ::std::os::raw::c_char,
    #[doc = " Project homepage."]
    pub homepage: *const ::std::os::raw::c_char,
    #[doc = " Configuration file name (in $XDG_CONFIG_HOME) to use."]
    pub config_file: *const ::std::os::raw::c_char,
    #[doc = " Configuration file name to use (if $XDG_CONFIG_HOME is not set)."]
    pub user_config_file: *const ::std::os::raw::c_char,
    #[doc = " String identifying the current project version."]
    pub version: *const ::std::os::raw::c_char,
    #[doc = " Non-zero means this project is part of GNU."]
    pub is_gnu: ::std::os::raw::c_int,
    #[doc = " Gettext domain for localisation, e.g. the PACKAGE macro."]
    #[doc = " Setting this field to NULL disables gettext."]
    pub gettext_domain: *mut ::std::os::raw::c_char,
    #[doc = " Gettext directory, e.g. the LOCALEDIR macro."]
    #[doc = " If this field is NULL, the path is automatically inferred."]
    pub gettext_path: *mut ::std::os::raw::c_char,
    #[doc = " URL pointing to the source code of the application.  Required for AGPL."]
    #[doc = " Setting this to NULL disables the built-in mechanism, but you must"]
    #[doc = " provide it in some other way.  If non-NULL, message type 1 and 2 are"]
    #[doc = " reserved."]
    pub agpl_url: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GNUNET_OS_ProjectData() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_OS_ProjectData>(),
        120usize,
        concat!("Size of: ", stringify!(GNUNET_OS_ProjectData))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_OS_ProjectData>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_OS_ProjectData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).libname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(libname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).project_dirname as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(project_dirname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).binary_name as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(binary_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).env_varname as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(env_varname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).env_varname_alt as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(env_varname_alt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).base_config_varname as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(base_config_varname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).bug_email as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(bug_email)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).homepage as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(homepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).config_file as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(config_file)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).user_config_file as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(user_config_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).version as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).is_gnu as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(is_gnu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).gettext_domain as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(gettext_domain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).gettext_path as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(gettext_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_OS_ProjectData>())).agpl_url as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_OS_ProjectData),
            "::",
            stringify!(agpl_url)
        )
    );
}
extern "C" {
    #[doc = " Return default project data used by 'libgnunetutil' for GNUnet."]
    pub fn GNUNET_OS_project_data_default() -> *const GNUNET_OS_ProjectData;
}
extern "C" {
    #[doc = " @return current (actual) project data."]
    pub fn GNUNET_OS_project_data_get() -> *const GNUNET_OS_ProjectData;
}
extern "C" {
    #[doc = " Setup OS subsystem with project data."]
    #[doc = ""]
    #[doc = " @param pd project data used to determine paths."]
    pub fn GNUNET_OS_init(pd: *const GNUNET_OS_ProjectData);
}
extern "C" {
    #[doc = " Get the path to a specific GNUnet installation directory or, with"]
    #[doc = " #GNUNET_OS_IPK_SELF_PREFIX, the current running apps installation"]
    #[doc = " directory."]
    #[doc = ""]
    #[doc = " @param dirkind what kind of directory is desired?"]
    #[doc = " @return a pointer to the dir path (to be freed by the caller)"]
    pub fn GNUNET_OS_installation_get_path(
        dirkind: GNUNET_OS_InstallationPathKind,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given the name of a gnunet-helper, gnunet-service or gnunet-daemon"]
    #[doc = " binary, try to prefix it with the libexec/-directory to get the"]
    #[doc = " full path."]
    #[doc = ""]
    #[doc = " @param progname name of the binary"]
    #[doc = " @return full path to the binary, if possible, otherwise copy of 'progname'"]
    pub fn GNUNET_OS_get_libexec_binary_path(
        progname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given the name of a helper, service or daemon binary construct the full"]
    #[doc = " path to the binary using the SUID_BINARY_PATH in the PATHS section of the"]
    #[doc = " configuration. If that option is not present, fall back to"]
    #[doc = " GNUNET_OS_get_libexec_binary_path. If @a progname is an absolute path, a"]
    #[doc = " copy of this path is returned."]
    #[doc = ""]
    #[doc = " @param cfg configuration to inspect"]
    #[doc = " @param progname name of the binary"]
    #[doc = " @return full path to the binary, if possible, a copy of @a progname"]
    #[doc = "         otherwise"]
    pub fn GNUNET_OS_get_suid_binary_path(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        progname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " Callback function invoked for each interface found."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param name name of the interface (can be NULL for unknown)"]
#[doc = " @param isDefault is this presumably the default interface"]
#[doc = " @param addr address of this interface (can be NULL for unknown or unassigned)"]
#[doc = " @param broadcast_addr the broadcast address (can be NULL for unknown or unassigned)"]
#[doc = " @param netmask the network mask (can be NULL for unknown or unassigned)"]
#[doc = " @param addrlen length of the address"]
#[doc = " @return #GNUNET_OK to continue iteration, #GNUNET_SYSERR to abort"]
pub type GNUNET_OS_NetworkInterfaceProcessor = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        isDefault: ::std::os::raw::c_int,
        addr: *const sockaddr,
        broadcast_addr: *const sockaddr,
        netmask: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Enumerate all network interfaces"]
    #[doc = ""]
    #[doc = " @param proc the callback function"]
    #[doc = " @param proc_cls closure for @a proc"]
    pub fn GNUNET_OS_network_interfaces_list(
        proc_: GNUNET_OS_NetworkInterfaceProcessor,
        proc_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get process structure for current process"]
    #[doc = ""]
    #[doc = " The pointer it returns points to static memory location and must not be"]
    #[doc = " deallocated/closed"]
    #[doc = ""]
    #[doc = " @return pointer to the process sturcutre for this process"]
    pub fn GNUNET_OS_process_current() -> *mut GNUNET_OS_Process;
}
extern "C" {
    #[doc = " Sends a signal to the process"]
    #[doc = ""]
    #[doc = " @param proc pointer to process structure"]
    #[doc = " @param sig signal"]
    #[doc = " @return 0 on success, -1 on error"]
    pub fn GNUNET_OS_process_kill(
        proc_: *mut GNUNET_OS_Process,
        sig: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Cleans up process structure contents (OS-dependent) and deallocates it"]
    #[doc = ""]
    #[doc = " @param proc pointer to process structure"]
    pub fn GNUNET_OS_process_destroy(proc_: *mut GNUNET_OS_Process);
}
extern "C" {
    #[doc = " Get the pid of the process in question"]
    #[doc = ""]
    #[doc = " @param proc the process to get the pid of"]
    #[doc = ""]
    #[doc = " @return the current process id"]
    pub fn GNUNET_OS_process_get_pid(proc_: *mut GNUNET_OS_Process) -> pid_t;
}
extern "C" {
    #[doc = " Start a process."]
    #[doc = ""]
    #[doc = " @param std_inheritance a set of GNUNET_OS_INHERIT_STD_* flags"]
    #[doc = " @param pipe_stdin pipe to use to send input to child process (or NULL)"]
    #[doc = " @param pipe_stdout pipe to use to get output from child process (or NULL)"]
    #[doc = " @param pipe_stderr pipe to use to get error output from child process (or NULL)"]
    #[doc = " @param filename name of the binary"]
    #[doc = " @param argv NULL-terminated array of arguments to the process"]
    #[doc = " @return pointer to process structure of the new process, NULL on error"]
    pub fn GNUNET_OS_start_process_vap(
        std_inheritance: GNUNET_OS_InheritStdioFlags,
        pipe_stdin: *mut GNUNET_DISK_PipeHandle,
        pipe_stdout: *mut GNUNET_DISK_PipeHandle,
        pipe_stderr: *mut GNUNET_DISK_PipeHandle,
        filename: *const ::std::os::raw::c_char,
        argv: *const *mut ::std::os::raw::c_char,
    ) -> *mut GNUNET_OS_Process;
}
extern "C" {
    #[doc = " Start a process."]
    #[doc = ""]
    #[doc = " @param std_inheritance a set of GNUNET_OS_INHERIT_STD_* flags"]
    #[doc = " @param pipe_stdin pipe to use to send input to child process (or NULL)"]
    #[doc = " @param pipe_stdout pipe to use to get output from child process (or NULL)"]
    #[doc = " @param pipe_stderr pipe to use to get error output from child process (or NULL)"]
    #[doc = " @param filename name of the binary"]
    #[doc = " @param ... NULL-terminated list of arguments to the process"]
    #[doc = " @return pointer to process structure of the new process, NULL on error"]
    pub fn GNUNET_OS_start_process(
        std_inheritance: GNUNET_OS_InheritStdioFlags,
        pipe_stdin: *mut GNUNET_DISK_PipeHandle,
        pipe_stdout: *mut GNUNET_DISK_PipeHandle,
        pipe_stderr: *mut GNUNET_DISK_PipeHandle,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GNUNET_OS_Process;
}
extern "C" {
    #[doc = " Start a process."]
    #[doc = ""]
    #[doc = " @param std_inheritance a set of GNUNET_OS_INHERIT_STD_* flags"]
    #[doc = " @param pipe_stdin pipe to use to send input to child process (or NULL)"]
    #[doc = " @param pipe_stdout pipe to use to get output from child process (or NULL)"]
    #[doc = " @param pipe_stderr pipe to use to get error output from child process (or NULL)"]
    #[doc = " @param filename name of the binary"]
    #[doc = " @param va NULL-terminated list of arguments to the process"]
    #[doc = " @return pointer to process structure of the new process, NULL on error"]
    pub fn GNUNET_OS_start_process_va(
        std_inheritance: GNUNET_OS_InheritStdioFlags,
        pipe_stdin: *mut GNUNET_DISK_PipeHandle,
        pipe_stdout: *mut GNUNET_DISK_PipeHandle,
        pipe_stderr: *mut GNUNET_DISK_PipeHandle,
        filename: *const ::std::os::raw::c_char,
        va: *mut __va_list_tag,
    ) -> *mut GNUNET_OS_Process;
}
extern "C" {
    #[doc = " Start a process."]
    #[doc = ""]
    #[doc = " @param std_inheritance a set of GNUNET_OS_INHERIT_STD_* flags"]
    #[doc = " @param lsocks array of listen sockets to dup systemd-style (or NULL);"]
    #[doc = "         must be NULL on platforms where dup is not supported"]
    #[doc = " @param filename name of the binary"]
    #[doc = " @param argv NULL-terminated list of arguments to the process,"]
    #[doc = "             including the process name as the first argument"]
    #[doc = " @return pointer to process structure of the new process, NULL on error"]
    pub fn GNUNET_OS_start_process_v(
        std_inheritance: GNUNET_OS_InheritStdioFlags,
        lsocks: *const ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        argv: *const *mut ::std::os::raw::c_char,
    ) -> *mut GNUNET_OS_Process;
}
extern "C" {
    #[doc = " Start a process.  This function is similar to the GNUNET_OS_start_process_*"]
    #[doc = " except that the filename and arguments can have whole strings which contain"]
    #[doc = " the arguments.  These arguments are to be separated by spaces and are parsed"]
    #[doc = " in the order they appear.  Arguments containing spaces can be used by"]
    #[doc = " quoting them with @em \"."]
    #[doc = ""]
    #[doc = " @param std_inheritance a set of GNUNET_OS_INHERIT_STD_* flags"]
    #[doc = " @param lsocks array of listen sockets to dup systemd-style (or NULL);"]
    #[doc = "         must be NULL on platforms where dup is not supported"]
    #[doc = " @param filename name of the binary.  It is valid to have the arguments"]
    #[doc = "         in this string when they are separated by spaces."]
    #[doc = " @param ... more arguments.  Should be of type `char *`.  It is valid"]
    #[doc = "         to have the arguments in these strings when they are separated by"]
    #[doc = "         spaces.  The last argument MUST be NULL."]
    #[doc = " @return pointer to process structure of the new process, NULL on error"]
    pub fn GNUNET_OS_start_process_s(
        std_inheritance: GNUNET_OS_InheritStdioFlags,
        lsocks: *const ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GNUNET_OS_Process;
}
#[doc = " Handle to a command action."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_OS_CommandHandle {
    _unused: [u8; 0],
}
#[doc = " Type of a function to process a line of output."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param line line of output from a command, NULL for the end"]
pub type GNUNET_OS_LineProcessor = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, line: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Stop/kill a command."]
    #[doc = ""]
    #[doc = " @param cmd handle to the process"]
    pub fn GNUNET_OS_command_stop(cmd: *mut GNUNET_OS_CommandHandle);
}
extern "C" {
    #[doc = " Run the given command line and call the given function"]
    #[doc = " for each line of the output."]
    #[doc = ""]
    #[doc = " @param proc function to call for each line of the output"]
    #[doc = " @param proc_cls closure for proc"]
    #[doc = " @param timeout when to time out"]
    #[doc = " @param binary command to run"]
    #[doc = " @param ... arguments to command"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_OS_command_run(
        proc_: GNUNET_OS_LineProcessor,
        proc_cls: *mut ::std::os::raw::c_void,
        timeout: GNUNET_TIME_Relative,
        binary: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GNUNET_OS_CommandHandle;
}
extern "C" {
    #[doc = " Retrieve the status of a process."]
    #[doc = " Nonblocking version."]
    #[doc = ""]
    #[doc = " @param proc pointer to process structure"]
    #[doc = " @param type status type"]
    #[doc = " @param code return code/signal number"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_NO if the process is still running, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_OS_process_status(
        proc_: *mut GNUNET_OS_Process,
        type_: *mut GNUNET_OS_ProcessStatusType,
        code: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for a process to terminate.  The return code is discarded."]
    #[doc = " You must not use #GNUNET_OS_process_status() on the same process"]
    #[doc = " after calling this function!  This function is blocking and should"]
    #[doc = " thus only be used if the child process is known to have terminated"]
    #[doc = " or to terminate very soon."]
    #[doc = ""]
    #[doc = " @param proc pointer to process structure of the process to wait for"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_OS_process_wait(proc_: *mut GNUNET_OS_Process) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the status of a process, waiting on it if dead."]
    #[doc = " Blocking version."]
    #[doc = ""]
    #[doc = " @param proc pointer to process structure"]
    #[doc = " @param type status type"]
    #[doc = " @param code return code/signal number"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_NO if the process is still running, #GNUNET_SYSERR otherwise"]
    pub fn GNUNET_OS_process_wait_status(
        proc_: *mut GNUNET_OS_Process,
        type_: *mut GNUNET_OS_ProcessStatusType,
        code: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Connects this process to its parent via pipe;"]
    #[doc = " essentially, the parent control handler will read signal numbers"]
    #[doc = " from the #GNUNET_OS_CONTROL_PIPE (as given in an environment"]
    #[doc = " variable) and raise those signals."]
    #[doc = ""]
    #[doc = " @param cls closure (unused)"]
    pub fn GNUNET_OS_install_parent_control_handler(cls: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Check whether an executable exists and possibly"]
    #[doc = " if the suid bit is set on the file."]
    #[doc = " Attempts to find the file using the current"]
    #[doc = " PATH environment variable as a search path."]
    #[doc = ""]
    #[doc = " @param binary the name of the file to check."]
    #[doc = "        W32: must not have an .exe suffix."]
    #[doc = " @param check_suid input true if the binary should be checked for SUID (*nix)"]
    #[doc = "        W32: checks if the program has sufficient privileges by executing this"]
    #[doc = "             binary with the -d flag. -d omits a programs main loop and only"]
    #[doc = "             executes all privileged operations in an binary."]
    #[doc = " @param params parameters used for w32 privilege checking (can be NULL for != w32, or when not checking for suid/permissions )"]
    #[doc = " @return #GNUNET_YES if the file is SUID (*nix) or can be executed with current privileges (W32),"]
    #[doc = "         #GNUNET_NO if not SUID (but binary exists),"]
    #[doc = "         #GNUNET_SYSERR on error (no such binary or not executable)"]
    pub fn GNUNET_OS_check_helper_binary(
        binary: *const ::std::os::raw::c_char,
        check_suid: ::std::os::raw::c_int,
        params: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A GNUNET_PEER_Id is simply a shorter version of a \"struct"]
#[doc = " GNUNET_PeerIdentifier\" that can be used inside of a GNUnet peer to"]
#[doc = " save memory when the same identifier needs to be used over and over"]
#[doc = " again."]
pub type GNUNET_PEER_Id = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Search for a peer identity. The reference counter is not changed."]
    #[doc = ""]
    #[doc = " @param pid identity to find"]
    #[doc = " @return the interned identity or 0."]
    pub fn GNUNET_PEER_search(pid: *const GNUNET_PeerIdentity) -> GNUNET_PEER_Id;
}
extern "C" {
    #[doc = " Intern an peer identity.  If the identity is already known, its"]
    #[doc = " reference counter will be increased by one."]
    #[doc = ""]
    #[doc = " @param pid identity to intern"]
    #[doc = " @return the interned identity."]
    pub fn GNUNET_PEER_intern(pid: *const GNUNET_PeerIdentity) -> GNUNET_PEER_Id;
}
extern "C" {
    #[doc = " Change the reference counter of an interned PID."]
    #[doc = ""]
    #[doc = " @param id identity to change the RC of"]
    #[doc = " @param delta how much to change the RC"]
    pub fn GNUNET_PEER_change_rc(id: GNUNET_PEER_Id, delta: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Decrement multiple RCs of peer identities by one."]
    #[doc = ""]
    #[doc = " @param ids array of PIDs to decrement the RCs of"]
    #[doc = " @param count size of the @a ids array"]
    pub fn GNUNET_PEER_decrement_rcs(ids: *const GNUNET_PEER_Id, count: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Convert an interned PID to a normal peer identity."]
    #[doc = ""]
    #[doc = " @param id interned PID to convert"]
    #[doc = " @param pid where to write the normal peer identity"]
    pub fn GNUNET_PEER_resolve(id: GNUNET_PEER_Id, pid: *mut GNUNET_PeerIdentity);
}
extern "C" {
    #[doc = " Convert an interned PID to a normal peer identity."]
    #[doc = ""]
    #[doc = " @param id interned PID to convert"]
    #[doc = " @return pointer to peer identity, valid as long @a id is valid"]
    pub fn GNUNET_PEER_resolve2(id: GNUNET_PEER_Id) -> *const GNUNET_PeerIdentity;
}
#[doc = " Signature of any function exported by a plugin."]
#[doc = ""]
#[doc = " @param arg argument to the function (context)"]
#[doc = " @return some pointer, NULL if the plugin was"]
#[doc = "         shutdown or if there was an error, otherwise"]
#[doc = "         the plugin's API on success"]
pub type GNUNET_PLUGIN_Callback = ::std::option::Option<
    unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    #[doc = " Test if a plugin exists."]
    #[doc = ""]
    #[doc = " Note that the library must export a symbol called"]
    #[doc = " \"library_name_init\" for the test to succeed."]
    #[doc = ""]
    #[doc = " @param library_name name of the plugin to test if it is installed"]
    #[doc = " @return #GNUNET_YES if the plugin exists, #GNUNET_NO if not"]
    pub fn GNUNET_PLUGIN_test(library_name: *const ::std::os::raw::c_char)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Setup plugin (runs the \"init\" callback and returns whatever \"init\""]
    #[doc = " returned).  If \"init\" returns NULL, the plugin is unloaded."]
    #[doc = ""]
    #[doc = " Note that the library must export symbols called"]
    #[doc = " \"library_name_init\" and \"library_name_done\".  These will be called"]
    #[doc = " when the library is loaded and unloaded respectively."]
    #[doc = ""]
    #[doc = " @param library_name name of the plugin to load"]
    #[doc = " @param arg argument to the plugin initialization function"]
    #[doc = " @return whatever the initialization function returned, NULL on error"]
    pub fn GNUNET_PLUGIN_load(
        library_name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Signature of a function called by #GNUNET_PLUGIN_load_all()."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param library_name full name of the library (to be used with"]
#[doc = "        #GNUNET_PLUGIN_unload)"]
#[doc = " @param lib_ret return value from the initialization function"]
#[doc = "        of the library (same as what #GNUNET_PLUGIN_load would"]
#[doc = "        have returned for the given library name)"]
pub type GNUNET_PLUGIN_LoaderCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        library_name: *const ::std::os::raw::c_char,
        lib_ret: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Load all compatible plugins with the given base name."]
    #[doc = ""]
    #[doc = " Note that the library must export symbols called"]
    #[doc = " \"basename_ANYTHING_init\" and \"basename_ANYTHING__done\".  These will"]
    #[doc = " be called when the library is loaded and unloaded respectively."]
    #[doc = ""]
    #[doc = " @param basename basename of the plugins to load"]
    #[doc = " @param arg argument to the plugin initialization function"]
    #[doc = " @param cb function to call for each plugin found"]
    #[doc = " @param cb_cls closure for @a cb"]
    pub fn GNUNET_PLUGIN_load_all(
        basename: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
        cb: GNUNET_PLUGIN_LoaderCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Unload plugin (runs the \"done\" callback and returns whatever \"done\""]
    #[doc = " returned).  The plugin is then unloaded."]
    #[doc = ""]
    #[doc = " @param library_name name of the plugin to unload"]
    #[doc = " @param arg argument to the plugin shutdown function"]
    #[doc = " @return whatever the shutdown function returned, typically NULL"]
    #[doc = "         or a \"char *\" representing the error message"]
    pub fn GNUNET_PLUGIN_unload(
        library_name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Main function that will be run."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param args remaining command-line arguments"]
#[doc = " @param cfgfile name of the configuration file used (for saving, can be NULL!)"]
#[doc = " @param cfg configuration"]
pub type GNUNET_PROGRAM_Main = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        args: *const *mut ::std::os::raw::c_char,
        cfgfile: *const ::std::os::raw::c_char,
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ),
>;
extern "C" {
    #[doc = " Run a standard GNUnet command startup sequence (initialize loggers"]
    #[doc = " and configuration, parse options)."]
    #[doc = ""]
    #[doc = " @param argc number of command line arguments in @a argv"]
    #[doc = " @param argv command line arguments"]
    #[doc = " @param binaryName our expected name"]
    #[doc = " @param binaryHelp help text for the program"]
    #[doc = " @param options command line options"]
    #[doc = " @param task main function to run"]
    #[doc = " @param task_cls closure for @a task"]
    #[doc = " @param run_without_scheduler #GNUNET_NO start the scheduler,"]
    #[doc = "        #GNUNET_YES do not start the scheduler just run the main task"]
    #[doc = " @return #GNUNET_SYSERR on error,"]
    #[doc = "         #GNUNET_NO if successful option processing called"]
    #[doc = "                    for the program to terminate,"]
    #[doc = "         #GNUNET_OK on success (#a task was invoked)"]
    pub fn GNUNET_PROGRAM_run2(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        binaryName: *const ::std::os::raw::c_char,
        binaryHelp: *const ::std::os::raw::c_char,
        options: *const GNUNET_GETOPT_CommandLineOption,
        task: GNUNET_PROGRAM_Main,
        task_cls: *mut ::std::os::raw::c_void,
        run_without_scheduler: ::std::os::raw::c_int,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Run a standard GNUnet command startup sequence (initialize loggers"]
    #[doc = " and configuration, parse options)."]
    #[doc = ""]
    #[doc = " @param argc number of command line arguments"]
    #[doc = " @param argv command line arguments"]
    #[doc = " @param binaryName our expected name"]
    #[doc = " @param binaryHelp helptext for \"-h\" option (about the app)"]
    #[doc = " @param options command line options"]
    #[doc = " @param task main function to run"]
    #[doc = " @param task_cls closure for @a task"]
    #[doc = " @return #GNUNET_SYSERR on error,"]
    #[doc = "         #GNUNET_NO if successful option processing called"]
    #[doc = "                    for the program to terminate,"]
    #[doc = "         #GNUNET_OK on success (#a task was invoked)"]
    pub fn GNUNET_PROGRAM_run(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        binaryName: *const ::std::os::raw::c_char,
        binaryHelp: *const ::std::os::raw::c_char,
        options: *const GNUNET_GETOPT_CommandLineOption,
        task: GNUNET_PROGRAM_Main,
        task_cls: *mut ::std::os::raw::c_void,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Use defaults.  Terminates all client connections and the listen"]
#[doc = " sockets immediately upon receiving the shutdown signal."]
pub const GNUNET_SERVICE_Options_GNUNET_SERVICE_OPTION_NONE: GNUNET_SERVICE_Options = 0;
#[doc = " Do not trigger server shutdown on signal at all; instead, allow"]
#[doc = " for the user to terminate the server explicitly when needed"]
#[doc = " by calling #GNUNET_SERVICE_shutdown()."]
pub const GNUNET_SERVICE_Options_GNUNET_SERVICE_OPTION_MANUAL_SHUTDOWN: GNUNET_SERVICE_Options = 1;
#[doc = " Trigger a SOFT server shutdown on signals, allowing active"]
#[doc = " non-monitor clients to complete their transactions."]
pub const GNUNET_SERVICE_Options_GNUNET_SERVICE_OPTION_SOFT_SHUTDOWN: GNUNET_SERVICE_Options = 2;
#[doc = " Bitmask over the shutdown options."]
pub const GNUNET_SERVICE_Options_GNUNET_SERVICE_OPTION_SHUTDOWN_BITMASK: GNUNET_SERVICE_Options = 3;
#[doc = " Instead of listening on lsocks passed by the parent,"]
#[doc = " close them *after* opening our own listen socket(s)."]
pub const GNUNET_SERVICE_Options_GNUNET_SERVICE_OPTION_CLOSE_LSOCKS: GNUNET_SERVICE_Options = 4;
#[doc = " Options for the service (bitmask)."]
pub type GNUNET_SERVICE_Options = ::std::os::raw::c_uint;
#[doc = " Handle to a service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SERVICE_Handle {
    _unused: [u8; 0],
}
#[doc = " Handle to a client that is connected to a service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SERVICE_Client {
    _unused: [u8; 0],
}
#[doc = " Callback to initialize a service, called exactly once when the service is run."]
#[doc = ""]
#[doc = " @param cls closure passed to #GNUNET_SERVICE_MAIN"]
#[doc = " @param cfg configuration to use for this service"]
#[doc = " @param sh handle to the newly create service"]
pub type GNUNET_SERVICE_InitCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        cfg: *const GNUNET_CONFIGURATION_Handle,
        sh: *mut GNUNET_SERVICE_Handle,
    ),
>;
#[doc = " Callback to be called when a client connects to the service."]
#[doc = ""]
#[doc = " @param cls closure for the service"]
#[doc = " @param c the new client that connected to the service"]
#[doc = " @param mq the message queue used to send messages to the client"]
#[doc = " @return the client-specific (`internal') closure"]
pub type GNUNET_SERVICE_ConnectHandler = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        c: *mut GNUNET_SERVICE_Client,
        mq: *mut GNUNET_MQ_Handle,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback to be called when a client disconnected from the service"]
#[doc = ""]
#[doc = " @param cls closure for the service"]
#[doc = " @param c the client that disconnected"]
#[doc = " @param internal_cls the client-specific (`internal') closure"]
pub type GNUNET_SERVICE_DisconnectHandler = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        c: *mut GNUNET_SERVICE_Client,
        internal_cls: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Low-level function to start a service if the scheduler"]
    #[doc = " is already running.  Should only be used directly in"]
    #[doc = " special cases."]
    #[doc = ""]
    #[doc = " The function will launch the service with the name @a service_name"]
    #[doc = " using the @a service_options to configure its shutdown"]
    #[doc = " behavior. When clients connect or disconnect, the respective"]
    #[doc = " @a connect_cb or @a disconnect_cb functions will be called. For"]
    #[doc = " messages received from the clients, the respective @a handlers will"]
    #[doc = " be invoked; for the closure of the handlers we use the return value"]
    #[doc = " from the @a connect_cb invocation of the respective client."]
    #[doc = ""]
    #[doc = " Each handler MUST call #GNUNET_SERVICE_client_continue() after each"]
    #[doc = " message to receive further messages from this client.  If"]
    #[doc = " #GNUNET_SERVICE_client_continue() is not called within a short"]
    #[doc = " time, a warning will be logged. If delays are expected, services"]
    #[doc = " should call #GNUNET_SERVICE_client_disable_continue_warning() to"]
    #[doc = " disable the warning."]
    #[doc = ""]
    #[doc = " Clients sending invalid messages (based on @a handlers) will be"]
    #[doc = " dropped. Additionally, clients can be dropped at any time using"]
    #[doc = " #GNUNET_SERVICE_client_drop()."]
    #[doc = ""]
    #[doc = " The service must be stopped using #GNUNET_SERVICE_stop()."]
    #[doc = ""]
    #[doc = " @param service_name name of the service to run"]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param connect_cb function to call whenever a client connects"]
    #[doc = " @param disconnect_cb function to call whenever a client disconnects"]
    #[doc = " @param cls closure argument for @a connect_cb and @a disconnect_cb"]
    #[doc = " @param handlers NULL-terminated array of message handlers for the service,"]
    #[doc = "                 the closure will be set to the value returned by"]
    #[doc = "                 the @a connect_cb for the respective connection"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_SERVICE_start(
        service_name: *const ::std::os::raw::c_char,
        cfg: *const GNUNET_CONFIGURATION_Handle,
        connect_cb: GNUNET_SERVICE_ConnectHandler,
        disconnect_cb: GNUNET_SERVICE_DisconnectHandler,
        cls: *mut ::std::os::raw::c_void,
        handlers: *const GNUNET_MQ_MessageHandler,
    ) -> *mut GNUNET_SERVICE_Handle;
}
extern "C" {
    #[doc = " Stops a service that was started with #GNUNET_SERVICE_start()."]
    #[doc = ""]
    #[doc = " @param srv service to stop"]
    pub fn GNUNET_SERVICE_stop(srv: *mut GNUNET_SERVICE_Handle);
}
extern "C" {
    #[doc = " Creates the \"main\" function for a GNUnet service.  You"]
    #[doc = " should almost always use the #GNUNET_SERVICE_MAIN macro"]
    #[doc = " instead of calling this function directly (except"]
    #[doc = " for ARM, which should call this function directly)."]
    #[doc = ""]
    #[doc = " The function will launch the service with the name @a service_name"]
    #[doc = " using the @a service_options to configure its shutdown"]
    #[doc = " behavior. Once the service is ready, the @a init_cb will be called"]
    #[doc = " for service-specific initialization.  @a init_cb will be given the"]
    #[doc = " service handler which can be used to control the service's"]
    #[doc = " availability.  When clients connect or disconnect, the respective"]
    #[doc = " @a connect_cb or @a disconnect_cb functions will be called. For"]
    #[doc = " messages received from the clients, the respective @a handlers will"]
    #[doc = " be invoked; for the closure of the handlers we use the return value"]
    #[doc = " from the @a connect_cb invocation of the respective client."]
    #[doc = ""]
    #[doc = " Each handler MUST call #GNUNET_SERVICE_client_continue() after each"]
    #[doc = " message to receive further messages from this client.  If"]
    #[doc = " #GNUNET_SERVICE_client_continue() is not called within a short"]
    #[doc = " time, a warning will be logged. If delays are expected, services"]
    #[doc = " should call #GNUNET_SERVICE_client_disable_continue_warning() to"]
    #[doc = " disable the warning."]
    #[doc = ""]
    #[doc = " Clients sending invalid messages (based on @a handlers) will be"]
    #[doc = " dropped. Additionally, clients can be dropped at any time using"]
    #[doc = " #GNUNET_SERVICE_client_drop()."]
    #[doc = ""]
    #[doc = " @param argc number of command-line arguments in @a argv"]
    #[doc = " @param argv array of command-line arguments"]
    #[doc = " @param service_name name of the service to run"]
    #[doc = " @param options options controlling shutdown of the service"]
    #[doc = " @param service_init_cb function to call once the service is ready"]
    #[doc = " @param connect_cb function to call whenever a client connects"]
    #[doc = " @param disconnect_cb function to call whenever a client disconnects"]
    #[doc = " @param cls closure argument for @a service_init_cb, @a connect_cb and @a disconnect_cb"]
    #[doc = " @param handlers NULL-terminated array of message handlers for the service,"]
    #[doc = "                 the closure will be set to the value returned by"]
    #[doc = "                 the @a connect_cb for the respective connection"]
    #[doc = " @return 0 on success, non-zero on error"]
    pub fn GNUNET_SERVICE_run_(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        service_name: *const ::std::os::raw::c_char,
        options: GNUNET_SERVICE_Options,
        service_init_cb: GNUNET_SERVICE_InitCallback,
        connect_cb: GNUNET_SERVICE_ConnectHandler,
        disconnect_cb: GNUNET_SERVICE_DisconnectHandler,
        cls: *mut ::std::os::raw::c_void,
        handlers: *const GNUNET_MQ_MessageHandler,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Suspend accepting connections from the listen socket temporarily."]
    #[doc = " Resume activity using #GNUNET_SERVICE_resume."]
    #[doc = ""]
    #[doc = " @param sh service to stop accepting connections."]
    pub fn GNUNET_SERVICE_suspend(sh: *mut GNUNET_SERVICE_Handle);
}
extern "C" {
    #[doc = " Resume accepting connections from the listen socket."]
    #[doc = ""]
    #[doc = " @param sh service to resume accepting connections."]
    pub fn GNUNET_SERVICE_resume(sh: *mut GNUNET_SERVICE_Handle);
}
extern "C" {
    #[doc = " Continue receiving further messages from the given client."]
    #[doc = " Must be called after each message received."]
    #[doc = ""]
    #[doc = " @param c the client to continue receiving from"]
    pub fn GNUNET_SERVICE_client_continue(c: *mut GNUNET_SERVICE_Client);
}
extern "C" {
    #[doc = " Obtain the message queue of @a c.  Convenience function."]
    #[doc = ""]
    #[doc = " @param c the client to continue receiving from"]
    #[doc = " @return the message queue of @a c"]
    pub fn GNUNET_SERVICE_client_get_mq(c: *mut GNUNET_SERVICE_Client) -> *mut GNUNET_MQ_Handle;
}
extern "C" {
    #[doc = " Disable the warning the server issues if a message is not"]
    #[doc = " acknowledged in a timely fashion.  Use this call if a client is"]
    #[doc = " intentionally delayed for a while.  Only applies to the current"]
    #[doc = " message."]
    #[doc = ""]
    #[doc = " @param c client for which to disable the warning"]
    pub fn GNUNET_SERVICE_client_disable_continue_warning(c: *mut GNUNET_SERVICE_Client);
}
extern "C" {
    #[doc = " Ask the server to disconnect from the given client.  This is the"]
    #[doc = " same as returning #GNUNET_SYSERR within the check procedure when"]
    #[doc = " handling a message, except that it allows dropping of a client even"]
    #[doc = " when not handling a message from that client.  The `disconnect_cb`"]
    #[doc = " will be called on @a c even if the application closes the connection"]
    #[doc = " using this function."]
    #[doc = ""]
    #[doc = " This function should be called (outside of util's internal logic)"]
    #[doc = " if (and usually only if) the client has violated the"]
    #[doc = " protocol. Otherwise, we should leave it to the client to disconnect"]
    #[doc = " from the service."]
    #[doc = ""]
    #[doc = " @param c client to disconnect now"]
    pub fn GNUNET_SERVICE_client_drop(c: *mut GNUNET_SERVICE_Client);
}
extern "C" {
    #[doc = " Explicitly stops the service."]
    #[doc = ""]
    #[doc = " @param sh server to shutdown"]
    pub fn GNUNET_SERVICE_shutdown(sh: *mut GNUNET_SERVICE_Handle);
}
extern "C" {
    #[doc = " Set the 'monitor' flag on this client.  Clients which have been"]
    #[doc = " marked as 'monitors' won't prevent the server from shutting down"]
    #[doc = " once #GNUNET_SERVICE_stop_listening() has been invoked.  The idea is"]
    #[doc = " that for \"normal\" clients we likely want to allow them to process"]
    #[doc = " their requests; however, monitor-clients are likely to 'never'"]
    #[doc = " disconnect during shutdown and thus will not be considered when"]
    #[doc = " determining if the server should continue to exist after"]
    #[doc = " shutdown has been triggered."]
    #[doc = ""]
    #[doc = " @param c client to mark as a monitor"]
    pub fn GNUNET_SERVICE_client_mark_monitor(c: *mut GNUNET_SERVICE_Client);
}
extern "C" {
    #[doc = " Set the persist option on this client.  Indicates that the"]
    #[doc = " underlying socket or fd should never really be closed.  Used for"]
    #[doc = " indicating process death."]
    #[doc = ""]
    #[doc = " @param c client to persist the socket (never to be closed)"]
    pub fn GNUNET_SERVICE_client_persist(c: *mut GNUNET_SERVICE_Client);
}
#[doc = " Context created when a signal handler is installed;"]
#[doc = " can be used to restore it to the previous state later."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_SIGNAL_Context {
    _unused: [u8; 0],
}
#[doc = " A signal handler.  Since different OSes have different signatures"]
#[doc = " for their handlers, the API only gives the most restrictive"]
#[doc = " signature -- no arguments, no return value.  Note that this will"]
#[doc = " work even if the OS expects a function with arguments.  However,"]
#[doc = " the implementation must guarantee that this handler is not called"]
#[doc = " for signals other than the one that it has been registered for."]
pub type GNUNET_SIGNAL_Handler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " Install a signal handler that will be run if the"]
    #[doc = " given signal is received."]
    #[doc = ""]
    #[doc = " @param signal the number of the signal"]
    #[doc = " @param handler the function to call"]
    #[doc = " @return context that can be used to restore, NULL on error"]
    pub fn GNUNET_SIGNAL_handler_install(
        signal: ::std::os::raw::c_int,
        handler: GNUNET_SIGNAL_Handler,
    ) -> *mut GNUNET_SIGNAL_Context;
}
extern "C" {
    #[doc = " Uninstall a previously installed signal handler."]
    #[doc = ""]
    #[doc = " @param ctx context that was returned when the"]
    #[doc = "            signal handler was installed"]
    pub fn GNUNET_SIGNAL_handler_uninstall(ctx: *mut GNUNET_SIGNAL_Context);
}
extern "C" {
    #[doc = " Raise the given signal by calling the installed signal handlers.  This will"]
    #[doc = " not use the @em raise() system call but only calls the handlers registered"]
    #[doc = " through GNUNET_SIGNAL_handler_install()."]
    #[doc = ""]
    #[doc = " @param sig the signal to raise"]
    pub fn GNUNET_SIGNAL_raise(sig: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timestamp {
    pub len: u8,
    pub ptr: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub data: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<timestamp>(),
        40usize,
        concat!("Size of: ", stringify!(timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timestamp>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timestamp),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timestamp>())).ptr as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(timestamp),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timestamp>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timestamp),
            "::",
            stringify!(data)
        )
    );
}
impl timestamp {
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn overflow(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_overflow(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: ::std::os::raw::c_uint,
        overflow: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let overflow: u32 = unsafe { ::std::mem::transmute(overflow) };
            overflow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iphdr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub tos: u8,
    pub tot_len: u16,
    pub id: u16,
    pub frag_off: u16,
    pub ttl: u8,
    pub protocol: u8,
    pub check: u16,
    pub saddr: u32,
    pub daddr: u32,
}
#[test]
fn bindgen_test_layout_iphdr() {
    assert_eq!(
        ::std::mem::size_of::<iphdr>(),
        20usize,
        concat!("Size of: ", stringify!(iphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<iphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(iphdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).tos as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).tot_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(iphdr), "::", stringify!(id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).frag_off as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(frag_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).protocol as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).check as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).saddr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(saddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iphdr>())).daddr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(iphdr),
            "::",
            stringify!(daddr)
        )
    );
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ihl: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u32 = unsafe { ::std::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub ip_tos: u8,
    pub ip_len: ::std::os::raw::c_ushort,
    pub ip_id: ::std::os::raw::c_ushort,
    pub ip_off: ::std::os::raw::c_ushort,
    pub ip_ttl: u8,
    pub ip_p: u8,
    pub ip_sum: ::std::os::raw::c_ushort,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
#[test]
fn bindgen_test_layout_ip() {
    assert_eq!(
        ::std::mem::size_of::<ip>(),
        20usize,
        concat!("Size of: ", stringify!(ip))
    );
    assert_eq!(
        ::std::mem::align_of::<ip>(),
        4usize,
        concat!("Alignment of ", stringify!(ip))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_tos as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_id as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(ip), "::", stringify!(ip_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_off as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_p as *const _ as usize },
        9usize,
        concat!("Offset of field: ", stringify!(ip), "::", stringify!(ip_p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_sum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_sum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_src as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip>())).ip_dst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip),
            "::",
            stringify!(ip_dst)
        )
    );
}
impl ip {
    #[inline]
    pub fn ip_hl(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_v(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ip_hl: ::std::os::raw::c_uint,
        ip_v: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ip_hl: u32 = unsafe { ::std::mem::transmute(ip_hl) };
            ip_hl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ip_v: u32 = unsafe { ::std::mem::transmute(ip_v) };
            ip_v as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_timestamp {
    pub ipt_code: u8,
    pub ipt_len: u8,
    pub ipt_ptr: u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub data: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_ip_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<ip_timestamp>(),
        40usize,
        concat!("Size of: ", stringify!(ip_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_timestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).ipt_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_timestamp),
            "::",
            stringify!(ipt_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).ipt_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_timestamp),
            "::",
            stringify!(ipt_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).ipt_ptr as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_timestamp),
            "::",
            stringify!(ipt_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_timestamp>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_timestamp),
            "::",
            stringify!(data)
        )
    );
}
impl ip_timestamp {
    #[inline]
    pub fn ipt_flg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_flg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ipt_oflw(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_ipt_oflw(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ipt_flg: ::std::os::raw::c_uint,
        ipt_oflw: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ipt_flg: u32 = unsafe { ::std::mem::transmute(ipt_flg) };
            ipt_flg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ipt_oflw: u32 = unsafe { ::std::mem::transmute(ipt_oflw) };
            ipt_oflw as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Convert a given fancy human-readable size to bytes."]
    #[doc = ""]
    #[doc = " @param fancy_size human readable string (i.e. 1 MB)"]
    #[doc = " @param size set to the size in bytes"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_STRINGS_fancy_size_to_bytes(
        fancy_size: *const ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a given fancy human-readable time to our internal"]
    #[doc = " representation."]
    #[doc = ""]
    #[doc = " @param fancy_time human readable string (i.e. 1 minute)"]
    #[doc = " @param rtime set to the relative time"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_STRINGS_fancy_time_to_relative(
        fancy_time: *const ::std::os::raw::c_char,
        rtime: *mut GNUNET_TIME_Relative,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @ingroup time"]
    #[doc = " Convert a given fancy human-readable time to our internal"]
    #[doc = " representation.  The human-readable time is expected to be"]
    #[doc = " in local time, whereas the returned value will be in UTC."]
    #[doc = ""]
    #[doc = " @param fancy_time human readable string (i.e. %Y-%m-%d %H:%M:%S)"]
    #[doc = " @param atime set to the absolute time"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on error"]
    pub fn GNUNET_STRINGS_fancy_time_to_absolute(
        fancy_time: *const ::std::os::raw::c_char,
        atime: *mut GNUNET_TIME_Absolute,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a given filesize into a fancy human-readable format."]
    #[doc = ""]
    #[doc = " @param size number of bytes"]
    #[doc = " @return fancy representation of the size (possibly rounded) for humans"]
    pub fn GNUNET_STRINGS_byte_size_fancy(
        size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert the len characters long character sequence"]
    #[doc = " given in input that is in the given input charset"]
    #[doc = " to a string in given output charset."]
    #[doc = ""]
    #[doc = " @param input input string"]
    #[doc = " @param len number of bytes in @a input"]
    #[doc = " @param input_charset character set used for @a input"]
    #[doc = " @param output_charset desired character set for the return value"]
    #[doc = " @return the converted string (0-terminated),"]
    #[doc = "  if conversion fails, a copy of the original"]
    #[doc = "  string is returned."]
    pub fn GNUNET_STRINGS_conv(
        input: *const ::std::os::raw::c_char,
        len: usize,
        input_charset: *const ::std::os::raw::c_char,
        output_charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert the len characters long character sequence"]
    #[doc = " given in input that is in the given charset"]
    #[doc = " to UTF-8."]
    #[doc = ""]
    #[doc = " @param input the input string (not necessarily 0-terminated)"]
    #[doc = " @param len the number of bytes in the @a input"]
    #[doc = " @param charset character set to convert from"]
    #[doc = " @return the converted string (0-terminated)"]
    pub fn GNUNET_STRINGS_to_utf8(
        input: *const ::std::os::raw::c_char,
        len: usize,
        charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert the len bytes-long UTF-8 string"]
    #[doc = " given in input to the given charset."]
    #[doc = ""]
    #[doc = " @param input the input string (not necessarily 0-terminated)"]
    #[doc = " @param len the number of bytes in the @a input"]
    #[doc = " @param charset character set to convert to"]
    #[doc = " @return the converted string (0-terminated),"]
    #[doc = "  if conversion fails, a copy of the original"]
    #[doc = "  string is returned."]
    pub fn GNUNET_STRINGS_from_utf8(
        input: *const ::std::os::raw::c_char,
        len: usize,
        charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert the utf-8 input string to lower case."]
    #[doc = " Output needs to be allocated appropriately."]
    #[doc = ""]
    #[doc = " @param input input string"]
    #[doc = " @param output output buffer"]
    pub fn GNUNET_STRINGS_utf8_tolower(
        input: *const ::std::os::raw::c_char,
        output: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Convert the utf-8 input string to upper case."]
    #[doc = " Output needs to be allocated appropriately."]
    #[doc = ""]
    #[doc = " @param input input string"]
    #[doc = " @param output output buffer"]
    pub fn GNUNET_STRINGS_utf8_toupper(
        input: *const ::std::os::raw::c_char,
        output: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Complete filename (a la shell) from abbrevition."]
    #[doc = ""]
    #[doc = " @param fil the name of the file, may contain ~/ or"]
    #[doc = "        be relative to the current directory"]
    #[doc = " @return the full file name,"]
    #[doc = "          NULL is returned on error"]
    pub fn GNUNET_STRINGS_filename_expand(
        fil: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Fill a buffer of the given size with count 0-terminated strings"]
    #[doc = " (given as varargs).  If \"buffer\" is NULL, only compute the amount"]
    #[doc = " of space required (sum of \"strlen(arg)+1\")."]
    #[doc = ""]
    #[doc = " Unlike using \"snprintf\" with \"%s\", this function will add"]
    #[doc = " 0-terminators after each string.  The"]
    #[doc = " \"GNUNET_string_buffer_tokenize\" function can be used to parse the"]
    #[doc = " buffer back into individual strings."]
    #[doc = ""]
    #[doc = " @param buffer the buffer to fill with strings, can"]
    #[doc = "               be NULL in which case only the necessary"]
    #[doc = "               amount of space will be calculated"]
    #[doc = " @param size number of bytes available in buffer"]
    #[doc = " @param count number of strings that follow"]
    #[doc = " @param ... count 0-terminated strings to copy to buffer"]
    #[doc = " @return number of bytes written to the buffer"]
    #[doc = "         (or number of bytes that would have been written)"]
    pub fn GNUNET_STRINGS_buffer_fill(
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
        count: ::std::os::raw::c_uint,
        ...
    ) -> usize;
}
extern "C" {
    #[doc = " Given a buffer of a given size, find \"count\" 0-terminated strings"]
    #[doc = " in the buffer and assign the count (varargs) of type \"const char**\""]
    #[doc = " to the locations of the respective strings in the buffer."]
    #[doc = ""]
    #[doc = " @param buffer the buffer to parse"]
    #[doc = " @param size size of the @a buffer"]
    #[doc = " @param count number of strings to locate"]
    #[doc = " @param ... pointers to where to store the strings"]
    #[doc = " @return offset of the character after the last 0-termination"]
    #[doc = "         in the buffer, or 0 on error."]
    pub fn GNUNET_STRINGS_buffer_tokenize(
        buffer: *const ::std::os::raw::c_char,
        size: usize,
        count: ::std::os::raw::c_uint,
        ...
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @ingroup time"]
    #[doc = " Like `asctime`, except for GNUnet time.  Converts a GNUnet internal"]
    #[doc = " absolute time (which is in UTC) to a string in local time."]
    #[doc = " Note that the returned value will be overwritten if this function"]
    #[doc = " is called again."]
    #[doc = ""]
    #[doc = " @param t the absolute time to convert"]
    #[doc = " @return timestamp in human-readable form in local time"]
    pub fn GNUNET_STRINGS_absolute_time_to_string(
        t: GNUNET_TIME_Absolute,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @ingroup time"]
    #[doc = " Give relative time in human-readable fancy format."]
    #[doc = " This is one of the very few calls in the entire API that is"]
    #[doc = " NOT reentrant!"]
    #[doc = ""]
    #[doc = " @param delta time in milli seconds"]
    #[doc = " @param do_round are we allowed to round a bit?"]
    #[doc = " @return string in human-readable form"]
    pub fn GNUNET_STRINGS_relative_time_to_string(
        delta: GNUNET_TIME_Relative,
        do_round: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " \"man basename\""]
    #[doc = " Returns a pointer to a part of filename (allocates nothing)!"]
    #[doc = ""]
    #[doc = " @param filename filename to extract basename from"]
    #[doc = " @return short (base) name of the file (that is, everything following the"]
    #[doc = "         last directory separator in filename. If filename ends with a"]
    #[doc = "         directory separator, the result will be a zero-length string."]
    #[doc = "         If filename has no directory separators, the result is filename"]
    #[doc = "         itself."]
    pub fn GNUNET_STRINGS_get_short_name(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert binary data to ASCII encoding using CrockfordBase32."]
    #[doc = " Does not append 0-terminator, but returns a pointer to the place where"]
    #[doc = " it should be placed, if needed."]
    #[doc = ""]
    #[doc = " @param data data to encode"]
    #[doc = " @param size size of data (in bytes)"]
    #[doc = " @param out buffer to fill"]
    #[doc = " @param out_size size of the buffer. Must be large enough to hold"]
    #[doc = " ((size*8) + (((size*8) % 5) > 0 ? 5 - ((size*8) % 5) : 0)) / 5"]
    #[doc = " @return pointer to the next byte in 'out' or NULL on error."]
    pub fn GNUNET_STRINGS_data_to_string(
        data: *const ::std::os::raw::c_void,
        size: usize,
        out: *mut ::std::os::raw::c_char,
        out_size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the base32crockford encoding of the given buffer."]
    #[doc = ""]
    #[doc = " The returned string will be freshly allocated, and must be free'd"]
    #[doc = " with #GNUNET_free()."]
    #[doc = ""]
    #[doc = " @param buf buffer with data"]
    #[doc = " @param size size of the buffer @a buf"]
    #[doc = " @return freshly allocated, null-terminated string"]
    pub fn GNUNET_STRINGS_data_to_string_alloc(
        buf: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert CrockfordBase32 encoding back to data."]
    #[doc = " @a out_size must match exactly the size of the data before it was encoded."]
    #[doc = ""]
    #[doc = " @param enc the encoding"]
    #[doc = " @param enclen number of characters in @a enc (without 0-terminator, which can be missing)"]
    #[doc = " @param out location where to store the decoded data"]
    #[doc = " @param out_size size of the output buffer @a out"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if result has the wrong encoding"]
    pub fn GNUNET_STRINGS_string_to_data(
        enc: *const ::std::os::raw::c_char,
        enclen: usize,
        out: *mut ::std::os::raw::c_void,
        out_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode into Base64."]
    #[doc = ""]
    #[doc = " @param data the data to encode"]
    #[doc = " @param len the length of the input"]
    #[doc = " @param output where to write the output (*output should be NULL,"]
    #[doc = "   is allocated)"]
    #[doc = " @return the size of the output"]
    pub fn GNUNET_STRINGS_base64_encode(
        in_: *const ::std::os::raw::c_void,
        len: usize,
        output: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " url/percent encode (RFC3986)."]
    #[doc = ""]
    #[doc = " @param data the data to decode"]
    #[doc = " @param len the length of the input"]
    #[doc = " @param output where to write the output (*output should be NULL,"]
    #[doc = "   is allocated)"]
    #[doc = " @return the size of the output"]
    pub fn GNUNET_STRINGS_urlencode(
        data: *const ::std::os::raw::c_char,
        len: usize,
        out: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Encode into Base64url. RFC7515"]
    #[doc = ""]
    #[doc = " @param in the data to encode"]
    #[doc = " @param len the length of the input"]
    #[doc = " @param output where to write the output (*output should be NULL,"]
    #[doc = "   is allocated)"]
    #[doc = " @return the size of the output"]
    pub fn GNUNET_STRINGS_base64url_encode(
        in_: *const ::std::os::raw::c_void,
        len: usize,
        output: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Decode from Base64."]
    #[doc = ""]
    #[doc = " @param data the data to encode"]
    #[doc = " @param len the length of the input"]
    #[doc = " @param[out] output where to write the output (*output should be NULL,"]
    #[doc = "   is allocated)"]
    #[doc = " @return the size of the output"]
    pub fn GNUNET_STRINGS_base64_decode(
        data: *const ::std::os::raw::c_char,
        len: usize,
        output: *mut *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " Decode from Base64url. RFC7515"]
    #[doc = ""]
    #[doc = " @param data the data to decode"]
    #[doc = " @param len the length of the input"]
    #[doc = " @param output where to write the output (*output should be NULL,"]
    #[doc = "   is allocated)"]
    #[doc = " @return the size of the output"]
    pub fn GNUNET_STRINGS_base64url_decode(
        data: *const ::std::os::raw::c_char,
        len: usize,
        out: *mut *mut ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[doc = " url/percent encode (RFC3986)."]
    #[doc = ""]
    #[doc = " @param data the data to encode"]
    #[doc = " @param len the length of the input"]
    #[doc = " @param output where to write the output (*output should be NULL,"]
    #[doc = "   is allocated)"]
    #[doc = " @return the size of the output"]
    pub fn GNUNET_STRINGS_urldecode(
        data: *const ::std::os::raw::c_char,
        len: usize,
        out: *mut *mut ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = " Convert a peer path to a human-readable string."]
    #[doc = ""]
    #[doc = " @param pids array of PIDs to convert to a string"]
    #[doc = " @param num_pids length of the @a pids array"]
    #[doc = " @return string representing the array of @a pids"]
    pub fn GNUNET_STRINGS_pp2s(
        pids: *const GNUNET_PeerIdentity,
        num_pids: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a path that might be an URI."]
    #[doc = ""]
    #[doc = " @param path path to parse. Must be NULL-terminated."]
    #[doc = " @param[out] scheme_part pointer to a string that"]
    #[doc = "        represents the URI scheme will be stored. Can be NULL. The string is"]
    #[doc = "        allocated by the function, and should be freed by GNUNET_free() when"]
    #[doc = "        it is no longer needed."]
    #[doc = " @param path_part a pointer to 'const char *' where a pointer to the path"]
    #[doc = "        part of the URI will be stored. Can be NULL. Points to the same block"]
    #[doc = "        of memory as @a path, and thus must not be freed. Might point to '\\0',"]
    #[doc = "        if path part is zero-length."]
    #[doc = " @return #GNUNET_YES if it's an URI, #GNUNET_NO otherwise. If 'path' is not"]
    #[doc = "         an URI, '* scheme_part' and '*path_part' will remain unchanged"]
    #[doc = "         (if they weren't NULL)."]
    pub fn GNUNET_STRINGS_parse_uri(
        path: *const ::std::os::raw::c_char,
        scheme_part: *mut *mut ::std::os::raw::c_char,
        path_part: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check whether filename is absolute or not, and if it's an URI"]
    #[doc = ""]
    #[doc = " @param filename filename to check"]
    #[doc = " @param can_be_uri #GNUNET_YES to check for being URI, #GNUNET_NO - to"]
    #[doc = "        assume it's not URI"]
    #[doc = " @param r_is_uri a pointer to an int that is set to #GNUNET_YES if 'filename'"]
    #[doc = "        is URI and to GNUNET_NO otherwise. Can be NULL. If 'can_be_uri' is"]
    #[doc = "        not #GNUNET_YES, *r_is_uri is set to #GNUNET_NO."]
    #[doc = " @param r_uri_scheme a pointer to a char * that is set to a pointer to URI scheme."]
    #[doc = "        The string is allocated by the function, and should be freed with"]
    #[doc = "        GNUNET_free (). Can be NULL."]
    #[doc = " @return #GNUNET_YES if 'filename' is absolute, #GNUNET_NO otherwise."]
    pub fn GNUNET_STRINGS_path_is_absolute(
        filename: *const ::std::os::raw::c_char,
        can_be_uri: ::std::os::raw::c_int,
        r_is_uri: *mut ::std::os::raw::c_int,
        r_uri_scheme: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Check that it exists."]
pub const GNUNET_STRINGS_FilenameCheck_GNUNET_STRINGS_CHECK_EXISTS: GNUNET_STRINGS_FilenameCheck =
    1;
#[doc = " Check that it is a directory."]
pub const GNUNET_STRINGS_FilenameCheck_GNUNET_STRINGS_CHECK_IS_DIRECTORY:
    GNUNET_STRINGS_FilenameCheck = 2;
#[doc = " Check that it is a link."]
pub const GNUNET_STRINGS_FilenameCheck_GNUNET_STRINGS_CHECK_IS_LINK: GNUNET_STRINGS_FilenameCheck =
    4;
#[doc = " Check that the path is an absolute path."]
pub const GNUNET_STRINGS_FilenameCheck_GNUNET_STRINGS_CHECK_IS_ABSOLUTE:
    GNUNET_STRINGS_FilenameCheck = 8;
#[doc = " Flags for what we should check a file for."]
pub type GNUNET_STRINGS_FilenameCheck = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Perform checks on @a filename.  FIXME: some duplication with"]
    #[doc = " \"GNUNET_DISK_\"-APIs.  We should unify those."]
    #[doc = ""]
    #[doc = " @param filename file to check"]
    #[doc = " @param checks checks to perform"]
    #[doc = " @return #GNUNET_YES if all checks pass, #GNUNET_NO if at least one of them"]
    #[doc = "         fails, #GNUNET_SYSERR when a check can't be performed"]
    pub fn GNUNET_STRINGS_check_filename(
        filename: *const ::std::os::raw::c_char,
        checks: GNUNET_STRINGS_FilenameCheck,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tries to convert @a zt_addr string to an IPv6 address."]
    #[doc = " The string is expected to have the format \"[ABCD::01]:80\"."]
    #[doc = ""]
    #[doc = " @param zt_addr 0-terminated string. May be mangled by the function."]
    #[doc = " @param addrlen length of zt_addr (not counting 0-terminator)."]
    #[doc = " @param r_buf a buffer to fill. Initially gets filled with zeroes,"]
    #[doc = "        then its sin6_port, sin6_family and sin6_addr are set appropriately."]
    #[doc = " @return #GNUNET_OK if conversion succeeded. #GNUNET_SYSERR otherwise, in which"]
    #[doc = "         case the contents of r_buf are undefined."]
    pub fn GNUNET_STRINGS_to_address_ipv6(
        zt_addr: *const ::std::os::raw::c_char,
        addrlen: u16,
        r_buf: *mut sockaddr_in6,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tries to convert @a zt_addr string to an IPv4 address."]
    #[doc = " The string is expected to have the format \"1.2.3.4:80\"."]
    #[doc = ""]
    #[doc = " @param zt_addr 0-terminated string. May be mangled by the function."]
    #[doc = " @param addrlen length of zt_addr (not counting 0-terminator)."]
    #[doc = " @param r_buf a buffer to fill."]
    #[doc = " @return #GNUNET_OK if conversion succeeded. #GNUNET_SYSERR otherwise, in which case"]
    #[doc = "         the contents of r_buf are undefined."]
    pub fn GNUNET_STRINGS_to_address_ipv4(
        zt_addr: *const ::std::os::raw::c_char,
        addrlen: u16,
        r_buf: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse an address given as a string into a"]
    #[doc = " `struct sockaddr`."]
    #[doc = ""]
    #[doc = " @param addr the address"]
    #[doc = " @param[out] af set to the parsed address family (i.e. AF_INET)"]
    #[doc = " @param[out] sa set to the parsed address"]
    #[doc = " @return 0 on error, otherwise number of bytes in @a sa"]
    pub fn GNUNET_STRINGS_parse_socket_addr(
        addr: *const ::std::os::raw::c_char,
        af: *mut u8,
        sa: *mut *mut sockaddr,
    ) -> usize;
}
extern "C" {
    #[doc = " Tries to convert @a addr string to an IP (v4 or v6) address."]
    #[doc = " Will automatically decide whether to treat 'addr' as v4 or v6 address."]
    #[doc = ""]
    #[doc = " @param addr a string, may not be 0-terminated."]
    #[doc = " @param addrlen number of bytes in @a addr (if addr is 0-terminated,"]
    #[doc = "        0-terminator should not be counted towards addrlen)."]
    #[doc = " @param r_buf a buffer to fill."]
    #[doc = " @return #GNUNET_OK if conversion succeeded. #GNUNET_SYSERR otherwise, in which"]
    #[doc = "         case the contents of r_buf are undefined."]
    pub fn GNUNET_STRINGS_to_address_ip(
        addr: *const ::std::os::raw::c_char,
        addrlen: u16,
        r_buf: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns utf-8 encoded arguments.  Does nothing (returns a copy of"]
    #[doc = " @a argc and @a argv) on any platform other than W32.  Returned @a"]
    #[doc = " argv has `u8argv[u8argc] == NULL`.  Returned @a argv is a single"]
    #[doc = " memory block, and can be freed with a single GNUNET_free() call."]
    #[doc = ""]
    #[doc = " @param argc argc (as given by main())"]
    #[doc = " @param argv argv (as given by main())"]
    #[doc = " @param u8argc a location to store new argc in (though it's th same as argc)"]
    #[doc = " @param u8argv a location to store new argv in"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR on failure"]
    pub fn GNUNET_STRINGS_get_utf8_args(
        argc: ::std::os::raw::c_int,
        argv: *const *mut ::std::os::raw::c_char,
        u8argc: *mut ::std::os::raw::c_int,
        u8argv: *mut *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Like strlcpy but portable. The given string @a src is copied in full length"]
    #[doc = " (until its null byte). The destination buffer is guaranteed to be"]
    #[doc = " null-terminated."]
    #[doc = ""]
    #[doc = " to a destination buffer"]
    #[doc = " and ensures that the destination string is null-terminated."]
    #[doc = ""]
    #[doc = " @param dst destination of the copy"]
    #[doc = " @param src source of the copy, must be null-terminated"]
    #[doc = " @param n the length of the string to copy, including its terminating null"]
    #[doc = "          byte"]
    #[doc = " @return the length of the string that was copied, excluding the terminating"]
    #[doc = "         null byte"]
    pub fn GNUNET_strlcpy(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_STRINGS_PortPolicy {
    #[doc = " Starting port range (0 if none given)."]
    pub start_port: u16,
    #[doc = " End of port range (0 if none given)."]
    pub end_port: u16,
    #[doc = " #GNUNET_YES if the port range should be negated"]
    #[doc = " (\"!\" in policy)."]
    pub negate_portrange: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GNUNET_STRINGS_PortPolicy() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_STRINGS_PortPolicy>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_STRINGS_PortPolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_STRINGS_PortPolicy>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_STRINGS_PortPolicy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_PortPolicy>())).start_port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_PortPolicy),
            "::",
            stringify!(start_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_PortPolicy>())).end_port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_PortPolicy),
            "::",
            stringify!(end_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_PortPolicy>())).negate_portrange as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_PortPolicy),
            "::",
            stringify!(negate_portrange)
        )
    );
}
#[doc = " @brief IPV4 network in CIDR notation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_STRINGS_IPv4NetworkPolicy {
    #[doc = " IPv4 address."]
    pub network: in_addr,
    #[doc = " IPv4 netmask."]
    pub netmask: in_addr,
    #[doc = " Policy for port access."]
    pub pp: GNUNET_STRINGS_PortPolicy,
}
#[test]
fn bindgen_test_layout_GNUNET_STRINGS_IPv4NetworkPolicy() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_STRINGS_IPv4NetworkPolicy>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_STRINGS_IPv4NetworkPolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_STRINGS_IPv4NetworkPolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_STRINGS_IPv4NetworkPolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_IPv4NetworkPolicy>())).network as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_IPv4NetworkPolicy),
            "::",
            stringify!(network)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_IPv4NetworkPolicy>())).netmask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_IPv4NetworkPolicy),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_IPv4NetworkPolicy>())).pp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_IPv4NetworkPolicy),
            "::",
            stringify!(pp)
        )
    );
}
#[doc = " @brief network in CIDR notation for IPV6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_STRINGS_IPv6NetworkPolicy {
    #[doc = " IPv6 address."]
    pub network: in6_addr,
    #[doc = " IPv6 netmask."]
    pub netmask: in6_addr,
    #[doc = " Policy for port access."]
    pub pp: GNUNET_STRINGS_PortPolicy,
}
#[test]
fn bindgen_test_layout_GNUNET_STRINGS_IPv6NetworkPolicy() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_STRINGS_IPv6NetworkPolicy>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_STRINGS_IPv6NetworkPolicy))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_STRINGS_IPv6NetworkPolicy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_STRINGS_IPv6NetworkPolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_IPv6NetworkPolicy>())).network as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_IPv6NetworkPolicy),
            "::",
            stringify!(network)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_IPv6NetworkPolicy>())).netmask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_IPv6NetworkPolicy),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_STRINGS_IPv6NetworkPolicy>())).pp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_STRINGS_IPv6NetworkPolicy),
            "::",
            stringify!(pp)
        )
    );
}
extern "C" {
    #[doc = " Parse an IPv4 network policy. The argument specifies a list of"]
    #[doc = " subnets. The format is <tt>(network[/netmask][:[!]SPORT-DPORT];)*</tt>"]
    #[doc = " (no whitespace, must be terminated with a semicolon). The network"]
    #[doc = " must be given in dotted-decimal notation. The netmask can be given"]
    #[doc = " in CIDR notation (/16) or in dotted-decimal (/255.255.0.0)."]
    #[doc = ""]
    #[doc = " @param routeListX a string specifying the IPv4 subnets"]
    #[doc = " @return the converted list, terminated with all zeros;"]
    #[doc = "         NULL if the synatx is flawed"]
    pub fn GNUNET_STRINGS_parse_ipv4_policy(
        routeListX: *const ::std::os::raw::c_char,
    ) -> *mut GNUNET_STRINGS_IPv4NetworkPolicy;
}
extern "C" {
    #[doc = " Parse an IPv6 network policy. The argument specifies a list of"]
    #[doc = " subnets. The format is <tt>(network[/netmask[:[!]SPORT[-DPORT]]];)*</tt>"]
    #[doc = " (no whitespace, must be terminated with a semicolon). The network"]
    #[doc = " must be given in colon-hex notation.  The netmask must be given in"]
    #[doc = " CIDR notation (/16) or can be omitted to specify a single host."]
    #[doc = " Note that the netmask is mandatory if ports are specified."]
    #[doc = ""]
    #[doc = " @param routeListX a string specifying the policy"]
    #[doc = " @return the converted list, 0-terminated, NULL if the synatx is flawed"]
    pub fn GNUNET_STRINGS_parse_ipv6_policy(
        routeListX: *const ::std::os::raw::c_char,
    ) -> *mut GNUNET_STRINGS_IPv6NetworkPolicy;
}
#[doc = " Header from Linux TUN interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_Layer2PacketHeader {
    #[doc = " Some flags (unused)."]
    pub flags: u16,
    #[doc = " Here we get an ETH_P_-number."]
    pub proto: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_Layer2PacketHeader() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_Layer2PacketHeader>(),
        4usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_Layer2PacketHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_Layer2PacketHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_Layer2PacketHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_Layer2PacketHeader>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_Layer2PacketHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_Layer2PacketHeader>())).proto as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_Layer2PacketHeader),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " Standard IPv4 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_IPv4Header {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub diff_serv: u8,
    #[doc = " Length of the packet, including this header."]
    pub total_length: u16,
    #[doc = " Unique random ID for matching up fragments."]
    pub identification: u16,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = " How many more hops can this packet be forwarded?"]
    pub ttl: u8,
    #[doc = " L4-protocol, for example, IPPROTO_UDP or IPPROTO_TCP."]
    pub protocol: u8,
    #[doc = " Checksum."]
    pub checksum: u16,
    #[doc = " Origin of the packet."]
    pub source_address: in_addr,
    #[doc = " Destination of the packet."]
    pub destination_address: in_addr,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_IPv4Header() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_IPv4Header>(),
        20usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_IPv4Header))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_IPv4Header>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_IPv4Header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).diff_serv as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(diff_serv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).total_length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(total_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).identification as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(identification)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).ttl as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).protocol as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).checksum as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).source_address as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv4Header>())).destination_address as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv4Header),
            "::",
            stringify!(destination_address)
        )
    );
}
impl GNUNET_TUN_IPv4Header {
    #[inline]
    pub fn header_length(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_header_length(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        header_length: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let header_length: u32 = unsafe { ::std::mem::transmute(header_length) };
            header_length as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn flags(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fragmentation_offset(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_fragmentation_offset(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        flags: ::std::os::raw::c_uint,
        fragmentation_offset: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let fragmentation_offset: u32 = unsafe { ::std::mem::transmute(fragmentation_offset) };
            fragmentation_offset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Standard IPv6 header."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct GNUNET_TUN_IPv6Header {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = " Length of the payload, excluding this header."]
    pub payload_length: u16,
    #[doc = " For example, IPPROTO_UDP or IPPROTO_TCP."]
    pub next_header: u8,
    #[doc = " How many more hops can this packet be forwarded?"]
    pub hop_limit: u8,
    #[doc = " Origin of the packet."]
    pub source_address: in6_addr,
    #[doc = " Destination of the packet."]
    pub destination_address: in6_addr,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_IPv6Header() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_IPv6Header>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_IPv6Header))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_IPv6Header>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_IPv6Header))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv6Header>())).payload_length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv6Header),
            "::",
            stringify!(payload_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv6Header>())).next_header as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv6Header),
            "::",
            stringify!(next_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IPv6Header>())).hop_limit as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv6Header),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv6Header>())).source_address as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv6Header),
            "::",
            stringify!(source_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IPv6Header>())).destination_address as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IPv6Header),
            "::",
            stringify!(destination_address)
        )
    );
}
impl GNUNET_TUN_IPv6Header {
    #[inline]
    pub fn traffic_class_h(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_traffic_class_h(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn traffic_class_l(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_traffic_class_l(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn flow_label(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_flow_label(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        traffic_class_h: ::std::os::raw::c_uint,
        version: ::std::os::raw::c_uint,
        traffic_class_l: ::std::os::raw::c_uint,
        flow_label: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let traffic_class_h: u32 = unsafe { ::std::mem::transmute(traffic_class_h) };
            traffic_class_h as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let traffic_class_l: u32 = unsafe { ::std::mem::transmute(traffic_class_l) };
            traffic_class_l as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let flow_label: u32 = unsafe { ::std::mem::transmute(flow_label) };
            flow_label as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " TCP packet header."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_TcpHeader {
    #[doc = " Source port (in NBO)."]
    pub source_port: u16,
    #[doc = " Destination port (in NBO)."]
    pub destination_port: u16,
    #[doc = " Sequence number."]
    pub seq: u32,
    #[doc = " Acknowledgement number."]
    pub ack: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " Flags (SYN, FIN, ACK, etc.)"]
    pub flags: u8,
    #[doc = " Window size."]
    pub window_size: u16,
    #[doc = " Checksum."]
    pub crc: u16,
    #[doc = " Urgent pointer."]
    pub urgent_pointer: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_TcpHeader() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_TcpHeader>(),
        20usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_TcpHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_TcpHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_TcpHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).source_port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(source_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).destination_port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(destination_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).ack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(ack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).flags as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).window_size as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(window_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).crc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_TcpHeader>())).urgent_pointer as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_TcpHeader),
            "::",
            stringify!(urgent_pointer)
        )
    );
}
impl GNUNET_TUN_TcpHeader {
    #[inline]
    pub fn reserved(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: ::std::os::raw::c_uint,
        off: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let off: u32 = unsafe { ::std::mem::transmute(off) };
            off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " UDP packet header."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_UdpHeader {
    #[doc = " Source port (in NBO)."]
    pub source_port: u16,
    #[doc = " Destination port (in NBO)."]
    pub destination_port: u16,
    #[doc = " Number of bytes of payload."]
    pub len: u16,
    #[doc = " Checksum."]
    pub crc: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_UdpHeader() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_UdpHeader>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_UdpHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_UdpHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_UdpHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_UdpHeader>())).source_port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_UdpHeader),
            "::",
            stringify!(source_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_UdpHeader>())).destination_port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_UdpHeader),
            "::",
            stringify!(destination_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_UdpHeader>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_UdpHeader),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_UdpHeader>())).crc as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_UdpHeader),
            "::",
            stringify!(crc)
        )
    );
}
#[doc = " DNS flags (largely RFC 1035 / RFC 2136)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsFlags {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsFlags() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsFlags>(),
        2usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsFlags>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsFlags))
    );
}
impl GNUNET_TUN_DnsFlags {
    #[inline]
    pub fn recursion_desired(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_recursion_desired(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn message_truncated(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_message_truncated(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authoritative_answer(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_authoritative_answer(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn query_or_response(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_query_or_response(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn return_code(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_return_code(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn checking_disabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_checking_disabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authenticated_data(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_authenticated_data(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zero(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_zero(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recursion_available(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_recursion_available(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        recursion_desired: ::std::os::raw::c_uint,
        message_truncated: ::std::os::raw::c_uint,
        authoritative_answer: ::std::os::raw::c_uint,
        opcode: ::std::os::raw::c_uint,
        query_or_response: ::std::os::raw::c_uint,
        return_code: ::std::os::raw::c_uint,
        checking_disabled: ::std::os::raw::c_uint,
        authenticated_data: ::std::os::raw::c_uint,
        zero: ::std::os::raw::c_uint,
        recursion_available: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recursion_desired: u32 = unsafe { ::std::mem::transmute(recursion_desired) };
            recursion_desired as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let message_truncated: u32 = unsafe { ::std::mem::transmute(message_truncated) };
            message_truncated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let authoritative_answer: u32 = unsafe { ::std::mem::transmute(authoritative_answer) };
            authoritative_answer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let opcode: u32 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let query_or_response: u32 = unsafe { ::std::mem::transmute(query_or_response) };
            query_or_response as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let return_code: u32 = unsafe { ::std::mem::transmute(return_code) };
            return_code as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let checking_disabled: u32 = unsafe { ::std::mem::transmute(checking_disabled) };
            checking_disabled as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let authenticated_data: u32 = unsafe { ::std::mem::transmute(authenticated_data) };
            authenticated_data as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let zero: u32 = unsafe { ::std::mem::transmute(zero) };
            zero as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let recursion_available: u32 = unsafe { ::std::mem::transmute(recursion_available) };
            recursion_available as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " DNS header."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsHeader {
    #[doc = " Unique identifier for the request/response."]
    pub id: u16,
    #[doc = " Flags."]
    pub flags: GNUNET_TUN_DnsFlags,
    #[doc = " Number of queries."]
    pub query_count: u16,
    #[doc = " Number of answers."]
    pub answer_rcount: u16,
    #[doc = " Number of authoritative answers."]
    pub authority_rcount: u16,
    #[doc = " Number of additional records."]
    pub additional_rcount: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsHeader() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsHeader>(),
        12usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsHeader>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsHeader>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsHeader),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsHeader>())).flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsHeader>())).query_count as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsHeader),
            "::",
            stringify!(query_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsHeader>())).answer_rcount as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsHeader),
            "::",
            stringify!(answer_rcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsHeader>())).authority_rcount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsHeader),
            "::",
            stringify!(authority_rcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsHeader>())).additional_rcount as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsHeader),
            "::",
            stringify!(additional_rcount)
        )
    );
}
#[doc = " Payload of DNS SOA record (header)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsSoaRecord {
    #[doc = " The version number of the original copy of the zone.   (NBO)"]
    pub serial: u32,
    #[doc = " Time interval before the zone should be refreshed. (NBO)"]
    pub refresh: u32,
    #[doc = " Time interval that should elapse before a failed refresh should"]
    #[doc = " be retried. (NBO)"]
    pub retry: u32,
    #[doc = " Time value that specifies the upper limit on the time interval"]
    #[doc = " that can elapse before the zone is no longer authoritative. (NBO)"]
    pub expire: u32,
    #[doc = " The bit minimum TTL field that should be exported with any RR"]
    #[doc = " from this zone. (NBO)"]
    pub minimum: u32,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsSoaRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsSoaRecord>(),
        20usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsSoaRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsSoaRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsSoaRecord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSoaRecord>())).serial as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSoaRecord),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSoaRecord>())).refresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSoaRecord),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSoaRecord>())).retry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSoaRecord),
            "::",
            stringify!(retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSoaRecord>())).expire as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSoaRecord),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSoaRecord>())).minimum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSoaRecord),
            "::",
            stringify!(minimum)
        )
    );
}
#[doc = " Payload of DNS SRV record (header)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsSrvRecord {
    #[doc = " Preference for this entry (lower value is higher preference).  Clients"]
    #[doc = " will contact hosts from the lowest-priority group first and fall back"]
    #[doc = " to higher priorities if the low-priority entries are unavailable. (NBO)"]
    pub prio: u16,
    #[doc = " Relative weight for records with the same priority.  Clients will use"]
    #[doc = " the hosts of the same (lowest) priority with a probability proportional"]
    #[doc = " to the weight given. (NBO)"]
    pub weight: u16,
    #[doc = " TCP or UDP port of the service. (NBO)"]
    pub port: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsSrvRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsSrvRecord>(),
        6usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsSrvRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsSrvRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsSrvRecord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSrvRecord>())).prio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSrvRecord),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSrvRecord>())).weight as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSrvRecord),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsSrvRecord>())).port as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsSrvRecord),
            "::",
            stringify!(port)
        )
    );
}
#[doc = " Payload of DNS CERT record."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsCertRecord {
    #[doc = " Certificate type"]
    pub cert_type: u16,
    #[doc = " Certificate KeyTag"]
    pub cert_tag: u16,
    #[doc = " Algorithm"]
    pub algorithm: u8,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsCertRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsCertRecord>(),
        6usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsCertRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsCertRecord>(),
        2usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsCertRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsCertRecord>())).cert_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsCertRecord),
            "::",
            stringify!(cert_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsCertRecord>())).cert_tag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsCertRecord),
            "::",
            stringify!(cert_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsCertRecord>())).algorithm as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsCertRecord),
            "::",
            stringify!(algorithm)
        )
    );
}
#[doc = " Payload of DNSSEC TLSA record."]
#[doc = " http://datatracker.ietf.org/doc/draft-ietf-dane-protocol/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsTlsaRecord {
    #[doc = " Certificate usage"]
    #[doc = " 0: CA cert"]
    #[doc = " 1: Entity cert"]
    #[doc = " 2: Trust anchor"]
    #[doc = " 3: domain-issued cert"]
    pub usage: u8,
    #[doc = " Selector"]
    #[doc = " What part will be matched against the cert"]
    #[doc = " presented by server"]
    #[doc = " 0: Full cert (in binary)"]
    #[doc = " 1: Full cert (in DER)"]
    pub selector: u8,
    #[doc = " Matching type (of selected content)"]
    #[doc = " 0: exact match"]
    #[doc = " 1: SHA-256 hash"]
    #[doc = " 2: SHA-512 hash"]
    pub matching_type: u8,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsTlsaRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsTlsaRecord>(),
        3usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsTlsaRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsTlsaRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsTlsaRecord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsTlsaRecord>())).usage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsTlsaRecord),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsTlsaRecord>())).selector as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsTlsaRecord),
            "::",
            stringify!(selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsTlsaRecord>())).matching_type as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsTlsaRecord),
            "::",
            stringify!(matching_type)
        )
    );
}
#[doc = " Payload of GNS VPN record"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_GnsVpnRecord {
    #[doc = " The peer to contact"]
    pub peer: GNUNET_PeerIdentity,
    #[doc = " The protocol to use"]
    pub proto: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_GnsVpnRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_GnsVpnRecord>(),
        34usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_GnsVpnRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_GnsVpnRecord>(),
        2usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_GnsVpnRecord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_GnsVpnRecord>())).peer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_GnsVpnRecord),
            "::",
            stringify!(peer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_GnsVpnRecord>())).proto as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_GnsVpnRecord),
            "::",
            stringify!(proto)
        )
    );
}
#[doc = " DNS query prefix."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsQueryLine {
    #[doc = " Desired type (GNUNET_DNSPARSER_TYPE_XXX). (NBO)"]
    pub type_: u16,
    #[doc = " Desired class (usually GNUNET_TUN_DNS_CLASS_INTERNET). (NBO)"]
    pub dns_traffic_class: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsQueryLine() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsQueryLine>(),
        4usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsQueryLine))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsQueryLine>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsQueryLine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsQueryLine>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsQueryLine),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsQueryLine>())).dns_traffic_class as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsQueryLine),
            "::",
            stringify!(dns_traffic_class)
        )
    );
}
#[doc = " General DNS record prefix."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_DnsRecordLine {
    #[doc = " Record type (GNUNET_DNSPARSER_TYPE_XXX). (NBO)"]
    pub type_: u16,
    #[doc = " Record class (usually GNUNET_TUN_DNS_CLASS_INTERNET). (NBO)"]
    pub dns_traffic_class: u16,
    #[doc = " Expiration for the record (in seconds). (NBO)"]
    pub ttl: u32,
    #[doc = " Number of bytes of data that follow. (NBO)"]
    pub data_len: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_DnsRecordLine() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_DnsRecordLine>(),
        10usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_DnsRecordLine))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_DnsRecordLine>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_DnsRecordLine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsRecordLine>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsRecordLine),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsRecordLine>())).dns_traffic_class as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsRecordLine),
            "::",
            stringify!(dns_traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_DnsRecordLine>())).ttl as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsRecordLine),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_DnsRecordLine>())).data_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_DnsRecordLine),
            "::",
            stringify!(data_len)
        )
    );
}
#[doc = " ICMP header."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_TUN_IcmpHeader {
    pub type_: u8,
    pub code: u8,
    pub crc: u16,
    pub quench: GNUNET_TUN_IcmpHeader__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GNUNET_TUN_IcmpHeader__bindgen_ty_1 {
    pub echo: GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1,
    pub destination_unreachable: GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu,
    #[doc = " ICMP Redirect"]
    pub redirect_gateway_address: in_addr,
    #[doc = " MTU for packets that are too big (IPv6)."]
    pub packet_too_big_mtu: u32,
    _bindgen_union_align: u32,
}
#[doc = " ICMP Echo (request/reply)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1 {
    pub identifier: u16,
    pub sequence_number: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1>())).identifier
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1>()))
                .sequence_number as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sequence_number)
        )
    );
}
#[doc = " ICMP Destination Unreachable (RFC 1191)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu {
    pub empty: u16,
    pub next_hop_mtu: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu>())).empty
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu),
            "::",
            stringify!(empty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu>())).next_hop_mtu
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1_ih_pmtu),
            "::",
            stringify!(next_hop_mtu)
        )
    );
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_IcmpHeader__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_IcmpHeader__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_IcmpHeader__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1>())).echo as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1),
            "::",
            stringify!(echo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1>())).destination_unreachable
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1),
            "::",
            stringify!(destination_unreachable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1>())).redirect_gateway_address
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1),
            "::",
            stringify!(redirect_gateway_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader__bindgen_ty_1>())).packet_too_big_mtu
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader__bindgen_ty_1),
            "::",
            stringify!(packet_too_big_mtu)
        )
    );
}
#[test]
fn bindgen_test_layout_GNUNET_TUN_IcmpHeader() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TUN_IcmpHeader>(),
        8usize,
        concat!("Size of: ", stringify!(GNUNET_TUN_IcmpHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TUN_IcmpHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_TUN_IcmpHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader>())).code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader>())).crc as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_TUN_IcmpHeader>())).quench as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TUN_IcmpHeader),
            "::",
            stringify!(quench)
        )
    );
}
extern "C" {
    #[doc = " Initialize an IPv4 header."]
    #[doc = ""]
    #[doc = " @param ip header to initialize"]
    #[doc = " @param protocol protocol to use (i.e. IPPROTO_UDP)"]
    #[doc = " @param payload_length number of bytes of payload that follow (excluding IPv4"]
    #[doc = " header)"]
    #[doc = " @param src source IP address to use"]
    #[doc = " @param dst destination IP address to use"]
    pub fn GNUNET_TUN_initialize_ipv4_header(
        ip: *mut GNUNET_TUN_IPv4Header,
        protocol: u8,
        payload_length: u16,
        src: *const in_addr,
        dst: *const in_addr,
    );
}
extern "C" {
    #[doc = " Initialize an IPv6 header."]
    #[doc = ""]
    #[doc = " @param ip header to initialize"]
    #[doc = " @param protocol protocol to use (i.e. IPPROTO_UDP)"]
    #[doc = " @param payload_length number of bytes of payload that follow (excluding IPv4"]
    #[doc = " header)"]
    #[doc = " @param src source IP address to use"]
    #[doc = " @param dst destination IP address to use"]
    pub fn GNUNET_TUN_initialize_ipv6_header(
        ip: *mut GNUNET_TUN_IPv6Header,
        protocol: u8,
        payload_length: u16,
        src: *const in6_addr,
        dst: *const in6_addr,
    );
}
extern "C" {
    #[doc = " Calculate IPv4 TCP checksum."]
    #[doc = ""]
    #[doc = " @param ip ipv4 header fully initialized"]
    #[doc = " @param tcp TCP header (initialized except for CRC)"]
    #[doc = " @param payload the TCP payload"]
    #[doc = " @param payload_length number of bytes of TCP @a payload"]
    pub fn GNUNET_TUN_calculate_tcp4_checksum(
        ip: *const GNUNET_TUN_IPv4Header,
        tcp: *mut GNUNET_TUN_TcpHeader,
        payload: *const ::std::os::raw::c_void,
        payload_length: u16,
    );
}
extern "C" {
    #[doc = " Calculate IPv6 TCP checksum."]
    #[doc = ""]
    #[doc = " @param ip ipv6 header fully initialized"]
    #[doc = " @param tcp TCP header (initialized except for CRC)"]
    #[doc = " @param payload the TCP payload"]
    #[doc = " @param payload_length number of bytes of TCP payload"]
    pub fn GNUNET_TUN_calculate_tcp6_checksum(
        ip: *const GNUNET_TUN_IPv6Header,
        tcp: *mut GNUNET_TUN_TcpHeader,
        payload: *const ::std::os::raw::c_void,
        payload_length: u16,
    );
}
extern "C" {
    #[doc = " Calculate IPv4 UDP checksum."]
    #[doc = ""]
    #[doc = " @param ip ipv4 header fully initialized"]
    #[doc = " @param udp UDP header (initialized except for CRC)"]
    #[doc = " @param payload the UDP payload"]
    #[doc = " @param payload_length number of bytes of UDP @a payload"]
    pub fn GNUNET_TUN_calculate_udp4_checksum(
        ip: *const GNUNET_TUN_IPv4Header,
        udp: *mut GNUNET_TUN_UdpHeader,
        payload: *const ::std::os::raw::c_void,
        payload_length: u16,
    );
}
extern "C" {
    #[doc = " Calculate IPv6 UDP checksum."]
    #[doc = ""]
    #[doc = " @param ip ipv6 header fully initialized"]
    #[doc = " @param udp UDP header (initialized except for CRC)"]
    #[doc = " @param payload the UDP payload"]
    #[doc = " @param payload_length number of bytes of @a payload"]
    pub fn GNUNET_TUN_calculate_udp6_checksum(
        ip: *const GNUNET_TUN_IPv6Header,
        udp: *mut GNUNET_TUN_UdpHeader,
        payload: *const ::std::os::raw::c_void,
        payload_length: u16,
    );
}
extern "C" {
    #[doc = " Calculate ICMP checksum."]
    #[doc = ""]
    #[doc = " @param icmp IMCP header (initialized except for CRC)"]
    #[doc = " @param payload the ICMP payload"]
    #[doc = " @param payload_length number of bytes of @a payload"]
    pub fn GNUNET_TUN_calculate_icmp_checksum(
        icmp: *mut GNUNET_TUN_IcmpHeader,
        payload: *const ::std::os::raw::c_void,
        payload_length: u16,
    );
}
extern "C" {
    #[doc = " Create a regex in @a rxstr from the given @a ip and @a port."]
    #[doc = ""]
    #[doc = " @param ip IPv4 representation."]
    #[doc = " @param port destination port"]
    #[doc = " @param rxstr generated regex, must be at least #GNUNET_TUN_IPV4_REGEXLEN"]
    #[doc = "              bytes long."]
    pub fn GNUNET_TUN_ipv4toregexsearch(
        ip: *const in_addr,
        port: u16,
        rxstr: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Create a regex in @a rxstr from the given @a ipv6 and @a port."]
    #[doc = ""]
    #[doc = " @param ipv6 IPv6 representation."]
    #[doc = " @param port destination port"]
    #[doc = " @param rxstr generated regex, must be at least #GNUNET_TUN_IPV6_REGEXLEN"]
    #[doc = "              bytes long."]
    pub fn GNUNET_TUN_ipv6toregexsearch(
        ipv6: *const in6_addr,
        port: u16,
        rxstr: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Convert an exit policy to a regular expression.  The exit policy"]
    #[doc = " specifies a set of subnets this peer is willing to serve as an"]
    #[doc = " exit for; the resulting regular expression will match the"]
    #[doc = " IPv6 address strings as returned by #GNUNET_TUN_ipv6toregexsearch."]
    #[doc = ""]
    #[doc = " @param policy exit policy specification"]
    #[doc = " @return regular expression, NULL on error"]
    pub fn GNUNET_TUN_ipv6policy2regex(
        policy: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert an exit policy to a regular expression.  The exit policy"]
    #[doc = " specifies a set of subnets this peer is willing to serve as an"]
    #[doc = " exit for; the resulting regular expression will match the"]
    #[doc = " IPv4 address strings as returned by #GNUNET_TUN_ipv4toregexsearch."]
    #[doc = ""]
    #[doc = " @param policy exit policy specification"]
    #[doc = " @return regular expression, NULL on error"]
    pub fn GNUNET_TUN_ipv4policy2regex(
        policy: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Hash the service name of a hosted service to the"]
    #[doc = " hash code that is used to identify the service on"]
    #[doc = " the network."]
    #[doc = ""]
    #[doc = " @param service_name a string"]
    #[doc = " @param[out] hc corresponding hash"]
    pub fn GNUNET_TUN_service_name_to_hash(
        service_name: *const ::std::os::raw::c_char,
        hc: *mut GNUNET_HashCode,
    );
}
extern "C" {
    #[doc = " Check if two sockaddrs are equal."]
    #[doc = ""]
    #[doc = " @param sa one address"]
    #[doc = " @param sb another address"]
    #[doc = " @param include_port also check ports"]
    #[doc = " @return #GNUNET_YES if they are equal"]
    pub fn GNUNET_TUN_sockaddr_cmp(
        sa: *const sockaddr,
        sb: *const sockaddr,
        include_port: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute the CADET port given a service descriptor"]
    #[doc = " (returned from #GNUNET_TUN_service_name_to_hash) and"]
    #[doc = " a TCP/UDP port @a ip_port."]
    #[doc = ""]
    #[doc = " @param desc service shared secret"]
    #[doc = " @param ip_port TCP/UDP port, use 0 for ICMP"]
    #[doc = " @param[out] cadet_port CADET port to use"]
    pub fn GNUNET_TUN_compute_service_cadet_port(
        desc: *const GNUNET_HashCode,
        ip_port: u16,
        cadet_port: *mut GNUNET_HashCode,
    );
}
#[doc = " Opaque handle to the stub resolver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSSTUB_Context {
    _unused: [u8; 0],
}
#[doc = " Opaque handle to a socket doing UDP requests."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSSTUB_RequestSocket {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Start a DNS stub resolver."]
    #[doc = ""]
    #[doc = " @param num_sockets how many sockets should we open"]
    #[doc = "        in parallel for DNS queries for this stub?"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_DNSSTUB_start(num_sockets: ::std::os::raw::c_uint)
        -> *mut GNUNET_DNSSTUB_Context;
}
extern "C" {
    #[doc = " Add nameserver for use by the DNSSTUB.  We will use"]
    #[doc = " all provided nameservers for resolution (round-robin)."]
    #[doc = ""]
    #[doc = " @param ctx resolver context to modify"]
    #[doc = " @param dns_ip target IP address to use (as string)"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_DNSSTUB_add_dns_ip(
        ctx: *mut GNUNET_DNSSTUB_Context,
        dns_ip: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add nameserver for use by the DNSSTUB.  We will use"]
    #[doc = " all provided nameservers for resolution (round-robin)."]
    #[doc = ""]
    #[doc = " @param ctx resolver context to modify"]
    #[doc = " @param sa socket address of DNS resolver to use"]
    #[doc = " @return #GNUNET_OK on success"]
    pub fn GNUNET_DNSSTUB_add_dns_sa(
        ctx: *mut GNUNET_DNSSTUB_Context,
        sa: *const sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " How long should we try requests before timing out?"]
    #[doc = " Only effective for requests issued after this call."]
    #[doc = ""]
    #[doc = " @param ctx resolver context to modify"]
    #[doc = " @param retry_frequ how long to wait between retries"]
    pub fn GNUNET_DNSSTUB_set_retry(
        ctx: *mut GNUNET_DNSSTUB_Context,
        retry_freq: GNUNET_TIME_Relative,
    );
}
extern "C" {
    #[doc = " Cleanup DNSSTUB resolver."]
    #[doc = ""]
    #[doc = " @param ctx stub resolver to clean up"]
    pub fn GNUNET_DNSSTUB_stop(ctx: *mut GNUNET_DNSSTUB_Context);
}
#[doc = " Function called with the result of a DNS resolution."]
#[doc = " Once this function is called, the resolution request"]
#[doc = " is automatically cancelled / cleaned up.  In particular,"]
#[doc = " the function will only be called once."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param dns dns response, NULL on hard error (i.e. timeout)"]
#[doc = " @param dns_len number of bytes in @a dns"]
pub type GNUNET_DNSSTUB_ResultCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        dns: *const GNUNET_TUN_DnsHeader,
        dns_len: usize,
    ),
>;
extern "C" {
    #[doc = " Perform DNS resolution using our default IP from init."]
    #[doc = ""]
    #[doc = " @param ctx stub resolver to use"]
    #[doc = " @param request DNS request to transmit"]
    #[doc = " @param request_len number of bytes in msg"]
    #[doc = " @param rc function to call with result (once)"]
    #[doc = " @param rc_cls closure for @a rc"]
    #[doc = " @return socket used for the request, NULL on error"]
    pub fn GNUNET_DNSSTUB_resolve(
        ctx: *mut GNUNET_DNSSTUB_Context,
        request: *const ::std::os::raw::c_void,
        request_len: usize,
        rc: GNUNET_DNSSTUB_ResultCallback,
        rc_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_DNSSTUB_RequestSocket;
}
extern "C" {
    #[doc = " Cancel DNS resolution."]
    #[doc = ""]
    #[doc = " @param rs resolution to cancel"]
    pub fn GNUNET_DNSSTUB_resolve_cancel(rs: *mut GNUNET_DNSSTUB_RequestSocket);
}
#[doc = " A DNS query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_Query {
    #[doc = " Name of the record that the query is for (0-terminated)."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " See GNUNET_DNSPARSER_TYPE_*."]
    pub type_: u16,
    #[doc = " See GNUNET_TUN_DNS_CLASS_*."]
    pub dns_traffic_class: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_Query() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_Query>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_Query))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_Query>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_Query))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Query>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Query),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Query>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Query),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Query>())).dns_traffic_class as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Query),
            "::",
            stringify!(dns_traffic_class)
        )
    );
}
#[doc = " Information from MX records (RFC 1035)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_MxRecord {
    #[doc = " Preference for this entry (lower value is higher preference)."]
    pub preference: u16,
    #[doc = " Name of the mail server."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub mxhost: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_MxRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_MxRecord>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_MxRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_MxRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_MxRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_MxRecord>())).preference as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_MxRecord),
            "::",
            stringify!(preference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_MxRecord>())).mxhost as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_MxRecord),
            "::",
            stringify!(mxhost)
        )
    );
}
#[doc = " Information from SRV records (RFC 2782)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_SrvRecord {
    #[doc = " Hostname offering the service."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub target: *mut ::std::os::raw::c_char,
    #[doc = " Preference for this entry (lower value is higher preference).  Clients"]
    #[doc = " will contact hosts from the lowest-priority group first and fall back"]
    #[doc = " to higher priorities if the low-priority entries are unavailable."]
    pub priority: u16,
    #[doc = " Relative weight for records with the same priority.  Clients will use"]
    #[doc = " the hosts of the same (lowest) priority with a probability proportional"]
    #[doc = " to the weight given."]
    pub weight: u16,
    #[doc = " TCP or UDP port of the service."]
    pub port: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_SrvRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_SrvRecord>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_SrvRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_SrvRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_SrvRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SrvRecord>())).target as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SrvRecord),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SrvRecord>())).priority as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SrvRecord),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SrvRecord>())).weight as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SrvRecord),
            "::",
            stringify!(weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_SrvRecord>())).port as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SrvRecord),
            "::",
            stringify!(port)
        )
    );
}
#[doc = "  Reserved value"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_RESERVED: GNUNET_DNSPARSER_CertType =
    0;
#[doc = " An x509 PKIX certificate"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_PKIX: GNUNET_DNSPARSER_CertType = 1;
#[doc = " A SKPI certificate"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_SKPI: GNUNET_DNSPARSER_CertType = 2;
#[doc = " A PGP certificate"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_PGP: GNUNET_DNSPARSER_CertType = 3;
#[doc = " An x509 PKIX cert URL"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_IPKIX: GNUNET_DNSPARSER_CertType = 4;
#[doc = " A SKPI cert URL"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_ISKPI: GNUNET_DNSPARSER_CertType = 5;
#[doc = " A PGP cert fingerprint and URL"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_IPGP: GNUNET_DNSPARSER_CertType = 6;
#[doc = " An attribute Certificate"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_ACPKIX: GNUNET_DNSPARSER_CertType = 7;
#[doc = " An attribute cert URL"]
pub const GNUNET_DNSPARSER_CertType_GNUNET_DNSPARSER_CERTTYPE_IACKPIX: GNUNET_DNSPARSER_CertType =
    8;
#[doc = " DNS CERT types as defined in RFC 4398."]
pub type GNUNET_DNSPARSER_CertType = ::std::os::raw::c_uint;
#[doc = " No defined"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_UNDEFINED:
    GNUNET_DNSPARSER_CertAlgorithm = 0;
#[doc = " RSA/MD5"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSAMD5:
    GNUNET_DNSPARSER_CertAlgorithm = 1;
#[doc = " Diffie-Hellman"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_DH:
    GNUNET_DNSPARSER_CertAlgorithm = 2;
#[doc = " DSA/SHA1"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_DSASHA:
    GNUNET_DNSPARSER_CertAlgorithm = 3;
#[doc = " Reserved"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSRVD4:
    GNUNET_DNSPARSER_CertAlgorithm = 4;
#[doc = " RSA/SHA1"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSASHA:
    GNUNET_DNSPARSER_CertAlgorithm = 5;
#[doc = " DSA/NSEC3/SHA"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_DSANSEC3:
    GNUNET_DNSPARSER_CertAlgorithm = 6;
#[doc = " RSA/NSEC3/SHA"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSANSEC3:
    GNUNET_DNSPARSER_CertAlgorithm = 7;
#[doc = " RSA/SHA256"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSASHA256:
    GNUNET_DNSPARSER_CertAlgorithm = 8;
#[doc = " Reserved"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSRVD9:
    GNUNET_DNSPARSER_CertAlgorithm = 9;
#[doc = " RSA/SHA512"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_RSASHA512:
    GNUNET_DNSPARSER_CertAlgorithm = 10;
#[doc = " GHOST R 34.10-2001"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_GOST_R34:
    GNUNET_DNSPARSER_CertAlgorithm = 12;
#[doc = " ECDSA Curve P-256/SHA256"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_ECDSA_P256SHA256:
    GNUNET_DNSPARSER_CertAlgorithm = 13;
#[doc = " ECDSA Curve P-384/SHA384"]
pub const GNUNET_DNSPARSER_CertAlgorithm_GNUNET_DNSPARSER_CERTALGO_ECDSA_P384SHA384:
    GNUNET_DNSPARSER_CertAlgorithm = 14;
#[doc = " DNSCERT algorithms as defined in http://www.iana.org/assignments/"]
#[doc = "  dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml, under dns-sec-alg-numbers-1"]
pub type GNUNET_DNSPARSER_CertAlgorithm = ::std::os::raw::c_uint;
#[doc = " Information from CERT records (RFC 4034)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_CertRecord {
    #[doc = " Certificate type"]
    pub cert_type: GNUNET_DNSPARSER_CertType,
    #[doc = " Certificate KeyTag"]
    pub cert_tag: u16,
    #[doc = " Algorithm"]
    pub algorithm: GNUNET_DNSPARSER_CertAlgorithm,
    #[doc = " Number of bytes in @e certificate_data"]
    pub certificate_size: usize,
    #[doc = " Data of the certificate."]
    pub certificate_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_CertRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_CertRecord>(),
        32usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_CertRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_CertRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_CertRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CertRecord>())).cert_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CertRecord),
            "::",
            stringify!(cert_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CertRecord>())).cert_tag as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CertRecord),
            "::",
            stringify!(cert_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CertRecord>())).algorithm as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CertRecord),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CertRecord>())).certificate_size as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CertRecord),
            "::",
            stringify!(certificate_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CertRecord>())).certificate_data as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CertRecord),
            "::",
            stringify!(certificate_data)
        )
    );
}
#[doc = " Information from SOA records (RFC 1035)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_SoaRecord {
    #[doc = " The domainname of the name server that was the"]
    #[doc = " original or primary source of data for this zone."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub mname: *mut ::std::os::raw::c_char,
    #[doc = " A domainname which specifies the mailbox of the"]
    #[doc = " person responsible for this zone."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub rname: *mut ::std::os::raw::c_char,
    #[doc = " The version number of the original copy of the zone."]
    pub serial: u32,
    #[doc = " Time interval before the zone should be refreshed."]
    pub refresh: u32,
    #[doc = " Time interval that should elapse before a failed refresh should"]
    #[doc = " be retried."]
    pub retry: u32,
    #[doc = " Time value that specifies the upper limit on the time interval"]
    #[doc = " that can elapse before the zone is no longer authoritative."]
    pub expire: u32,
    #[doc = " The bit minimum TTL field that should be exported with any RR"]
    #[doc = " from this zone."]
    pub minimum_ttl: u32,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_SoaRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_SoaRecord>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_SoaRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_SoaRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_SoaRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).mname as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(mname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).rname as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(rname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).serial as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).refresh as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(refresh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).retry as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(retry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).expire as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(expire)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_SoaRecord>())).minimum_ttl as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_SoaRecord),
            "::",
            stringify!(minimum_ttl)
        )
    );
}
#[doc = " Information from CAA records (RFC 6844)."]
#[doc = " The tag is followed by the tag_len."]
#[doc = " The value is followed by the tag for (d - tag_len - 2) bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_CaaRecord {
    #[doc = " The flags of the CAA record."]
    pub flags: u8,
    #[doc = " The length of the tag."]
    pub tag_len: u8,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_CaaRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_CaaRecord>(),
        2usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_CaaRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_CaaRecord>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_CaaRecord))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CaaRecord>())).flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CaaRecord),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_CaaRecord>())).tag_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_CaaRecord),
            "::",
            stringify!(tag_len)
        )
    );
}
#[doc = " Binary record information (unparsed)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_RawRecord {
    #[doc = " Binary record data."]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = " Number of bytes in data."]
    pub data_len: usize,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_RawRecord() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_RawRecord>(),
        16usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_RawRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_RawRecord>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_RawRecord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_RawRecord>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_RawRecord),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_RawRecord>())).data_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_RawRecord),
            "::",
            stringify!(data_len)
        )
    );
}
#[doc = " A DNS response record."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_DNSPARSER_Record {
    #[doc = " Name of the record that the query is for (0-terminated)."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub name: *mut ::std::os::raw::c_char,
    pub data: GNUNET_DNSPARSER_Record__bindgen_ty_1,
    #[doc = " When does the record expire?"]
    pub expiration_time: GNUNET_TIME_Absolute,
    #[doc = " See GNUNET_DNSPARSER_TYPE_*."]
    pub type_: u16,
    #[doc = " See GNUNET_TUN_DNS_CLASS_*."]
    pub dns_traffic_class: u16,
}
#[doc = " Payload of the record (which one of these is valid depends on the 'type')."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union GNUNET_DNSPARSER_Record__bindgen_ty_1 {
    #[doc = " For NS, CNAME and PTR records, this is the uncompressed 0-terminated hostname."]
    #[doc = " In UTF-8 format.  The library will convert from and to DNS-IDNA"]
    #[doc = " as necessary.  Use #GNUNET_DNSPARSER_check_label() to test if an"]
    #[doc = " individual label is well-formed.  If a given name is not well-formed,"]
    #[doc = " creating the DNS packet will fail."]
    pub hostname: *mut ::std::os::raw::c_char,
    #[doc = " SOA data for SOA records."]
    pub soa: *mut GNUNET_DNSPARSER_SoaRecord,
    #[doc = " CERT data for CERT records."]
    pub cert: *mut GNUNET_DNSPARSER_CertRecord,
    #[doc = " MX data for MX records."]
    pub mx: *mut GNUNET_DNSPARSER_MxRecord,
    #[doc = " SRV data for SRV records."]
    pub srv: *mut GNUNET_DNSPARSER_SrvRecord,
    #[doc = " Raw data for all other types."]
    pub raw: GNUNET_DNSPARSER_RawRecord,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_Record__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_Record__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_Record__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record__bindgen_ty_1>())).hostname as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record__bindgen_ty_1>())).soa as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1),
            "::",
            stringify!(soa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record__bindgen_ty_1>())).cert as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record__bindgen_ty_1>())).mx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1),
            "::",
            stringify!(mx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record__bindgen_ty_1>())).srv as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1),
            "::",
            stringify!(srv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record__bindgen_ty_1>())).raw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_Record() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_Record>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_Record))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_Record>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_Record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record>())).expiration_time as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record),
            "::",
            stringify!(expiration_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Record>())).dns_traffic_class as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Record),
            "::",
            stringify!(dns_traffic_class)
        )
    );
}
#[doc = " Easy-to-process, parsed version of a DNS packet."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_DNSPARSER_Packet {
    #[doc = " Array of all queries in the packet, must contain \"num_queries\" entries."]
    pub queries: *mut GNUNET_DNSPARSER_Query,
    #[doc = " Array of all answers in the packet, must contain \"num_answers\" entries."]
    pub answers: *mut GNUNET_DNSPARSER_Record,
    #[doc = " Array of all authority records in the packet, must contain \"num_authority_records\" entries."]
    pub authority_records: *mut GNUNET_DNSPARSER_Record,
    #[doc = " Array of all additional answers in the packet, must contain \"num_additional_records\" entries."]
    pub additional_records: *mut GNUNET_DNSPARSER_Record,
    #[doc = " Number of queries in the packet."]
    pub num_queries: ::std::os::raw::c_uint,
    #[doc = " Number of answers in the packet, should be 0 for queries."]
    pub num_answers: ::std::os::raw::c_uint,
    #[doc = " Number of authoritative answers in the packet, should be 0 for queries."]
    pub num_authority_records: ::std::os::raw::c_uint,
    #[doc = " Number of additional records in the packet, should be 0 for queries."]
    pub num_additional_records: ::std::os::raw::c_uint,
    #[doc = " Bitfield of DNS flags."]
    pub flags: GNUNET_TUN_DnsFlags,
    #[doc = " DNS ID (to match replies to requests)."]
    pub id: u16,
}
#[test]
fn bindgen_test_layout_GNUNET_DNSPARSER_Packet() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_DNSPARSER_Packet>(),
        56usize,
        concat!("Size of: ", stringify!(GNUNET_DNSPARSER_Packet))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_DNSPARSER_Packet>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_DNSPARSER_Packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).queries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(queries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).answers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(answers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).authority_records as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(authority_records)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).additional_records as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(additional_records)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).num_queries as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(num_queries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).num_answers as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(num_answers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).num_authority_records as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(num_authority_records)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).num_additional_records as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(num_additional_records)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_DNSPARSER_Packet>())).id as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_DNSPARSER_Packet),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    #[doc = " Check if a label in UTF-8 format can be coded into valid IDNA."]
    #[doc = " This can fail if the ASCII-conversion becomes longer than 63 characters."]
    #[doc = ""]
    #[doc = " @param label label to check (UTF-8 string)"]
    #[doc = " @return #GNUNET_OK if the label can be converted to IDNA,"]
    #[doc = "         #GNUNET_SYSERR if the label is not valid for DNS names"]
    pub fn GNUNET_DNSPARSER_check_label(
        label: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a hostname in UTF-8 format can be coded into valid IDNA."]
    #[doc = " This can fail if a label becomes longer than 63 characters or if"]
    #[doc = " the entire name exceeds 253 characters."]
    #[doc = ""]
    #[doc = " @param name name to check (UTF-8 string)"]
    #[doc = " @return #GNUNET_OK if the label can be converted to IDNA,"]
    #[doc = "         #GNUNET_SYSERR if the label is not valid for DNS names"]
    pub fn GNUNET_DNSPARSER_check_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a UDP payload of a DNS packet in to a nice struct for further"]
    #[doc = " processing and manipulation."]
    #[doc = ""]
    #[doc = " @param udp_payload wire-format of the DNS packet"]
    #[doc = " @param udp_payload_length number of bytes in @a udp_payload"]
    #[doc = " @return NULL on error, otherwise the parsed packet"]
    pub fn GNUNET_DNSPARSER_parse(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
    ) -> *mut GNUNET_DNSPARSER_Packet;
}
extern "C" {
    #[doc = " Free memory taken by a packet."]
    #[doc = ""]
    #[doc = " @param p packet to free"]
    pub fn GNUNET_DNSPARSER_free_packet(p: *mut GNUNET_DNSPARSER_Packet);
}
extern "C" {
    #[doc = " Given a DNS packet @a p, generate the corresponding UDP payload."]
    #[doc = " Note that we do not attempt to pack the strings with pointers"]
    #[doc = " as this would complicate the code and this is about being"]
    #[doc = " simple and secure, not fast, fancy and broken like bind."]
    #[doc = ""]
    #[doc = " @param p packet to pack"]
    #[doc = " @param max maximum allowed size for the resulting UDP payload"]
    #[doc = " @param buf set to a buffer with the packed message"]
    #[doc = " @param buf_length set to the length of @a buf"]
    #[doc = " @return #GNUNET_SYSERR if @a p is invalid"]
    #[doc = "         #GNUNET_NO if @a p was truncated (but there is still a result in @a buf)"]
    #[doc = "         #GNUNET_OK if @a p was packed completely into @a buf"]
    pub fn GNUNET_DNSPARSER_pack(
        p: *const GNUNET_DNSPARSER_Packet,
        max: u16,
        buf: *mut *mut ::std::os::raw::c_char,
        buf_length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a DNS name to the UDP packet at the given location, converting"]
    #[doc = " the name to IDNA notation as necessary."]
    #[doc = ""]
    #[doc = " @param dst where to write the name (UDP packet)"]
    #[doc = " @param dst_len number of bytes in @a dst"]
    #[doc = " @param off pointer to offset where to write the name (increment by bytes used)"]
    #[doc = "            must not be changed if there is an error"]
    #[doc = " @param name name to write"]
    #[doc = " @return #GNUNET_SYSERR if @a name is invalid"]
    #[doc = "         #GNUNET_NO if @a name did not fit"]
    #[doc = "         #GNUNET_OK if @a name was added to @a dst"]
    pub fn GNUNET_DNSPARSER_builder_add_name(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        off: *mut usize,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a DNS query to the UDP packet at the given location."]
    #[doc = ""]
    #[doc = " @param dst where to write the query"]
    #[doc = " @param dst_len number of bytes in @a dst"]
    #[doc = " @param off pointer to offset where to write the query (increment by bytes used)"]
    #[doc = "            must not be changed if there is an error"]
    #[doc = " @param query query to write"]
    #[doc = " @return #GNUNET_SYSERR if @a query is invalid"]
    #[doc = "         #GNUNET_NO if @a query did not fit"]
    #[doc = "         #GNUNET_OK if @a query was added to @a dst"]
    pub fn GNUNET_DNSPARSER_builder_add_query(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        off: *mut usize,
        query: *const GNUNET_DNSPARSER_Query,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an MX record to the UDP packet at the given location."]
    #[doc = ""]
    #[doc = " @param dst where to write the mx record"]
    #[doc = " @param dst_len number of bytes in @a dst"]
    #[doc = " @param off pointer to offset where to write the mx information (increment by bytes used);"]
    #[doc = "            can also change if there was an error"]
    #[doc = " @param mx mx information to write"]
    #[doc = " @return #GNUNET_SYSERR if @a mx is invalid"]
    #[doc = "         #GNUNET_NO if @a mx did not fit"]
    #[doc = "         #GNUNET_OK if @a mx was added to @a dst"]
    pub fn GNUNET_DNSPARSER_builder_add_mx(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        off: *mut usize,
        mx: *const GNUNET_DNSPARSER_MxRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an SOA record to the UDP packet at the given location."]
    #[doc = ""]
    #[doc = " @param dst where to write the SOA record"]
    #[doc = " @param dst_len number of bytes in @a dst"]
    #[doc = " @param off pointer to offset where to write the SOA information (increment by bytes used)"]
    #[doc = "            can also change if there was an error"]
    #[doc = " @param soa SOA information to write"]
    #[doc = " @return #GNUNET_SYSERR if @a soa is invalid"]
    #[doc = "         #GNUNET_NO if @a soa did not fit"]
    #[doc = "         #GNUNET_OK if @a soa was added to @a dst"]
    pub fn GNUNET_DNSPARSER_builder_add_soa(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        off: *mut usize,
        soa: *const GNUNET_DNSPARSER_SoaRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add CERT record to the UDP packet at the given location."]
    #[doc = ""]
    #[doc = " @param dst where to write the CERT record"]
    #[doc = " @param dst_len number of bytes in @a dst"]
    #[doc = " @param off pointer to offset where to write the CERT information (increment by bytes used)"]
    #[doc = "            can also change if there was an error"]
    #[doc = " @param cert CERT information to write"]
    #[doc = " @return #GNUNET_SYSERR if @a soa is invalid"]
    #[doc = "         #GNUNET_NO if @a soa did not fit"]
    #[doc = "         #GNUNET_OK if @a soa was added to @a dst"]
    pub fn GNUNET_DNSPARSER_builder_add_cert(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        off: *mut usize,
        cert: *const GNUNET_DNSPARSER_CertRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add an SRV record to the UDP packet at the given location."]
    #[doc = ""]
    #[doc = " @param dst where to write the SRV record"]
    #[doc = " @param dst_len number of bytes in @a dst"]
    #[doc = " @param off pointer to offset where to write the SRV information (increment by bytes used)"]
    #[doc = "            can also change if there was an error"]
    #[doc = " @param srv SRV information to write"]
    #[doc = " @return #GNUNET_SYSERR if @a srv is invalid"]
    #[doc = "         #GNUNET_NO if @a srv did not fit"]
    #[doc = "         #GNUNET_OK if @a srv was added to @a dst"]
    pub fn GNUNET_DNSPARSER_builder_add_srv(
        dst: *mut ::std::os::raw::c_char,
        dst_len: usize,
        off: *mut usize,
        srv: *const GNUNET_DNSPARSER_SrvRecord,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a DNS record entry."]
    #[doc = ""]
    #[doc = " @param udp_payload entire UDP payload"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the record to parse in the udp_payload (to be"]
    #[doc = "                    incremented by the size of the record)"]
    #[doc = " @param r where to write the record information"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if the record is malformed"]
    pub fn GNUNET_DNSPARSER_parse_record(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
        r: *mut GNUNET_DNSPARSER_Record,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse name inside of a DNS query or record."]
    #[doc = ""]
    #[doc = " @param udp_payload entire UDP payload"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the name to parse in the udp_payload (to be"]
    #[doc = "                    incremented by the size of the name)"]
    #[doc = " @return name as 0-terminated C string on success, NULL if the payload is malformed"]
    pub fn GNUNET_DNSPARSER_parse_name(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a DNS query entry."]
    #[doc = ""]
    #[doc = " @param udp_payload entire UDP payload"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the query to parse in the udp_payload (to be"]
    #[doc = "                    incremented by the size of the query)"]
    #[doc = " @param q where to write the query information"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if the query is malformed"]
    pub fn GNUNET_DNSPARSER_parse_query(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
        q: *mut GNUNET_DNSPARSER_Query,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a DNS SOA record."]
    #[doc = ""]
    #[doc = " @param udp_payload reference to UDP packet"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the query to parse in the SOA record (to be"]
    #[doc = "                    incremented by the size of the record), unchanged on error"]
    #[doc = " @return the parsed SOA record, NULL on error"]
    pub fn GNUNET_DNSPARSER_parse_soa(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
    ) -> *mut GNUNET_DNSPARSER_SoaRecord;
}
extern "C" {
    #[doc = " Parse a DNS CERT record."]
    #[doc = ""]
    #[doc = " @param udp_payload reference to UDP packet"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the query to parse in the CERT record (to be"]
    #[doc = "                    incremented by the size of the record), unchanged on error"]
    #[doc = " @return the parsed CERT record, NULL on error"]
    pub fn GNUNET_DNSPARSER_parse_cert(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
    ) -> *mut GNUNET_DNSPARSER_CertRecord;
}
extern "C" {
    #[doc = " Parse a DNS MX record."]
    #[doc = ""]
    #[doc = " @param udp_payload reference to UDP packet"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the query to parse in the MX record (to be"]
    #[doc = "                    incremented by the size of the record), unchanged on error"]
    #[doc = " @return the parsed MX record, NULL on error"]
    pub fn GNUNET_DNSPARSER_parse_mx(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
    ) -> *mut GNUNET_DNSPARSER_MxRecord;
}
extern "C" {
    #[doc = " Parse a DNS SRV record."]
    #[doc = ""]
    #[doc = " @param udp_payload reference to UDP packet"]
    #[doc = " @param udp_payload_length length of @a udp_payload"]
    #[doc = " @param off pointer to the offset of the query to parse in the SRV record (to be"]
    #[doc = "                    incremented by the size of the record), unchanged on error"]
    #[doc = " @return the parsed SRV record, NULL on error"]
    pub fn GNUNET_DNSPARSER_parse_srv(
        udp_payload: *const ::std::os::raw::c_char,
        udp_payload_length: usize,
        off: *mut usize,
    ) -> *mut GNUNET_DNSPARSER_SrvRecord;
}
extern "C" {
    #[doc = " Duplicate (deep-copy) the given DNS record"]
    #[doc = ""]
    #[doc = " @param r the record"]
    #[doc = " @return the newly allocated record"]
    pub fn GNUNET_DNSPARSER_duplicate_record(
        r: *const GNUNET_DNSPARSER_Record,
    ) -> *mut GNUNET_DNSPARSER_Record;
}
extern "C" {
    #[doc = " Duplicate (deep-copy) the given DNS record"]
    #[doc = ""]
    #[doc = " @param r the record"]
    #[doc = " @return the newly allocated record"]
    pub fn GNUNET_DNSPARSER_duplicate_soa_record(
        r: *const GNUNET_DNSPARSER_SoaRecord,
    ) -> *mut GNUNET_DNSPARSER_SoaRecord;
}
extern "C" {
    #[doc = " Duplicate (deep-copy) the given DNS record"]
    #[doc = ""]
    #[doc = " @param r the record"]
    #[doc = " @return the newly allocated record"]
    pub fn GNUNET_DNSPARSER_duplicate_cert_record(
        r: *const GNUNET_DNSPARSER_CertRecord,
    ) -> *mut GNUNET_DNSPARSER_CertRecord;
}
extern "C" {
    #[doc = " Duplicate (deep-copy) the given DNS record"]
    #[doc = ""]
    #[doc = " @param r the record"]
    #[doc = " @return the newly allocated record"]
    pub fn GNUNET_DNSPARSER_duplicate_mx_record(
        r: *const GNUNET_DNSPARSER_MxRecord,
    ) -> *mut GNUNET_DNSPARSER_MxRecord;
}
extern "C" {
    #[doc = " Duplicate (deep-copy) the given DNS record"]
    #[doc = ""]
    #[doc = " @param r the record"]
    #[doc = " @return the newly allocated record"]
    pub fn GNUNET_DNSPARSER_duplicate_srv_record(
        r: *const GNUNET_DNSPARSER_SrvRecord,
    ) -> *mut GNUNET_DNSPARSER_SrvRecord;
}
extern "C" {
    #[doc = " Free the given DNS record."]
    #[doc = ""]
    #[doc = " @param r record to free"]
    pub fn GNUNET_DNSPARSER_free_record(r: *mut GNUNET_DNSPARSER_Record);
}
extern "C" {
    #[doc = " Free MX information record."]
    #[doc = ""]
    #[doc = " @param mx record to free"]
    pub fn GNUNET_DNSPARSER_free_mx(mx: *mut GNUNET_DNSPARSER_MxRecord);
}
extern "C" {
    #[doc = " Free SRV information record."]
    #[doc = ""]
    #[doc = " @param srv record to free"]
    pub fn GNUNET_DNSPARSER_free_srv(srv: *mut GNUNET_DNSPARSER_SrvRecord);
}
extern "C" {
    #[doc = " Free SOA information record."]
    #[doc = ""]
    #[doc = " @param soa record to free"]
    pub fn GNUNET_DNSPARSER_free_soa(soa: *mut GNUNET_DNSPARSER_SoaRecord);
}
extern "C" {
    #[doc = " Free CERT information record."]
    #[doc = ""]
    #[doc = " @param cert record to free"]
    pub fn GNUNET_DNSPARSER_free_cert(cert: *mut GNUNET_DNSPARSER_CertRecord);
}
extern "C" {
    #[doc = " Convert a block of binary data to HEX."]
    #[doc = ""]
    #[doc = " @param data binary data to convert"]
    #[doc = " @param data_size number of bytes in @a data"]
    #[doc = " @return HEX string (lower case)"]
    pub fn GNUNET_DNSPARSER_bin_to_hex(
        data: *const ::std::os::raw::c_void,
        data_size: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a HEX string to block of binary data."]
    #[doc = ""]
    #[doc = " @param hex HEX string to convert (may contain mixed case)"]
    #[doc = " @param data where to write result, must be"]
    #[doc = "             at least `strlen(hex)/2` bytes long"]
    #[doc = " @return number of bytes written to data"]
    pub fn GNUNET_DNSPARSER_hex_to_bin(
        hex: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ) -> usize;
}
#[doc = " No additional information"]
pub const GNUNET_HELLO_AddressInfo_GNUNET_HELLO_ADDRESS_INFO_NONE: GNUNET_HELLO_AddressInfo = 0;
#[doc = " This is an inbound address and cannot be used to initiate an outbound"]
#[doc = " connection to another peer"]
pub const GNUNET_HELLO_AddressInfo_GNUNET_HELLO_ADDRESS_INFO_INBOUND: GNUNET_HELLO_AddressInfo = 1;
#[doc = " Additional local information about an address"]
#[doc = ""]
#[doc = " These information are only valid for the local peer and are not serialized"]
#[doc = " when a #GNUNET_HELLO_Message is created"]
pub type GNUNET_HELLO_AddressInfo = ::std::os::raw::c_uint;
#[doc = " An address for communicating with a peer.  We frequently"]
#[doc = " need this tuple and the components cannot really be"]
#[doc = " separated.  This is NOT the format that would be used"]
#[doc = " on the wire."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_HELLO_Address {
    #[doc = " For which peer is this an address?"]
    pub peer: GNUNET_PeerIdentity,
    #[doc = " Name of the transport plugin enabling the communication using"]
    #[doc = " this address."]
    pub transport_name: *const ::std::os::raw::c_char,
    #[doc = " Binary representation of the address (plugin-specific)."]
    pub address: *const ::std::os::raw::c_void,
    #[doc = " Number of bytes in @e address."]
    pub address_length: usize,
    #[doc = " Extended information about address"]
    #[doc = ""]
    #[doc = " This field contains additional #GNUNET_HELLO_AddressInfo flags e.g."]
    #[doc = " to indicate an address is inbound and cannot be used to initiate an"]
    #[doc = " outbound connection."]
    #[doc = ""]
    #[doc = " These information are only valid for the local peer and are not serialized"]
    #[doc = " when a #GNUNET_HELLO_Message is created"]
    pub local_info: GNUNET_HELLO_AddressInfo,
}
#[test]
fn bindgen_test_layout_GNUNET_HELLO_Address() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_HELLO_Address>(),
        64usize,
        concat!("Size of: ", stringify!(GNUNET_HELLO_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_HELLO_Address>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_HELLO_Address))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_HELLO_Address>())).peer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Address),
            "::",
            stringify!(peer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_HELLO_Address>())).transport_name as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Address),
            "::",
            stringify!(transport_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_HELLO_Address>())).address as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Address),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_HELLO_Address>())).address_length as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Address),
            "::",
            stringify!(address_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_HELLO_Address>())).local_info as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Address),
            "::",
            stringify!(local_info)
        )
    );
}
extern "C" {
    #[doc = " Allocate an address struct."]
    #[doc = ""]
    #[doc = " @param peer the peer"]
    #[doc = " @param transport_name plugin name"]
    #[doc = " @param address binary address"]
    #[doc = " @param address_length number of bytes in @a address"]
    #[doc = " @param local_info additional local information for the address"]
    #[doc = " @return the address struct"]
    pub fn GNUNET_HELLO_address_allocate(
        peer: *const GNUNET_PeerIdentity,
        transport_name: *const ::std::os::raw::c_char,
        address: *const ::std::os::raw::c_void,
        address_length: usize,
        local_info: GNUNET_HELLO_AddressInfo,
    ) -> *mut GNUNET_HELLO_Address;
}
extern "C" {
    #[doc = " Copy an address struct."]
    #[doc = ""]
    #[doc = " @param address address to copy"]
    #[doc = " @return a copy of the address struct"]
    pub fn GNUNET_HELLO_address_copy(
        address: *const GNUNET_HELLO_Address,
    ) -> *mut GNUNET_HELLO_Address;
}
extern "C" {
    #[doc = " Compare two addresses.  Does NOT compare the peer identity,"]
    #[doc = " that is assumed already to match!"]
    #[doc = ""]
    #[doc = " @param a1 first address"]
    #[doc = " @param a2 second address"]
    #[doc = " @return 0 if the addresses are equal, -1 if @a a1< @a a2, 1 if @a a1> @a a2."]
    pub fn GNUNET_HELLO_address_cmp(
        a1: *const GNUNET_HELLO_Address,
        a2: *const GNUNET_HELLO_Address,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the size of an address struct."]
    #[doc = ""]
    #[doc = " @param address address"]
    #[doc = " @return the size"]
    pub fn GNUNET_HELLO_address_get_size(address: *const GNUNET_HELLO_Address) -> usize;
}
extern "C" {
    #[doc = " Check if an address has a local option set"]
    #[doc = ""]
    #[doc = " @param address the address to check"]
    #[doc = " @param option the respective option to check for"]
    #[doc = " @return #GNUNET_YES or #GNUNET_NO"]
    pub fn GNUNET_HELLO_address_check_option(
        address: *const GNUNET_HELLO_Address,
        option: GNUNET_HELLO_AddressInfo,
    ) -> ::std::os::raw::c_int;
}
#[doc = " A HELLO message is used to exchange information about"]
#[doc = " transports with other peers.  This struct is always"]
#[doc = " followed by the actual network addresses which have"]
#[doc = " the format:"]
#[doc = ""]
#[doc = " 1) transport-name (0-terminated)"]
#[doc = " 2) address-length (uint16_t, network byte order; possibly"]
#[doc = "    unaligned!)"]
#[doc = " 3) address expiration (`struct GNUNET_TIME_AbsoluteNBO`); possibly"]
#[doc = "    unaligned!)"]
#[doc = " 4) address (address-length bytes; possibly unaligned!)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_HELLO_Message {
    #[doc = " Type will be #GNUNET_MESSAGE_TYPE_HELLO."]
    pub header: GNUNET_MessageHeader,
    #[doc = " Use in F2F mode: Do not gossip this HELLO message"]
    pub friend_only: u32,
    #[doc = " The public key of the peer."]
    pub publicKey: GNUNET_CRYPTO_EddsaPublicKey,
}
#[test]
fn bindgen_test_layout_GNUNET_HELLO_Message() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_HELLO_Message>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_HELLO_Message))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_HELLO_Message>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_HELLO_Message))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_HELLO_Message>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Message),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_HELLO_Message>())).friend_only as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Message),
            "::",
            stringify!(friend_only)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_HELLO_Message>())).publicKey as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_HELLO_Message),
            "::",
            stringify!(publicKey)
        )
    );
}
extern "C" {
    #[doc = " Return HELLO type"]
    #[doc = ""]
    #[doc = " @param h HELLO Message to test"]
    #[doc = " @return #GNUNET_YES for friend-only or #GNUNET_NO otherwise"]
    pub fn GNUNET_HELLO_is_friend_only(h: *const GNUNET_HELLO_Message) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the given address information into"]
    #[doc = " the given buffer using the format of HELLOs."]
    #[doc = ""]
    #[doc = " @param address address to add"]
    #[doc = " @param expiration expiration for the address"]
    #[doc = " @param target where to copy the address"]
    #[doc = " @param max maximum number of bytes to copy to @a target"]
    #[doc = " @return number of bytes copied, 0 if"]
    #[doc = "         the target buffer was not big enough."]
    pub fn GNUNET_HELLO_add_address(
        address: *const GNUNET_HELLO_Address,
        expiration: GNUNET_TIME_Absolute,
        target: *mut ::std::os::raw::c_char,
        max: usize,
    ) -> usize;
}
#[doc = " Callback function used to fill a buffer of max bytes with a list of"]
#[doc = " addresses in the format used by HELLOs.  Should use"]
#[doc = " #GNUNET_HELLO_add_address() as a helper function."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param max maximum number of bytes that can be written to @a buf"]
#[doc = " @param buf where to write the address information"]
#[doc = " @return number of bytes written or 0, #GNUNET_SYSERR to signal the"]
#[doc = "         end of the iteration."]
pub type GNUNET_HELLO_GenerateAddressListCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        max: usize,
        buf: *mut ::std::os::raw::c_void,
    ) -> isize,
>;
extern "C" {
    #[doc = " Construct a HELLO message given the public key,"]
    #[doc = " expiration time and an iterator that spews the"]
    #[doc = " transport addresses."]
    #[doc = ""]
    #[doc = " If friend only is set to #GNUNET_YES we create a FRIEND_HELLO which"]
    #[doc = " will not be gossiped to other peers."]
    #[doc = ""]
    #[doc = " @param public_key public key to include in the HELLO"]
    #[doc = " @param addrgen callback to invoke to get addresses"]
    #[doc = " @param addrgen_cls closure for @a addrgen"]
    #[doc = " @param friend_only should the returned HELLO be only visible to friends?"]
    #[doc = " @return the hello message"]
    pub fn GNUNET_HELLO_create(
        public_key: *const GNUNET_CRYPTO_EddsaPublicKey,
        addrgen: GNUNET_HELLO_GenerateAddressListCallback,
        addrgen_cls: *mut ::std::os::raw::c_void,
        friend_only: ::std::os::raw::c_int,
    ) -> *mut GNUNET_HELLO_Message;
}
extern "C" {
    #[doc = " Return the size of the given HELLO message."]
    #[doc = ""]
    #[doc = " @param hello to inspect"]
    #[doc = " @return the size, 0 if HELLO is invalid"]
    pub fn GNUNET_HELLO_size(hello: *const GNUNET_HELLO_Message) -> u16;
}
extern "C" {
    #[doc = " Construct a HELLO message by merging the"]
    #[doc = " addresses in two existing HELLOs (which"]
    #[doc = " must be for the same peer)."]
    #[doc = ""]
    #[doc = " @param h1 first HELLO message"]
    #[doc = " @param h2 the second HELLO message"]
    #[doc = " @return the combined hello message"]
    pub fn GNUNET_HELLO_merge(
        h1: *const GNUNET_HELLO_Message,
        h2: *const GNUNET_HELLO_Message,
    ) -> *mut GNUNET_HELLO_Message;
}
extern "C" {
    #[doc = " Test if two HELLO messages contain the same addresses."]
    #[doc = " If they only differ in expiration time, the lowest"]
    #[doc = " expiration time larger than 'now' where they differ"]
    #[doc = " is returned."]
    #[doc = ""]
    #[doc = " @param h1 first HELLO message"]
    #[doc = " @param h2 the second HELLO message"]
    #[doc = " @param now time to use for deciding which addresses have"]
    #[doc = "            expired and should not be considered at all"]
    #[doc = " @return absolute time forever if the two HELLOs are"]
    #[doc = "         totally identical; smallest timestamp >= now if"]
    #[doc = "         they only differ in timestamps;"]
    #[doc = "         zero if the some addresses with expirations >= now"]
    #[doc = "         do not match at all"]
    pub fn GNUNET_HELLO_equals(
        h1: *const GNUNET_HELLO_Message,
        h2: *const GNUNET_HELLO_Message,
        now: GNUNET_TIME_Absolute,
    ) -> GNUNET_TIME_Absolute;
}
#[doc = " Iterator callback to go over all addresses."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param address the address"]
#[doc = " @param expiration expiration time"]
#[doc = " @return #GNUNET_OK to keep the address,"]
#[doc = "         #GNUNET_NO to delete it from the HELLO"]
#[doc = "         #GNUNET_SYSERR to stop iterating (but keep current address)"]
pub type GNUNET_HELLO_AddressIterator = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        address: *const GNUNET_HELLO_Address,
        expiration: GNUNET_TIME_Absolute,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " When does the last address in the given HELLO expire?"]
    #[doc = ""]
    #[doc = " @param msg HELLO to inspect"]
    #[doc = " @return time the last address expires, 0 if there are no addresses in the HELLO"]
    pub fn GNUNET_HELLO_get_last_expiration(
        msg: *const GNUNET_HELLO_Message,
    ) -> GNUNET_TIME_Absolute;
}
extern "C" {
    #[doc = " Iterate over all of the addresses in the HELLO."]
    #[doc = ""]
    #[doc = " @param msg HELLO to iterate over; client does not need to"]
    #[doc = "        have verified that msg is well-formed (beyond starting"]
    #[doc = "        with a GNUNET_MessageHeader of the right type)."]
    #[doc = " @param return_modified if a modified copy should be returned,"]
    #[doc = "         otherwise NULL will be returned"]
    #[doc = " @param it iterator to call on each address"]
    #[doc = " @param it_cls closure for @a it"]
    #[doc = " @return the modified HELLO or NULL"]
    pub fn GNUNET_HELLO_iterate_addresses(
        msg: *const GNUNET_HELLO_Message,
        return_modified: ::std::os::raw::c_int,
        it: GNUNET_HELLO_AddressIterator,
        it_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_HELLO_Message;
}
extern "C" {
    #[doc = " Iterate over addresses in @a new_hello that are NOT already present"]
    #[doc = " in @a old_hello. Note that if the address is present in @a old_hello"]
    #[doc = " but the expiration time in @a new_hello is more recent, the"]
    #[doc = " iterator is also called."]
    #[doc = ""]
    #[doc = " @param new_hello a HELLO message"]
    #[doc = " @param old_hello a HELLO message"]
    #[doc = " @param expiration_limit ignore addresses in old_hello"]
    #[doc = "        that expired before the given time stamp"]
    #[doc = " @param it iterator to call on each address"]
    #[doc = " @param it_cls closure for @a it"]
    pub fn GNUNET_HELLO_iterate_new_addresses(
        new_hello: *const GNUNET_HELLO_Message,
        old_hello: *const GNUNET_HELLO_Message,
        expiration_limit: GNUNET_TIME_Absolute,
        it: GNUNET_HELLO_AddressIterator,
        it_cls: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the peer identity from a HELLO message."]
    #[doc = ""]
    #[doc = " @param hello the hello message"]
    #[doc = " @param peer where to store the peer's identity"]
    #[doc = " @return #GNUNET_SYSERR if the HELLO was malformed"]
    pub fn GNUNET_HELLO_get_id(
        hello: *const GNUNET_HELLO_Message,
        peer: *mut GNUNET_PeerIdentity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the header from a HELLO message, used so other code"]
    #[doc = " can correctly send HELLO messages."]
    #[doc = ""]
    #[doc = " @param hello the hello message"]
    #[doc = ""]
    #[doc = " @return header or NULL if the HELLO was malformed"]
    pub fn GNUNET_HELLO_get_header(hello: *mut GNUNET_HELLO_Message) -> *mut GNUNET_MessageHeader;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_PluginFunctions {
    _unused: [u8; 0],
}
#[doc = " Helper function to load/access transport plugins."]
#[doc = " FIXME: pass closure!"]
#[doc = ""]
#[doc = " @param name name of the transport plugin to load"]
#[doc = " @return NULL if a plugin with name @a name is not known/loadable"]
pub type GNUNET_HELLO_TransportPluginsFind = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GNUNET_TRANSPORT_PluginFunctions,
>;
extern "C" {
    #[doc = " Compose a hello URI string from a hello message."]
    #[doc = ""]
    #[doc = " @param hello Hello message"]
    #[doc = " @param plugins_find Function to find transport plugins by name"]
    #[doc = " @return Hello URI string"]
    pub fn GNUNET_HELLO_compose_uri(
        hello: *const GNUNET_HELLO_Message,
        plugins_find: GNUNET_HELLO_TransportPluginsFind,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse a hello URI string to a hello message."]
    #[doc = ""]
    #[doc = " @param uri URI string to parse"]
    #[doc = " @param pubkey Pointer to struct where public key is parsed"]
    #[doc = " @param hello Pointer to struct where hello message is parsed"]
    #[doc = " @param plugins_find Function to find transport plugins by name"]
    #[doc = " @return #GNUNET_OK on success, #GNUNET_SYSERR if the URI was invalid, #GNUNET_NO on other errors"]
    pub fn GNUNET_HELLO_parse_uri(
        uri: *const ::std::os::raw::c_char,
        pubkey: *mut GNUNET_CRYPTO_EddsaPublicKey,
        hello: *mut *mut GNUNET_HELLO_Message,
        plugins_find: GNUNET_HELLO_TransportPluginsFind,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Category of last resort."]
pub const GNUNET_NetworkType_GNUNET_NT_UNSPECIFIED: GNUNET_NetworkType = 0;
#[doc = " Loopback (same host)."]
pub const GNUNET_NetworkType_GNUNET_NT_LOOPBACK: GNUNET_NetworkType = 1;
#[doc = " Local area network."]
pub const GNUNET_NetworkType_GNUNET_NT_LAN: GNUNET_NetworkType = 2;
#[doc = " Wide area network (i.e. Internet)"]
pub const GNUNET_NetworkType_GNUNET_NT_WAN: GNUNET_NetworkType = 3;
#[doc = " Wireless LAN (i.e. 802.11abgn)"]
pub const GNUNET_NetworkType_GNUNET_NT_WLAN: GNUNET_NetworkType = 4;
#[doc = " Bluetooth LAN"]
pub const GNUNET_NetworkType_GNUNET_NT_BT: GNUNET_NetworkType = 5;
#[doc = " Types of networks (with separate quotas) we support."]
pub type GNUNET_NetworkType = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Convert a `enum GNUNET_NetworkType` to a string"]
    #[doc = ""]
    #[doc = " @param net the network type"]
    #[doc = " @return a string or NULL if invalid"]
    pub fn GNUNET_NT_to_string(net: GNUNET_NetworkType) -> *const ::std::os::raw::c_char;
}
#[doc = " Handle for the LAN Characterization library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_NT_InterfaceScanner {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns where the address is located: loopback, LAN or WANT."]
    #[doc = ""]
    #[doc = " @param is handle from #GNUNET_ATS_interface_scanner_init()"]
    #[doc = " @param addr address"]
    #[doc = " @param addrlen address length"]
    #[doc = " @return type of the network the address belongs to"]
    pub fn GNUNET_NT_scanner_get_type(
        is: *mut GNUNET_NT_InterfaceScanner,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> GNUNET_NetworkType;
}
extern "C" {
    #[doc = " Initialize the address characterization client handle."]
    #[doc = ""]
    #[doc = " @return scanner handle, NULL on error"]
    pub fn GNUNET_NT_scanner_init() -> *mut GNUNET_NT_InterfaceScanner;
}
extern "C" {
    #[doc = " Terminate interface scanner."]
    #[doc = ""]
    #[doc = " @param is scanner we are done with"]
    pub fn GNUNET_NT_scanner_done(is: *mut GNUNET_NT_InterfaceScanner);
}
extern "C" {
    #[doc = " Build address record by signing raw information with private key."]
    #[doc = ""]
    #[doc = " @param address text address to sign"]
    #[doc = " @param nt network type of @a address"]
    #[doc = " @param mono_time when was @a address valid"]
    #[doc = " @param private_key signing key to use"]
    #[doc = " @param result[out] where to write address record (allocated)"]
    #[doc = " @param result_size[out] set to size of @a result"]
    pub fn GNUNET_HELLO_sign_address(
        address: *const ::std::os::raw::c_char,
        nt: GNUNET_NetworkType,
        mono_time: GNUNET_TIME_Absolute,
        private_key: *const GNUNET_CRYPTO_EddsaPrivateKey,
        result: *mut *mut ::std::os::raw::c_void,
        result_size: *mut usize,
    );
}
extern "C" {
    #[doc = " Check signature and extract address record."]
    #[doc = ""]
    #[doc = " @param raw raw signed address"]
    #[doc = " @param raw_size size of @a raw"]
    #[doc = " @param pid public key to use for signature verification"]
    #[doc = " @param nt[out] set to network type"]
    #[doc = " @param mono_time[out] when was the address generated"]
    #[doc = " @return NULL on error, otherwise the address"]
    pub fn GNUNET_HELLO_extract_address(
        raw: *const ::std::os::raw::c_void,
        raw_size: usize,
        pid: *const GNUNET_PeerIdentity,
        nt: *mut GNUNET_NetworkType,
        mono_time: *mut GNUNET_TIME_Absolute,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given an address as a string, extract the prefix that identifies"]
    #[doc = " the communicator offering transmissions to that address."]
    #[doc = ""]
    #[doc = " @param address a peer's address"]
    #[doc = " @return NULL if the address is mal-formed, otherwise the prefix"]
    pub fn GNUNET_HELLO_address_to_prefix(
        address: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " ATS performance characteristics for an address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_Properties {
    #[doc = " Delay.  Time between when the time packet is sent and the packet"]
    #[doc = " arrives.  FOREVER if we did not measure yet."]
    pub delay: GNUNET_TIME_Relative,
    #[doc = " Actual traffic on this connection from this peer to the other peer."]
    #[doc = " Includes transport overhead."]
    #[doc = ""]
    #[doc = " Unit: [bytes/second]"]
    pub utilization_out: u32,
    #[doc = " Actual traffic on this connection from the other peer to this peer."]
    #[doc = " Includes transport overhead."]
    #[doc = ""]
    #[doc = " Unit: [bytes/second]"]
    pub utilization_in: u32,
    #[doc = " Distance on network layer (required for distance-vector routing)"]
    #[doc = " in hops.  Zero for direct connections (i.e. plain TCP/UDP)."]
    pub distance: ::std::os::raw::c_uint,
    #[doc = " Which network scope does the respective address belong to?"]
    #[doc = " This property does not change."]
    pub scope: GNUNET_NetworkType,
}
#[test]
fn bindgen_test_layout_GNUNET_ATS_Properties() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_ATS_Properties>(),
        24usize,
        concat!("Size of: ", stringify!(GNUNET_ATS_Properties))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_ATS_Properties>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_ATS_Properties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_ATS_Properties>())).delay as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_Properties),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_ATS_Properties>())).utilization_out as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_Properties),
            "::",
            stringify!(utilization_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_ATS_Properties>())).utilization_in as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_Properties),
            "::",
            stringify!(utilization_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_ATS_Properties>())).distance as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_Properties),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_ATS_Properties>())).scope as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_Properties),
            "::",
            stringify!(scope)
        )
    );
}
#[doc = " ATS performance characteristics for an address in"]
#[doc = " network byte order (for IPC)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_PropertiesNBO {
    #[doc = " Actual traffic on this connection from this peer to the other peer."]
    #[doc = " Includes transport overhead."]
    #[doc = ""]
    #[doc = " Unit: [bytes/second]"]
    pub utilization_out: u32,
    #[doc = " Actual traffic on this connection from the other peer to this peer."]
    #[doc = " Includes transport overhead."]
    #[doc = ""]
    #[doc = " Unit: [bytes/second]"]
    pub utilization_in: u32,
    #[doc = " Which network scope does the respective address belong to?"]
    #[doc = " This property does not change."]
    pub scope: u32,
    #[doc = " Distance on network layer (required for distance-vector routing)"]
    #[doc = " in hops.  Zero for direct connections (i.e. plain TCP/UDP)."]
    pub distance: u32,
    #[doc = " Delay.  Time between when the time packet is sent and the packet"]
    #[doc = " arrives.  FOREVER if we did not measure yet."]
    pub delay: GNUNET_TIME_RelativeNBO,
}
#[test]
fn bindgen_test_layout_GNUNET_ATS_PropertiesNBO() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_ATS_PropertiesNBO>(),
        24usize,
        concat!("Size of: ", stringify!(GNUNET_ATS_PropertiesNBO))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_ATS_PropertiesNBO>(),
        1usize,
        concat!("Alignment of ", stringify!(GNUNET_ATS_PropertiesNBO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_ATS_PropertiesNBO>())).utilization_out as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_PropertiesNBO),
            "::",
            stringify!(utilization_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_ATS_PropertiesNBO>())).utilization_in as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_PropertiesNBO),
            "::",
            stringify!(utilization_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_ATS_PropertiesNBO>())).scope as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_PropertiesNBO),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_ATS_PropertiesNBO>())).distance as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_PropertiesNBO),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_ATS_PropertiesNBO>())).delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_ATS_PropertiesNBO),
            "::",
            stringify!(delay)
        )
    );
}
extern "C" {
    #[doc = " Convert ATS properties from host to network byte order."]
    #[doc = ""]
    #[doc = " @param nbo[OUT] value written"]
    #[doc = " @param hbo value read"]
    pub fn GNUNET_ATS_properties_hton(
        nbo: *mut GNUNET_ATS_PropertiesNBO,
        hbo: *const GNUNET_ATS_Properties,
    );
}
extern "C" {
    #[doc = " Convert ATS properties from network to host byte order."]
    #[doc = ""]
    #[doc = " @param hbo[OUT] value written"]
    #[doc = " @param nbo value read"]
    pub fn GNUNET_ATS_properties_ntoh(
        hbo: *mut GNUNET_ATS_Properties,
        nbo: *const GNUNET_ATS_PropertiesNBO,
    );
}
#[doc = " Handle to the ATS subsystem for making suggestions about"]
#[doc = " connections the peer would like to have."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_ConnectivityHandle {
    _unused: [u8; 0],
}
#[doc = " Handle for address suggestion requests."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_ConnectivitySuggestHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Initialize the ATS connectivity suggestion client handle."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @return ats connectivity handle, NULL on error"]
    pub fn GNUNET_ATS_connectivity_init(
        cfg: *const GNUNET_CONFIGURATION_Handle,
    ) -> *mut GNUNET_ATS_ConnectivityHandle;
}
extern "C" {
    #[doc = " Shutdown ATS connectivity suggestion client."]
    #[doc = ""]
    #[doc = " @param ch handle to destroy"]
    pub fn GNUNET_ATS_connectivity_done(ch: *mut GNUNET_ATS_ConnectivityHandle);
}
extern "C" {
    #[doc = " We would like to establish a new connection with a peer.  ATS"]
    #[doc = " should suggest a good address to begin with."]
    #[doc = ""]
    #[doc = " @param ch handle"]
    #[doc = " @param peer identity of the peer we need an address for"]
    #[doc = " @param strength how urgent is the need for such a suggestion"]
    #[doc = " @return suggestion handle, NULL if request is already pending"]
    pub fn GNUNET_ATS_connectivity_suggest(
        ch: *mut GNUNET_ATS_ConnectivityHandle,
        peer: *const GNUNET_PeerIdentity,
        strength: u32,
    ) -> *mut GNUNET_ATS_ConnectivitySuggestHandle;
}
extern "C" {
    #[doc = " We no longer care about being connected to a peer."]
    #[doc = ""]
    #[doc = " @param sh handle"]
    pub fn GNUNET_ATS_connectivity_suggest_cancel(sh: *mut GNUNET_ATS_ConnectivitySuggestHandle);
}
#[doc = " Handle to the ATS subsystem for bandwidth/transport scheduling information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_SchedulingHandle {
    _unused: [u8; 0],
}
#[doc = " Opaque session handle, defined by plugins.  Contents not known to ATS."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_Session {
    _unused: [u8; 0],
}
#[doc = " Signature of a function called by ATS with the current bandwidth"]
#[doc = " and address preferences as determined by ATS.  If our connection"]
#[doc = " to ATS dies and thus all suggestions become invalid, this function"]
#[doc = " is called ONCE with all arguments (except @a cls) being NULL/0."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param peer for which we suggest an address, NULL if ATS connection died"]
#[doc = " @param address suggested address (including peer identity of the peer),"]
#[doc = "             may be NULL to signal disconnect from peer"]
#[doc = " @param session session to use, NULL to establish a new outgoing session"]
#[doc = " @param bandwidth_out assigned outbound bandwidth for the connection,"]
#[doc = "        0 to signal disconnect"]
#[doc = " @param bandwidth_in assigned inbound bandwidth for the connection,"]
#[doc = "        0 to signal disconnect"]
pub type GNUNET_ATS_AddressSuggestionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        address: *const GNUNET_HELLO_Address,
        session: *mut GNUNET_ATS_Session,
        bandwidth_out: GNUNET_BANDWIDTH_Value32NBO,
        bandwidth_in: GNUNET_BANDWIDTH_Value32NBO,
    ),
>;
extern "C" {
    #[doc = " Initialize the ATS scheduling subsystem."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param suggest_cb notification to call whenever the suggestation changed"]
    #[doc = " @param suggest_cb_cls closure for @a suggest_cb"]
    #[doc = " @return ats context"]
    pub fn GNUNET_ATS_scheduling_init(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        suggest_cb: GNUNET_ATS_AddressSuggestionCallback,
        suggest_cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_ATS_SchedulingHandle;
}
extern "C" {
    #[doc = " Client is done with ATS scheduling, release resources."]
    #[doc = ""]
    #[doc = " @param sh handle to release"]
    pub fn GNUNET_ATS_scheduling_done(sh: *mut GNUNET_ATS_SchedulingHandle);
}
#[doc = " Handle used within ATS to track an address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_AddressRecord {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " We have a new address ATS should know. Addresses have to be added with this"]
    #[doc = " function before they can be: updated, set in use and destroyed"]
    #[doc = ""]
    #[doc = " @param sh handle"]
    #[doc = " @param address the address"]
    #[doc = " @param session session handle (if available, i.e. for incoming connections)"]
    #[doc = " @param prop performance data for the address"]
    #[doc = " @return handle to the address representation inside ATS, NULL"]
    #[doc = "         on error (i.e. ATS knows this exact address already, or"]
    #[doc = "         address is invalid)"]
    pub fn GNUNET_ATS_address_add(
        sh: *mut GNUNET_ATS_SchedulingHandle,
        address: *const GNUNET_HELLO_Address,
        session: *mut GNUNET_ATS_Session,
        prop: *const GNUNET_ATS_Properties,
    ) -> *mut GNUNET_ATS_AddressRecord;
}
extern "C" {
    #[doc = " An address was used to initiate a session."]
    #[doc = ""]
    #[doc = " @param ar address record to update information for"]
    #[doc = " @param session session handle"]
    pub fn GNUNET_ATS_address_add_session(
        ar: *mut GNUNET_ATS_AddressRecord,
        session: *mut GNUNET_ATS_Session,
    );
}
extern "C" {
    #[doc = " A @a session was destroyed, disassociate it from the given address"]
    #[doc = " record.  If this was an incoming address, destroys the address as"]
    #[doc = " well."]
    #[doc = ""]
    #[doc = " @param ar address record to update information for"]
    #[doc = " @param session session handle"]
    #[doc = " @return #GNUNET_YES if the @a ar was destroyed because"]
    #[doc = "                     it was an incoming address,"]
    #[doc = "         #GNUNET_NO if the @ar was kept because we can"]
    #[doc = "                    use it still to establish a new session"]
    pub fn GNUNET_ATS_address_del_session(
        ar: *mut GNUNET_ATS_AddressRecord,
        session: *mut GNUNET_ATS_Session,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " We have updated performance statistics for a given address.  Note"]
    #[doc = " that this function can be called for addresses that are currently"]
    #[doc = " in use as well as addresses that are valid but not actively in use."]
    #[doc = " Furthermore, the peer may not even be connected to us right now (@a"]
    #[doc = " session value of NULL used to signal disconnect, or somehow we"]
    #[doc = " otherwise got updated on @a ats information).  Based on the"]
    #[doc = " information provided, ATS may update bandwidth assignments and"]
    #[doc = " suggest to switch addresses."]
    #[doc = ""]
    #[doc = " @param ar address record to update information for"]
    #[doc = " @param prop performance data for the address"]
    pub fn GNUNET_ATS_address_update(
        ar: *mut GNUNET_ATS_AddressRecord,
        prop: *const GNUNET_ATS_Properties,
    );
}
extern "C" {
    #[doc = " An address got destroyed, stop using it as a valid address."]
    #[doc = ""]
    #[doc = " @param ar address record to destroy, it's validation has"]
    #[doc = "           expired and ATS may no longer use it"]
    pub fn GNUNET_ATS_address_destroy(ar: *mut GNUNET_ATS_AddressRecord);
}
#[doc = " ATS Handle to obtain and/or modify performance information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_PerformanceHandle {
    _unused: [u8; 0],
}
#[doc = " Signature of a function that is called with QoS information about an address."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param address the address, NULL if ATS service was disconnected or"]
#[doc = "        when the iteration is completed in the case of"]
#[doc = "        #GNUNET_ATS_performance_list_addresses()"]
#[doc = " @param address_active #GNUNET_YES if this address is actively used"]
#[doc = "        to maintain a connection to a peer;"]
#[doc = "        #GNUNET_NO if the address is not actively used;"]
#[doc = "        #GNUNET_SYSERR if this address is no longer available for ATS"]
#[doc = " @param bandwidth_out assigned outbound bandwidth for the connection"]
#[doc = " @param bandwidth_in assigned inbound bandwidth for the connection"]
#[doc = " @param prop performance data for the address"]
pub type GNUNET_ATS_AddressInformationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        address: *const GNUNET_HELLO_Address,
        address_active: ::std::os::raw::c_int,
        bandwidth_out: GNUNET_BANDWIDTH_Value32NBO,
        bandwidth_in: GNUNET_BANDWIDTH_Value32NBO,
        prop: *const GNUNET_ATS_Properties,
    ),
>;
#[doc = " Handle for an address listing operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_AddressListHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get handle to access performance API of the ATS subsystem."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param addr_info_cb callback called when performance characteristics for"]
    #[doc = "      an address change"]
    #[doc = " @param addr_info_cb_cls closure for @a addr_info_cb"]
    #[doc = " @return ats performance context"]
    pub fn GNUNET_ATS_performance_init(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        addr_info_cb: GNUNET_ATS_AddressInformationCallback,
        addr_info_cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_ATS_PerformanceHandle;
}
extern "C" {
    #[doc = " Get information about addresses known to the ATS subsystem."]
    #[doc = ""]
    #[doc = " @param ph the performance handle to use"]
    #[doc = " @param peer peer idm can be NULL for all peers"]
    #[doc = " @param all #GNUNET_YES to get information about all addresses or #GNUNET_NO to"]
    #[doc = "        get only address currently used"]
    #[doc = " @param infocb callback to call with the addresses,"]
    #[doc = "        will callback with address == NULL when done"]
    #[doc = " @param infocb_cls closure for @a infocb"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_ATS_performance_list_addresses(
        ph: *mut GNUNET_ATS_PerformanceHandle,
        peer: *const GNUNET_PeerIdentity,
        all: ::std::os::raw::c_int,
        infocb: GNUNET_ATS_AddressInformationCallback,
        infocb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_ATS_AddressListHandle;
}
extern "C" {
    #[doc = " Cancel a pending address listing operation"]
    #[doc = ""]
    #[doc = " @param alh the `struct GNUNET_ATS_AddressListHandle` handle to cancel"]
    pub fn GNUNET_ATS_performance_list_addresses_cancel(alh: *mut GNUNET_ATS_AddressListHandle);
}
extern "C" {
    #[doc = " Client is done using the ATS performance subsystem, release resources."]
    #[doc = ""]
    #[doc = " @param ph handle"]
    pub fn GNUNET_ATS_performance_done(ph: *mut GNUNET_ATS_PerformanceHandle);
}
#[doc = " Function called with reservation result."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param peer identifies the peer"]
#[doc = " @param amount set to the amount that was actually reserved or unreserved;"]
#[doc = "               either the full requested amount or zero (no partial reservations)"]
#[doc = " @param res_delay if the reservation could not be satisfied (amount was 0), how"]
#[doc = "        long should the client wait until re-trying?"]
pub type GNUNET_ATS_ReservationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        amount: i32,
        res_delay: GNUNET_TIME_Relative,
    ),
>;
#[doc = " Context that can be used to cancel a peer information request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_ATS_ReservationContext {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Reserve inbound bandwidth from the given peer.  ATS will look at"]
    #[doc = " the current amount of traffic we receive from the peer and ensure"]
    #[doc = " that the peer could add 'amount' of data to its stream."]
    #[doc = ""]
    #[doc = " @param ph performance handle"]
    #[doc = " @param peer identifies the peer"]
    #[doc = " @param amount reserve N bytes for receiving, negative"]
    #[doc = "                amounts can be used to undo a (recent) reservation;"]
    #[doc = " @param rcb function to call with the resulting reservation information"]
    #[doc = " @param rcb_cls closure for @a rcb"]
    #[doc = " @return NULL on error"]
    #[doc = " @deprecated will be replaced soon"]
    pub fn GNUNET_ATS_reserve_bandwidth(
        ph: *mut GNUNET_ATS_PerformanceHandle,
        peer: *const GNUNET_PeerIdentity,
        amount: i32,
        rcb: GNUNET_ATS_ReservationCallback,
        rcb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_ATS_ReservationContext;
}
extern "C" {
    #[doc = " Cancel request for reserving bandwidth."]
    #[doc = ""]
    #[doc = " @param rc context returned by the original GNUNET_ATS_reserve_bandwidth call"]
    pub fn GNUNET_ATS_reserve_bandwidth_cancel(rc: *mut GNUNET_ATS_ReservationContext);
}
#[doc = " Change the peer's bandwidth value (value per byte of bandwidth in"]
#[doc = " the goal function) to the given amount.  The argument is followed"]
#[doc = " by a double value giving the desired value (can be negative)."]
#[doc = " Preference changes are forgotten if peers disconnect."]
pub const GNUNET_ATS_PreferenceKind_GNUNET_ATS_PREFERENCE_BANDWIDTH: GNUNET_ATS_PreferenceKind = 0;
#[doc = " Change the peer's latency value to the given amount.  The"]
#[doc = " argument is followed by a double value giving the desired value"]
#[doc = " (can be negative).  The absolute score in the goal function is"]
#[doc = " the inverse of the latency in microseconds (minimum: 1"]
#[doc = " microsecond) multiplied by the latency preferences."]
pub const GNUNET_ATS_PreferenceKind_GNUNET_ATS_PREFERENCE_LATENCY: GNUNET_ATS_PreferenceKind = 1;
#[doc = " End of preference list."]
pub const GNUNET_ATS_PreferenceKind_GNUNET_ATS_PREFERENCE_END: GNUNET_ATS_PreferenceKind = 2;
#[doc = " Enum defining all known preference categories."]
pub type GNUNET_ATS_PreferenceKind = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Convert a GNUNET_ATS_PreferenceType to a string"]
    #[doc = ""]
    #[doc = " @param type the preference type"]
    #[doc = " @return a string or NULL if invalid"]
    pub fn GNUNET_ATS_print_preference_type(
        type_: GNUNET_ATS_PreferenceKind,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Change preferences for the given peer. Preference changes are forgotten if peers"]
    #[doc = " disconnect."]
    #[doc = ""]
    #[doc = " @param ph performance handle @param peer identifies the peer"]
    #[doc = " @param ... #GNUNET_ATS_PREFERENCE_END-terminated specification of the"]
    #[doc = " desired changes"]
    pub fn GNUNET_ATS_performance_change_preference(
        ph: *mut GNUNET_ATS_PerformanceHandle,
        peer: *const GNUNET_PeerIdentity,
        ...
    );
}
extern "C" {
    #[doc = " Application feedback on how good preference requirements are fulfilled"]
    #[doc = " for the preferences included in the given time scope [now - scope .. now]"]
    #[doc = ""]
    #[doc = " An application notifies ATS if (and only if) it has feedback information"]
    #[doc = " for specific properties. This values are valid until the feedback scores are"]
    #[doc = " updated by the application."]
    #[doc = ""]
    #[doc = " If the application has no feedback for this preference kind the application"]
    #[doc = " will not explicitly call for this property and will not include it in this"]
    #[doc = " function call."]
    #[doc = ""]
    #[doc = " @param ph performance handle"]
    #[doc = " @param scope the time interval this valid for: [now - scope .. now]"]
    #[doc = " @param peer identifies the peer"]
    #[doc = " @param ... #GNUNET_ATS_PREFERENCE_END-terminated specification of the desired changes"]
    pub fn GNUNET_ATS_performance_give_feedback(
        ph: *mut GNUNET_ATS_PerformanceHandle,
        peer: *const GNUNET_PeerIdentity,
        scope: GNUNET_TIME_Relative,
        ...
    );
}
#[doc = " Handle for a #GNUNET_TRANSPORT_offer_hello operation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_OfferHelloHandle {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Offer the transport service the HELLO of another peer.  Note that"]
    #[doc = " the transport service may just ignore this message if the HELLO is"]
    #[doc = " malformed or useless due to our local configuration."]
    #[doc = ""]
    #[doc = " @param cfg configuration"]
    #[doc = " @param hello the hello message"]
    #[doc = " @param cont continuation to call when HELLO has been sent,"]
    #[doc = "      tc reason #GNUNET_SCHEDULER_REASON_TIMEOUT for fail"]
    #[doc = "      tc reasong #GNUNET_SCHEDULER_REASON_READ_READY for success"]
    #[doc = " @param cont_cls closure for @a cont"]
    #[doc = " @return a `struct GNUNET_TRANSPORT_OfferHelloHandle` handle or NULL on"]
    #[doc = " failure, in case of failure @a cont will not be called"]
    #[doc = ""]
    pub fn GNUNET_TRANSPORT_offer_hello(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        hello: *const GNUNET_MessageHeader,
        cont: GNUNET_SCHEDULER_TaskCallback,
        cont_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_TRANSPORT_OfferHelloHandle;
}
extern "C" {
    #[doc = " Cancel the request to transport to offer the HELLO message"]
    #[doc = ""]
    #[doc = " @param ohh the `struct GNUNET_TRANSPORT_OfferHelloHandle` to cancel"]
    pub fn GNUNET_TRANSPORT_offer_hello_cancel(ohh: *mut GNUNET_TRANSPORT_OfferHelloHandle);
}
#[doc = " Handle to cancel a pending address lookup."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_AddressToStringContext {
    _unused: [u8; 0],
}
#[doc = " Function to call with a textual representation of an address.  This"]
#[doc = " function will be called several times with different possible"]
#[doc = " textual representations, and a last time with @a address being NULL"]
#[doc = " to signal the end of the iteration.  Note that @a address NULL"]
#[doc = " always is the last call, regardless of the value in @a res."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param address NULL on end of iteration,"]
#[doc = "        otherwise 0-terminated printable UTF-8 string,"]
#[doc = "        in particular an empty string if @a res is #GNUNET_NO"]
#[doc = " @param res result of the address to string conversion:"]
#[doc = "        if #GNUNET_OK: conversion successful"]
#[doc = "        if #GNUNET_NO: address was invalid (or not supported)"]
#[doc = "        if #GNUNET_SYSERR: communication error (IPC error)"]
pub type GNUNET_TRANSPORT_AddressToStringCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        address: *const ::std::os::raw::c_char,
        res: ::std::os::raw::c_int,
    ),
>;
extern "C" {
    #[doc = " Convert a binary address into a human readable address."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param address address to convert (binary format)"]
    #[doc = " @param numeric should (IP) addresses be displayed in numeric form"]
    #[doc = "                (otherwise do reverse DNS lookup)"]
    #[doc = " @param timeout how long is the lookup allowed to take at most"]
    #[doc = " @param aluc function to call with the results"]
    #[doc = " @param aluc_cls closure for @a aluc"]
    #[doc = " @return handle to cancel the operation, NULL on error"]
    pub fn GNUNET_TRANSPORT_address_to_string(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        address: *const GNUNET_HELLO_Address,
        numeric: ::std::os::raw::c_int,
        timeout: GNUNET_TIME_Relative,
        aluc: GNUNET_TRANSPORT_AddressToStringCallback,
        aluc_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_TRANSPORT_AddressToStringContext;
}
extern "C" {
    #[doc = " Cancel request for address conversion."]
    #[doc = ""]
    #[doc = " @param alc the context handle"]
    pub fn GNUNET_TRANSPORT_address_to_string_cancel(
        alc: *mut GNUNET_TRANSPORT_AddressToStringContext,
    );
}
#[doc = " Fresh peer or completely disconnected"]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_NOT_CONNECTED: GNUNET_TRANSPORT_PeerState =
    0;
#[doc = " Asked to initiate connection, trying to get address from ATS"]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_INIT_ATS: GNUNET_TRANSPORT_PeerState = 1;
#[doc = " Sent SYN message to other peer, waiting for SYN_ACK"]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_SYN_SENT: GNUNET_TRANSPORT_PeerState = 2;
#[doc = " Received a SYN, asking ATS about address suggestions."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_SYN_RECV_ATS: GNUNET_TRANSPORT_PeerState =
    3;
#[doc = " SYN request from other peer was SYN_ACK'ed, waiting for ACK."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_SYN_RECV_ACK: GNUNET_TRANSPORT_PeerState =
    4;
#[doc = " Got our SYN_ACK/ACK, connection is up."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_CONNECTED: GNUNET_TRANSPORT_PeerState = 5;
#[doc = " Connection got into trouble, rest of the system still believes"]
#[doc = " it to be up, but we're getting a new address from ATS."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_RECONNECT_ATS: GNUNET_TRANSPORT_PeerState =
    6;
#[doc = " Sent SYN over new address (either by ATS telling us to switch"]
#[doc = " addresses or from RECONNECT_ATS); if this fails, we need to tell"]
#[doc = " the rest of the system about a disconnect."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_RECONNECT_SENT:
    GNUNET_TRANSPORT_PeerState = 7;
#[doc = " We have some primary connection, but ATS suggested we switch"]
#[doc = " to some alternative; we now sent a SYN message for the"]
#[doc = " alternative session to the other peer and waiting for a"]
#[doc = " SYN_ACK to make this our primary connection."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_SWITCH_SYN_SENT:
    GNUNET_TRANSPORT_PeerState = 8;
#[doc = " Disconnect in progress (we're sending the DISCONNECT message to the"]
#[doc = " other peer; after that is finished, the state will be cleaned up)."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_DISCONNECT: GNUNET_TRANSPORT_PeerState = 9;
#[doc = " We're finished with the disconnect; and are cleaning up the state"]
#[doc = " now!  We put the struct into this state when we are really in the"]
#[doc = " task that calls 'free' on it and are about to remove the record"]
#[doc = " from the map.  We should never find a 'struct NeighbourMapEntry'"]
#[doc = " in this state in the map.  Accessing a 'struct NeighbourMapEntry'"]
#[doc = " in this state virtually always means using memory that has been"]
#[doc = " freed (the exception being the cleanup code in #free_neighbour())."]
pub const GNUNET_TRANSPORT_PeerState_GNUNET_TRANSPORT_PS_DISCONNECT_FINISHED:
    GNUNET_TRANSPORT_PeerState = 10;
#[doc = " Possible state of a neighbour.  Initially, we are"]
#[doc = " #GNUNET_TRANSPORT_PS_NOT_CONNECTED."]
#[doc = ""]
#[doc = " Then, there are two main paths. If we receive a SYN message, we give"]
#[doc = " the inbound address to ATS. After the check we ask ATS for a suggestion"]
#[doc = " (#GNUNET_TRANSPORT_PS_CONNECT_RECV_ATS). If ATS makes a suggestion, we"]
#[doc = " send our SYN_ACK and go to #GNUNET_TRANSPORT_PS_CONNECT_RECV_ACK."]
#[doc = " If we receive a ACK, we go to #GNUNET_TRANSPORT_PS_CONNECTED"]
#[doc = " (and notify everyone about the new connection). If the operation times out,"]
#[doc = " we go to #GNUNET_TRANSPORT_PS_DISCONNECT."]
#[doc = ""]
#[doc = " The other case is where we transmit a SYN message first.  We"]
#[doc = " start with #GNUNET_TRANSPORT_PS_INIT_ATS.  If we get an address, we send"]
#[doc = " the SYN message and go to state #GNUNET_TRANSPORT_PS_CONNECT_SENT."]
#[doc = " Once we receive a SYN_ACK, we go to #GNUNET_TRANSPORT_PS_CONNECTED"]
#[doc = " (and notify everyone about the new connection and send"]
#[doc = " back a ACK).  If the operation times out, we go to"]
#[doc = " #GNUNET_TRANSPORT_PS_DISCONNECT."]
#[doc = ""]
#[doc = " If the session is in trouble (i.e. transport-level disconnect or"]
#[doc = " timeout), we go to #GNUNET_TRANSPORT_PS_RECONNECT_ATS where we ask ATS for a"]
#[doc = " new address (we don't notify anyone about the disconnect yet).  Once we have"]
#[doc = " a new address, we enter #GNUNET_TRANSPORT_PS_RECONNECT_SENT and send a SYN"]
#[doc = " message.  If we receive a SYN_ACK, we go to #GNUNET_TRANSPORT_PS_CONNECTED"]
#[doc = " and nobody noticed that we had trouble; we also send a ACK at this time just"]
#[doc = " in case.  If the operation times out, we go to"]
#[doc = " #GNUNET_TRANSPORT_PS_DISCONNECT (and notify everyone about the lost"]
#[doc = " connection)."]
#[doc = ""]
#[doc = " If ATS decides to switch addresses while we have a normal"]
#[doc = " connection, we go to #GNUNET_TRANSPORT_PS_CONNECTED_SWITCHING_SYN_SENT"]
#[doc = " and send a SESSION_CONNECT.  If we get a ACK back, we switch the"]
#[doc = " primary connection to the suggested alternative from ATS, go back"]
#[doc = " to #GNUNET_TRANSPORT_PS_CONNECTED and send a ACK to the other peer just to be"]
#[doc = " sure.  If the operation times out"]
#[doc = " we go to #GNUNET_TRANSPORT_PS_CONNECTED (and notify ATS that the given"]
#[doc = " alternative address is \"invalid\")."]
#[doc = ""]
#[doc = " Once a session is in #GNUNET_TRANSPORT_PS_DISCONNECT, it is cleaned up and"]
#[doc = " then goes to (#GNUNET_TRANSPORT_PS_DISCONNECT_FINISHED).  If we receive an"]
#[doc = " explicit disconnect request, we can go from any state to"]
#[doc = " #GNUNET_TRANSPORT_PS_DISCONNECT, possibly after generating disconnect"]
#[doc = " notifications."]
#[doc = ""]
#[doc = " Note that it is quite possible that while we are in any of these"]
#[doc = " states, we could receive a 'SYN' request from the other peer."]
#[doc = " We then enter a 'weird' state where we pursue our own primary state"]
#[doc = " machine (as described above), but with the 'send_connect_ack' flag"]
#[doc = " set to 1.  If our state machine allows us to send a 'SYN_ACK'"]
#[doc = " (because we have an acceptable address), we send the 'SYN_ACK'"]
#[doc = " and set the 'send_connect_ack' to 2.  If we then receive a"]
#[doc = " 'ACK', we go to #GNUNET_TRANSPORT_PS_CONNECTED (and reset 'send_connect_ack'"]
#[doc = " to 0)."]
#[doc = ""]
pub type GNUNET_TRANSPORT_PeerState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Convert a transport state to a human readable string."]
    #[doc = ""]
    #[doc = " @param state the state"]
    pub fn GNUNET_TRANSPORT_ps2s(
        state: GNUNET_TRANSPORT_PeerState,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Check if a state is defined as connected"]
    #[doc = ""]
    #[doc = " @param state the state value"]
    #[doc = " @return #GNUNET_YES or #GNUNET_NO"]
    pub fn GNUNET_TRANSPORT_is_connected(
        state: GNUNET_TRANSPORT_PeerState,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Handle for a #GNUNET_TRANSPORT_monitor_peers operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_PeerMonitoringContext {
    _unused: [u8; 0],
}
#[doc = " Function to call with information about a peer"]
#[doc = ""]
#[doc = " If one_shot was set to #GNUNET_YES to iterate over all peers once,"]
#[doc = " a final call with NULL for peer and address will follow when done."]
#[doc = " In this case state and timeout do not contain valid values."]
#[doc = ""]
#[doc = " The #GNUNET_TRANSPORT_monitor_peers_cancel() call MUST not be called from"]
#[doc = " within this function!"]
#[doc = ""]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param peer peer this update is about,"]
#[doc = "      NULL if this is the final last callback for a iteration operation"]
#[doc = " @param address address, NULL if this is the final callback for iteration op"]
#[doc = " @param state current state this peer is in"]
#[doc = " @param state_timeout timeout for the current state of the peer"]
pub type GNUNET_TRANSPORT_PeerIterateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        address: *const GNUNET_HELLO_Address,
        state: GNUNET_TRANSPORT_PeerState,
        state_timeout: GNUNET_TIME_Absolute,
    ),
>;
extern "C" {
    #[doc = " Return information about a specific peer or all peers currently known to"]
    #[doc = " transport service once or in monitoring mode. To obtain information about"]
    #[doc = " a specific peer, a peer identity can be passed. To obtain information about"]
    #[doc = " all peers currently known to transport service, NULL can be passed as peer"]
    #[doc = " identity."]
    #[doc = ""]
    #[doc = " For each peer, the callback is called with information about the address used"]
    #[doc = " to communicate with this peer, the state this peer is currently in and the"]
    #[doc = " the current timeout for this state."]
    #[doc = ""]
    #[doc = " Upon completion, the #GNUNET_TRANSPORT_PeerIterateCallback is called one"]
    #[doc = " more time with `NULL`. After this, the operation must no longer be"]
    #[doc = " explicitly canceled."]
    #[doc = ""]
    #[doc = " The #GNUNET_TRANSPORT_monitor_peers_cancel call MUST not be called in the"]
    #[doc = " the peer_callback!"]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param peer a specific peer identity to obtain information for,"]
    #[doc = "      NULL for all peers"]
    #[doc = " @param one_shot #GNUNET_YES to return the current state and then end (with"]
    #[doc = " NULL+NULL), #GNUNET_NO to monitor peers continuously"]
    #[doc = " @param peer_callback function to call with the results"]
    #[doc = " @param peer_callback_cls closure for @a peer_callback"]
    pub fn GNUNET_TRANSPORT_monitor_peers(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        peer: *const GNUNET_PeerIdentity,
        one_shot: ::std::os::raw::c_int,
        peer_callback: GNUNET_TRANSPORT_PeerIterateCallback,
        peer_callback_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_TRANSPORT_PeerMonitoringContext;
}
extern "C" {
    #[doc = " Cancel request to monitor peers"]
    #[doc = ""]
    #[doc = " @param pic handle for the request to cancel"]
    pub fn GNUNET_TRANSPORT_monitor_peers_cancel(pic: *mut GNUNET_TRANSPORT_PeerMonitoringContext);
}
#[doc = " Handle for blacklisting peers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_Blacklist {
    _unused: [u8; 0],
}
#[doc = " Function that decides if a connection is acceptable or not."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param pid peer to approve or disapproave"]
#[doc = " @return #GNUNET_OK if the connection is allowed, #GNUNET_SYSERR if not"]
pub type GNUNET_TRANSPORT_BlacklistCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        pid: *const GNUNET_PeerIdentity,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Install a blacklist callback.  The service will be queried for all"]
    #[doc = " existing connections as well as any fresh connections to check if"]
    #[doc = " they are permitted.  If the blacklisting callback is unregistered,"]
    #[doc = " all hosts that were denied in the past will automatically be"]
    #[doc = " whitelisted again.  Cancelling the blacklist handle is also the"]
    #[doc = " only way to re-enable connections from peers that were previously"]
    #[doc = " blacklisted."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param cb callback to invoke to check if connections are allowed"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return NULL on error, otherwise handle for cancellation"]
    pub fn GNUNET_TRANSPORT_blacklist(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        cb: GNUNET_TRANSPORT_BlacklistCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_TRANSPORT_Blacklist;
}
extern "C" {
    #[doc = " Abort the blacklist.  Note that this function is the only way for"]
    #[doc = " removing a peer from the blacklist."]
    #[doc = ""]
    #[doc = " @param br handle of the request that is to be cancelled"]
    pub fn GNUNET_TRANSPORT_blacklist_cancel(br: *mut GNUNET_TRANSPORT_Blacklist);
}
#[doc = " Handle for a plugin session state monitor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_PluginMonitor {
    _unused: [u8; 0],
}
#[doc = " Abstract representation of a plugin's session."]
#[doc = " Corresponds to the `struct GNUNET_ATS_Session` within the TRANSPORT service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_PluginSession {
    _unused: [u8; 0],
}
#[doc = " The session was created (first call for each session object)."]
pub const GNUNET_TRANSPORT_SessionState_GNUNET_TRANSPORT_SS_INIT: GNUNET_TRANSPORT_SessionState = 0;
#[doc = " Initial session handshake is in progress."]
pub const GNUNET_TRANSPORT_SessionState_GNUNET_TRANSPORT_SS_HANDSHAKE:
    GNUNET_TRANSPORT_SessionState = 1;
#[doc = " Session is fully UP."]
pub const GNUNET_TRANSPORT_SessionState_GNUNET_TRANSPORT_SS_UP: GNUNET_TRANSPORT_SessionState = 2;
#[doc = " This is just an update about the session,"]
#[doc = " the state did not change."]
pub const GNUNET_TRANSPORT_SessionState_GNUNET_TRANSPORT_SS_UPDATE: GNUNET_TRANSPORT_SessionState =
    3;
#[doc = " Session is being torn down and about to disappear."]
#[doc = " Last call for each session object."]
pub const GNUNET_TRANSPORT_SessionState_GNUNET_TRANSPORT_SS_DONE: GNUNET_TRANSPORT_SessionState = 4;
#[doc = " Possible states of a session in a plugin."]
pub type GNUNET_TRANSPORT_SessionState = ::std::os::raw::c_uint;
#[doc = " Information about a plugin's session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_SessionInfo {
    #[doc = " New state of the session."]
    pub state: GNUNET_TRANSPORT_SessionState,
    #[doc = " #GNUNET_YES if this is an inbound connection,"]
    #[doc = " #GNUNET_NO if this is an outbound connection,"]
    #[doc = " #GNUNET_SYSERR if connections of this plugin"]
    #[doc = "             are so fundamentally bidirectional"]
    #[doc = "             that they have no 'initiator'"]
    pub is_inbound: ::std::os::raw::c_int,
    #[doc = " Number of messages pending transmission for this session."]
    pub num_msg_pending: u32,
    #[doc = " Number of bytes pending transmission for this session."]
    pub num_bytes_pending: u32,
    #[doc = " Until when does this plugin refuse to receive to manage"]
    #[doc = " staying within the inbound quota?  ZERO if receive is"]
    #[doc = " active."]
    pub receive_delay: GNUNET_TIME_Absolute,
    #[doc = " At what time will this session timeout (unless activity"]
    #[doc = " happens)?"]
    pub session_timeout: GNUNET_TIME_Absolute,
    #[doc = " Address used by the session.  Can be NULL if none is available."]
    pub address: *const GNUNET_HELLO_Address,
}
#[test]
fn bindgen_test_layout_GNUNET_TRANSPORT_SessionInfo() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_TRANSPORT_SessionInfo>(),
        40usize,
        concat!("Size of: ", stringify!(GNUNET_TRANSPORT_SessionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_TRANSPORT_SessionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GNUNET_TRANSPORT_SessionInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).is_inbound as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(is_inbound)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).num_msg_pending as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(num_msg_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).num_bytes_pending as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(num_bytes_pending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).receive_delay as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(receive_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).session_timeout as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(session_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_TRANSPORT_SessionInfo>())).address as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_TRANSPORT_SessionInfo),
            "::",
            stringify!(address)
        )
    );
}
#[doc = " Function called by the plugin with information about the"]
#[doc = " current sessions managed by the plugin (for monitoring)."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param session session handle this information is about,"]
#[doc = "        NULL to indicate that we are \"in sync\" (initial"]
#[doc = "        iteration complete)"]
#[doc = " @param session_ctx storage location where the application"]
#[doc = "        can store data; will point to NULL on #GNUNET_TRANSPORT_SS_INIT,"]
#[doc = "        and must be reset to NULL on #GNUNET_TRANSPORT_SS_DONE"]
#[doc = " @param info information about the state of the session,"]
#[doc = "        NULL if @a session is also NULL and we are"]
#[doc = "        merely signalling that the initial iteration is over;"]
#[doc = "        NULL with @a session being non-NULL if the monitor"]
#[doc = "        was being cancelled while sessions were active"]
pub type GNUNET_TRANSPORT_SessionMonitorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        session: *mut GNUNET_TRANSPORT_PluginSession,
        session_ctx: *mut *mut ::std::os::raw::c_void,
        info: *const GNUNET_TRANSPORT_SessionInfo,
    ),
>;
extern "C" {
    #[doc = " Install a plugin session state monitor callback.  The callback"]
    #[doc = " will be notified whenever the session changes."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param cb callback to invoke on events"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return NULL on error, otherwise handle for cancellation"]
    pub fn GNUNET_TRANSPORT_monitor_plugins(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        cb: GNUNET_TRANSPORT_SessionMonitorCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_TRANSPORT_PluginMonitor;
}
extern "C" {
    #[doc = " Cancel monitoring the plugin session state.  The callback will be"]
    #[doc = " called once for each session that is up with the \"info\" argument"]
    #[doc = " being NULL (this is just to enable client-side cleanup)."]
    #[doc = ""]
    #[doc = " @param pm handle of the request that is to be cancelled"]
    pub fn GNUNET_TRANSPORT_monitor_plugins_cancel(pm: *mut GNUNET_TRANSPORT_PluginMonitor);
}
#[doc = " Opaque handle to the service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_TRANSPORT_CoreHandle {
    _unused: [u8; 0],
}
#[doc = " Function called to notify transport users that another"]
#[doc = " peer connected to us."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param peer the identity of the peer that connected; this"]
#[doc = "        pointer will remain valid until the disconnect, hence"]
#[doc = "        applications do not necessarily have to make a copy"]
#[doc = "        of the value if they only need it until disconnect"]
#[doc = " @param mq message queue to use to transmit to @a peer"]
#[doc = " @return closure to use in MQ handlers"]
pub type GNUNET_TRANSPORT_NotifyConnect = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        mq: *mut GNUNET_MQ_Handle,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Function called to notify transport users that another peer"]
#[doc = " disconnected from us.  The message queue that was given to the"]
#[doc = " connect notification will be destroyed and must not be used"]
#[doc = " henceforth."]
#[doc = ""]
#[doc = " @param cls closure from #GNUNET_TRANSPORT_core_connect"]
#[doc = " @param peer the peer that disconnected"]
#[doc = " @param handlers_cls closure of the handlers, was returned from the"]
#[doc = "                    connect notification callback"]
pub type GNUNET_TRANSPORT_NotifyDisconnect = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        handler_cls: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Function called if we have \"excess\" bandwidth to a peer."]
#[doc = " The notification will happen the first time we have excess"]
#[doc = " bandwidth, and then only again after the client has performed"]
#[doc = " some transmission to the peer."]
#[doc = ""]
#[doc = " Excess bandwidth is defined as being allowed (by ATS) to send"]
#[doc = " more data, and us reaching the limit of the capacity build-up"]
#[doc = " (which, if we go past it, means we don't use available bandwidth)."]
#[doc = " See also the \"max carry\" in `struct GNUNET_BANDWIDTH_Tracker`."]
#[doc = ""]
#[doc = " @param cls the closure"]
#[doc = " @param neighbour peer that we have excess bandwidth to"]
#[doc = " @param handlers_cls closure of the handlers, was returned from the"]
#[doc = "                    connect notification callback"]
pub type GNUNET_TRANSPORT_NotifyExcessBandwidth = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        neighbour: *const GNUNET_PeerIdentity,
        handlers_cls: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Connect to the transport service.  Note that the connection may"]
    #[doc = " complete (or fail) asynchronously."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param self our own identity (API should check that it matches"]
    #[doc = "             the identity found by transport), or NULL (no check)"]
    #[doc = " @param handlers array of message handlers; note that the"]
    #[doc = "                 closures provided will be ignored and replaced"]
    #[doc = "                 with the respective return value from @a nc"]
    #[doc = " @param handlers array with handlers to call when we receive messages, or NULL"]
    #[doc = " @param cls closure for the @a nc, @a nd and @a neb callbacks"]
    #[doc = " @param nc function to call on connect events, or NULL"]
    #[doc = " @param nd function to call on disconnect events, or NULL"]
    #[doc = " @param neb function to call if we have excess bandwidth to a peer, or NULL"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_TRANSPORT_core_connect(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        self_: *const GNUNET_PeerIdentity,
        handlers: *const GNUNET_MQ_MessageHandler,
        cls: *mut ::std::os::raw::c_void,
        nc: GNUNET_TRANSPORT_NotifyConnect,
        nd: GNUNET_TRANSPORT_NotifyDisconnect,
        neb: GNUNET_TRANSPORT_NotifyExcessBandwidth,
    ) -> *mut GNUNET_TRANSPORT_CoreHandle;
}
extern "C" {
    #[doc = " Disconnect from the transport service."]
    #[doc = ""]
    #[doc = " @param handle handle returned from connect"]
    pub fn GNUNET_TRANSPORT_core_disconnect(handle: *mut GNUNET_TRANSPORT_CoreHandle);
}
extern "C" {
    #[doc = " Checks if a given peer is connected to us and get the message queue."]
    #[doc = ""]
    #[doc = " @param handle connection to transport service"]
    #[doc = " @param peer the peer to check"]
    #[doc = " @return NULL if disconnected, otherwise message queue for @a peer"]
    pub fn GNUNET_TRANSPORT_core_get_mq(
        handle: *mut GNUNET_TRANSPORT_CoreHandle,
        peer: *const GNUNET_PeerIdentity,
    ) -> *mut GNUNET_MQ_Handle;
}
#[doc = " Message transmitted with the signed ephemeral key of a peer.  The"]
#[doc = " session key is then derived from the two ephemeral keys (ECDHE)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EphemeralKeyMessage {
    #[doc = " Message type is #GNUNET_MESSAGE_TYPE_CORE_EPHEMERAL_KEY."]
    pub header: GNUNET_MessageHeader,
    #[doc = " Status of the sender (should be in `enum PeerStateMachine`), nbo."]
    pub sender_status: i32,
    #[doc = " An ECC signature of the @e origin_identity asserting the validity"]
    #[doc = " of the given ephemeral key."]
    pub signature: GNUNET_CRYPTO_EddsaSignature,
    #[doc = " Information about what is being signed."]
    pub purpose: GNUNET_CRYPTO_EccSignaturePurpose,
    #[doc = " At what time was this key created (beginning of validity)."]
    pub creation_time: GNUNET_TIME_AbsoluteNBO,
    #[doc = " When does the given ephemeral key expire (end of validity)."]
    pub expiration_time: GNUNET_TIME_AbsoluteNBO,
    #[doc = " Ephemeral public ECC key."]
    pub ephemeral_key: GNUNET_CRYPTO_EcdhePublicKey,
    #[doc = " Public key of the signing peer (persistent version, not the"]
    #[doc = " ephemeral public key)."]
    pub origin_identity: GNUNET_PeerIdentity,
}
#[test]
fn bindgen_test_layout_EphemeralKeyMessage() {
    assert_eq!(
        ::std::mem::size_of::<EphemeralKeyMessage>(),
        160usize,
        concat!("Size of: ", stringify!(EphemeralKeyMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<EphemeralKeyMessage>(),
        1usize,
        concat!("Alignment of ", stringify!(EphemeralKeyMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EphemeralKeyMessage>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralKeyMessage>())).sender_status as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(sender_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EphemeralKeyMessage>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EphemeralKeyMessage>())).purpose as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(purpose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralKeyMessage>())).creation_time as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(creation_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralKeyMessage>())).expiration_time as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(expiration_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralKeyMessage>())).ephemeral_key as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(ephemeral_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<EphemeralKeyMessage>())).origin_identity as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(EphemeralKeyMessage),
            "::",
            stringify!(origin_identity)
        )
    );
}
#[doc = " We're sending an (encrypted) PING to the other peer to check if it"]
#[doc = " can decrypt.  The other peer should respond with a PONG with the"]
#[doc = " same content, except this time encrypted with the receiver's key."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PingMessage {
    #[doc = " Message type is #GNUNET_MESSAGE_TYPE_CORE_PING."]
    pub header: GNUNET_MessageHeader,
    #[doc = " Seed for the IV"]
    pub iv_seed: u32,
    #[doc = " Intended target of the PING, used primarily to check"]
    #[doc = " that decryption actually worked."]
    pub target: GNUNET_PeerIdentity,
    #[doc = " Random number chosen to make replay harder."]
    pub challenge: u32,
}
#[test]
fn bindgen_test_layout_PingMessage() {
    assert_eq!(
        ::std::mem::size_of::<PingMessage>(),
        44usize,
        concat!("Size of: ", stringify!(PingMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<PingMessage>(),
        1usize,
        concat!("Alignment of ", stringify!(PingMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PingMessage>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PingMessage),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PingMessage>())).iv_seed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PingMessage),
            "::",
            stringify!(iv_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PingMessage>())).target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PingMessage),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PingMessage>())).challenge as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PingMessage),
            "::",
            stringify!(challenge)
        )
    );
}
#[doc = " Response to a PING.  Includes data from the original PING."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PongMessage {
    #[doc = " Message type is #GNUNET_MESSAGE_TYPE_CORE_PONG."]
    pub header: GNUNET_MessageHeader,
    #[doc = " Seed for the IV"]
    pub iv_seed: u32,
    #[doc = " Random number to make replay attacks harder."]
    pub challenge: u32,
    #[doc = " Reserved, always zero."]
    pub reserved: u32,
    #[doc = " Intended target of the PING, used primarily to check"]
    #[doc = " that decryption actually worked."]
    pub target: GNUNET_PeerIdentity,
}
#[test]
fn bindgen_test_layout_PongMessage() {
    assert_eq!(
        ::std::mem::size_of::<PongMessage>(),
        48usize,
        concat!("Size of: ", stringify!(PongMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<PongMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(PongMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PongMessage>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PongMessage),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PongMessage>())).iv_seed as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PongMessage),
            "::",
            stringify!(iv_seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PongMessage>())).challenge as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PongMessage),
            "::",
            stringify!(challenge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PongMessage>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PongMessage),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PongMessage>())).target as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PongMessage),
            "::",
            stringify!(target)
        )
    );
}
#[doc = " Opaque handle to the service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CORE_Handle {
    _unused: [u8; 0],
}
#[doc = " Method called whenever a given peer connects."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param peer peer identity this notification is about"]
#[doc = " @return closure associated with @a peer. given to mq callbacks and"]
#[doc = "         #GNUNET_CORE_DisconnectEventHandler"]
pub type GNUNET_CORE_ConnectEventHandler = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        mq: *mut GNUNET_MQ_Handle,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Method called whenever a peer disconnects."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param peer peer identity this notification is about"]
#[doc = " @param peer_cls closure associated with peer. given in"]
#[doc = "        #GNUNET_CORE_ConnectEventHandler"]
pub type GNUNET_CORE_DisconnectEventHandler = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        peer: *const GNUNET_PeerIdentity,
        peer_cls: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Function called after #GNUNET_CORE_connect has succeeded (or failed"]
#[doc = " for good).  Note that the private key of the peer is intentionally"]
#[doc = " not exposed here; if you need it, your process should try to read"]
#[doc = " the private key file directly (which should work if you are"]
#[doc = " authorized...).  Implementations of this function must not call"]
#[doc = " #GNUNET_CORE_disconnect (other than by scheduling a new task to"]
#[doc = " do this later)."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param my_identity ID of this peer, NULL if we failed"]
pub type GNUNET_CORE_StartupCallback = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, my_identity: *const GNUNET_PeerIdentity),
>;
extern "C" {
    #[doc = " Connect to the core service.  Note that the connection may complete"]
    #[doc = " (or fail) asynchronously.  This function primarily causes the given"]
    #[doc = " callback notification functions to be invoked whenever the"]
    #[doc = " specified event happens.  The maximum number of queued"]
    #[doc = " notifications (queue length) is per client; the queue is shared"]
    #[doc = " across all types of notifications.  So a slow client that registers"]
    #[doc = " for @a outbound_notify also risks missing @a inbound_notify messages."]
    #[doc = " Certain events (such as connect/disconnect notifications) are not"]
    #[doc = " subject to queue size limitations."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param cls closure for the various callbacks that follow (including handlers in the handlers array)"]
    #[doc = " @param init callback to call once we have successfully"]
    #[doc = "        connected to the core service"]
    #[doc = " @param connects function to call on peer connect, can be NULL"]
    #[doc = " @param disconnects function to call on peer disconnect / timeout, can be NULL"]
    #[doc = " @param handlers callbacks for messages we care about, NULL-terminated"]
    #[doc = "                note that the core is allowed to drop notifications about inbound"]
    #[doc = "                messages if the client does not process them fast enough (for this"]
    #[doc = "                notification type, a bounded queue is used)"]
    #[doc = " @return handle to the core service (only useful for disconnect until @a init is called),"]
    #[doc = "           NULL on error (in this case, init is never called)"]
    pub fn GNUNET_CORE_connect(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        cls: *mut ::std::os::raw::c_void,
        init: GNUNET_CORE_StartupCallback,
        connects: GNUNET_CORE_ConnectEventHandler,
        disconnects: GNUNET_CORE_DisconnectEventHandler,
        handlers: *const GNUNET_MQ_MessageHandler,
    ) -> *mut GNUNET_CORE_Handle;
}
extern "C" {
    #[doc = " Disconnect from the core service."]
    #[doc = ""]
    #[doc = " @param handle connection to core to disconnect"]
    pub fn GNUNET_CORE_disconnect(handle: *mut GNUNET_CORE_Handle);
}
extern "C" {
    #[doc = " Obtain the message queue for a connected peer."]
    #[doc = ""]
    #[doc = " @param h the core handle"]
    #[doc = " @param pid the identity of the peer"]
    #[doc = " @return NULL if @a pid is not connected"]
    pub fn GNUNET_CORE_get_mq(
        h: *const GNUNET_CORE_Handle,
        pid: *const GNUNET_PeerIdentity,
    ) -> *mut GNUNET_MQ_Handle;
}
#[doc = " Handle to a CORE monitoring operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_CORE_MonitorHandle {
    _unused: [u8; 0],
}
#[doc = " No handshake yet."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_STATE_DOWN: GNUNET_CORE_KxState = 0;
#[doc = " We've sent our session key."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_STATE_KEY_SENT: GNUNET_CORE_KxState = 1;
#[doc = " We've received the other peers session key."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_STATE_KEY_RECEIVED: GNUNET_CORE_KxState = 2;
#[doc = " The other peer has confirmed our session key + PING with a PONG"]
#[doc = " message encrypted with their session key (which we got).  Key"]
#[doc = " exchange is done."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_STATE_UP: GNUNET_CORE_KxState = 3;
#[doc = " We're rekeying (or had a timeout), so we have sent the other peer"]
#[doc = " our new ephemeral key, but we did not get a matching PONG yet."]
#[doc = " This is equivalent to being #GNUNET_CORE_KX_STATE_KEY_RECEIVED,"]
#[doc = " except that the session is marked as 'up' with sessions (as we"]
#[doc = " don't want to drop and re-establish P2P connections simply due to"]
#[doc = " rekeying)."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_STATE_REKEY_SENT: GNUNET_CORE_KxState = 4;
#[doc = " Last state of a KX (when it is being terminated).  Set"]
#[doc = " just before CORE frees the internal state for this peer."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_PEER_DISCONNECT: GNUNET_CORE_KxState = 5;
#[doc = " This is not a state in a peer's state machine, but a special"]
#[doc = " value used with the #GNUNET_CORE_MonitorCallback to indicate"]
#[doc = " that we finished the initial iteration over the peers."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_ITERATION_FINISHED: GNUNET_CORE_KxState = 6;
#[doc = " This is not a state in a peer's state machine, but a special"]
#[doc = " value used with the #GNUNET_CORE_MonitorCallback to indicate"]
#[doc = " that we lost the connection to the CORE service (and will try"]
#[doc = " to reconnect).  If this happens, most likely the CORE service"]
#[doc = " crashed and thus all connection state should be assumed lost."]
pub const GNUNET_CORE_KxState_GNUNET_CORE_KX_CORE_DISCONNECT: GNUNET_CORE_KxState = 7;
#[doc = " State machine for our P2P encryption handshake.  Everyone starts in"]
#[doc = " #GNUNET_CORE_KX_STATE_DOWN, if we receive the other peer's key"]
#[doc = " (other peer initiated) we start in state"]
#[doc = " #GNUNET_CORE_KX_STATE_KEY_RECEIVED (since we will immediately send"]
#[doc = " our own); otherwise we start in #GNUNET_CORE_KX_STATE_KEY_SENT.  If"]
#[doc = " we get back a PONG from within either state, we move up to"]
#[doc = " #GNUNET_CORE_KX_STATE_UP (the PONG will always be sent back"]
#[doc = " encrypted with the key we sent to the other peer).  Eventually,"]
#[doc = " we will try to rekey, for this we will enter"]
#[doc = " #GNUNET_CORE_KX_STATE_REKEY_SENT until the rekey operation is"]
#[doc = " confirmed by a PONG from the other peer."]
pub type GNUNET_CORE_KxState = ::std::os::raw::c_uint;
#[doc = " Function called by the monitor callback whenever"]
#[doc = " a peer's connection status changes."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param pid identity of the peer this update is about"]
#[doc = " @param state current key exchange state of the peer"]
#[doc = " @param timeout when does the current state expire"]
pub type GNUNET_CORE_MonitorCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        pid: *const GNUNET_PeerIdentity,
        state: GNUNET_CORE_KxState,
        timeout: GNUNET_TIME_Absolute,
    ),
>;
extern "C" {
    #[doc = " Monitor connectivity and KX status of all peers known to CORE."]
    #[doc = " Calls @a peer_cb with the current status for each connected peer,"]
    #[doc = " and then once with NULL to indicate that all peers that are"]
    #[doc = " currently active have been handled.  After that, the iteration"]
    #[doc = " continues until it is cancelled.  Normal users of the CORE API are"]
    #[doc = " not expected to use this function.  It is different in that it"]
    #[doc = " truly lists all connections (including those where the KX is in"]
    #[doc = " progress), not just those relevant to the application.  This"]
    #[doc = " function is used by special applications for diagnostics."]
    #[doc = ""]
    #[doc = " @param cfg configuration handle"]
    #[doc = " @param peer_cb function to call with the peer information"]
    #[doc = " @param peer_cb_cls closure for @a peer_cb"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_CORE_monitor_start(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        peer_cb: GNUNET_CORE_MonitorCallback,
        peer_cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_CORE_MonitorHandle;
}
extern "C" {
    #[doc = " Stop monitoring CORE activity."]
    #[doc = ""]
    #[doc = " @param mh monitor to stop"]
    pub fn GNUNET_CORE_monitor_stop(mh: *mut GNUNET_CORE_MonitorHandle);
}
extern "C" {
    #[doc = " Check if the given peer is currently connected. This function is for special"]
    #[doc = " circumstances (GNUNET_TESTBED uses it), normal users of the CORE API are"]
    #[doc = " expected to track which peers are connected based on the connect/disconnect"]
    #[doc = " callbacks from #GNUNET_CORE_connect.  This function is NOT part of the"]
    #[doc = " 'versioned', 'official' API.  This function returns"]
    #[doc = " synchronously after looking in the CORE API cache."]
    #[doc = ""]
    #[doc = " @param h the core handle"]
    #[doc = " @param pid the identity of the peer to check if it has been connected to us"]
    #[doc = " @return #GNUNET_YES if the peer is connected to us; #GNUNET_NO if not"]
    pub fn GNUNET_CORE_is_peer_connected_sync(
        h: *const GNUNET_CORE_Handle,
        pid: *const GNUNET_PeerIdentity,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a message queue for sending messages to a peer with CORE."]
    #[doc = " Messages may only be queued with #GNUNET_MQ_send once the init callback has"]
    #[doc = " been called for the given handle."]
    #[doc = " There must only be one queue per peer for each core handle."]
    #[doc = " The message queue can only be used to transmit messages,"]
    #[doc = " not to receive them."]
    #[doc = ""]
    #[doc = " @param h the core handle"]
    #[doc = " @param target the target peer for this queue, may not be NULL"]
    #[doc = " @return a message queue for sending messages over the core handle"]
    #[doc = "         to the target peer"]
    pub fn GNUNET_CORE_mq_create(
        h: *mut GNUNET_CORE_Handle,
        target: *const GNUNET_PeerIdentity,
    ) -> *mut GNUNET_MQ_Handle;
}
#[doc = " The identity type. The value is the same as the"]
#[doc = " PKEY record type."]
pub const GNUNET_IDENTITY_KeyType_GNUNET_IDENTITY_TYPE_ECDSA: GNUNET_IDENTITY_KeyType = 65536;
#[doc = " EDDSA identity. The value is the same as the EDKEY"]
#[doc = " record type."]
pub const GNUNET_IDENTITY_KeyType_GNUNET_IDENTITY_TYPE_EDDSA: GNUNET_IDENTITY_KeyType = 65556;
pub type GNUNET_IDENTITY_KeyType = ::std::os::raw::c_uint;
#[doc = " Handle to access the identity service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_IDENTITY_Handle {
    _unused: [u8; 0],
}
#[doc = " Handle for a ego."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_IDENTITY_Ego {
    _unused: [u8; 0],
}
#[doc = " A private key for an identity as per LSD0001."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_IDENTITY_PrivateKey {
    #[doc = " Type of public key."]
    #[doc = " Defined by the GNS zone type value."]
    #[doc = " In NBO."]
    pub type_: u32,
    pub __bindgen_anon_1: GNUNET_IDENTITY_PrivateKey__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GNUNET_IDENTITY_PrivateKey__bindgen_ty_1 {
    #[doc = " An ECDSA identity key."]
    pub ecdsa_key: GNUNET_CRYPTO_EcdsaPrivateKey,
    #[doc = " AN EdDSA identtiy key"]
    pub eddsa_key: GNUNET_CRYPTO_EddsaPrivateKey,
    _bindgen_union_align: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_IDENTITY_PrivateKey__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_IDENTITY_PrivateKey__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_IDENTITY_PrivateKey__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_IDENTITY_PrivateKey__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_IDENTITY_PrivateKey__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_PrivateKey__bindgen_ty_1>())).ecdsa_key
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_PrivateKey__bindgen_ty_1),
            "::",
            stringify!(ecdsa_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_PrivateKey__bindgen_ty_1>())).eddsa_key
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_PrivateKey__bindgen_ty_1),
            "::",
            stringify!(eddsa_key)
        )
    );
}
#[test]
fn bindgen_test_layout_GNUNET_IDENTITY_PrivateKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_IDENTITY_PrivateKey>(),
        36usize,
        concat!("Size of: ", stringify!(GNUNET_IDENTITY_PrivateKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_IDENTITY_PrivateKey>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_IDENTITY_PrivateKey))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_PrivateKey>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_PrivateKey),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " An identity key as per LSD0001."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_IDENTITY_PublicKey {
    #[doc = " Type of public key."]
    #[doc = " Defined by the GNS zone type value."]
    #[doc = " In NBO."]
    pub type_: u32,
    pub __bindgen_anon_1: GNUNET_IDENTITY_PublicKey__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GNUNET_IDENTITY_PublicKey__bindgen_ty_1 {
    #[doc = " An ECDSA identity key."]
    pub ecdsa_key: GNUNET_CRYPTO_EcdsaPublicKey,
    #[doc = " AN EdDSA identtiy key"]
    pub eddsa_key: GNUNET_CRYPTO_EddsaPublicKey,
    _bindgen_union_align: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_GNUNET_IDENTITY_PublicKey__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_IDENTITY_PublicKey__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_IDENTITY_PublicKey__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_IDENTITY_PublicKey__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_IDENTITY_PublicKey__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_PublicKey__bindgen_ty_1>())).ecdsa_key
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_PublicKey__bindgen_ty_1),
            "::",
            stringify!(ecdsa_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_PublicKey__bindgen_ty_1>())).eddsa_key
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_PublicKey__bindgen_ty_1),
            "::",
            stringify!(eddsa_key)
        )
    );
}
#[test]
fn bindgen_test_layout_GNUNET_IDENTITY_PublicKey() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_IDENTITY_PublicKey>(),
        36usize,
        concat!("Size of: ", stringify!(GNUNET_IDENTITY_PublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_IDENTITY_PublicKey>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_IDENTITY_PublicKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_IDENTITY_PublicKey>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_PublicKey),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " An identity signature as per LSD0001."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GNUNET_IDENTITY_Signature {
    #[doc = " Type of signature."]
    #[doc = " Defined by the GNS zone type value."]
    #[doc = " In NBO."]
    pub type_: u32,
    pub __bindgen_anon_1: GNUNET_IDENTITY_Signature__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GNUNET_IDENTITY_Signature__bindgen_ty_1 {
    #[doc = " An ECDSA signature"]
    pub ecdsa_signature: GNUNET_CRYPTO_EcdsaSignature,
    #[doc = " AN EdDSA signature"]
    pub eddsa_signature: GNUNET_CRYPTO_EddsaSignature,
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_GNUNET_IDENTITY_Signature__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_IDENTITY_Signature__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(GNUNET_IDENTITY_Signature__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_IDENTITY_Signature__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(GNUNET_IDENTITY_Signature__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_Signature__bindgen_ty_1>())).ecdsa_signature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_Signature__bindgen_ty_1),
            "::",
            stringify!(ecdsa_signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GNUNET_IDENTITY_Signature__bindgen_ty_1>())).eddsa_signature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_Signature__bindgen_ty_1),
            "::",
            stringify!(eddsa_signature)
        )
    );
}
#[test]
fn bindgen_test_layout_GNUNET_IDENTITY_Signature() {
    assert_eq!(
        ::std::mem::size_of::<GNUNET_IDENTITY_Signature>(),
        68usize,
        concat!("Size of: ", stringify!(GNUNET_IDENTITY_Signature))
    );
    assert_eq!(
        ::std::mem::align_of::<GNUNET_IDENTITY_Signature>(),
        4usize,
        concat!("Alignment of ", stringify!(GNUNET_IDENTITY_Signature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GNUNET_IDENTITY_Signature>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GNUNET_IDENTITY_Signature),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " Handle for an operation with the identity service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_IDENTITY_Operation {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Obtain the ECC key associated with a ego."]
    #[doc = ""]
    #[doc = " @param ego the ego"]
    #[doc = " @return associated ECC key, valid as long as the ego is valid"]
    pub fn GNUNET_IDENTITY_ego_get_private_key(
        ego: *const GNUNET_IDENTITY_Ego,
    ) -> *const GNUNET_IDENTITY_PrivateKey;
}
extern "C" {
    #[doc = " Obtain the ego representing 'anonymous' users."]
    #[doc = ""]
    #[doc = " @return handle for the anonymous user, MUST NOT be freed"]
    pub fn GNUNET_IDENTITY_ego_get_anonymous() -> *mut GNUNET_IDENTITY_Ego;
}
extern "C" {
    #[doc = " Get the identifier (public key) of an ego."]
    #[doc = ""]
    #[doc = " @param ego identity handle with the private key"]
    #[doc = " @param pk set to ego's public key"]
    pub fn GNUNET_IDENTITY_ego_get_public_key(
        ego: *mut GNUNET_IDENTITY_Ego,
        pk: *mut GNUNET_IDENTITY_PublicKey,
    );
}
#[doc = " Method called to inform about the egos of this peer."]
#[doc = ""]
#[doc = " When used with #GNUNET_IDENTITY_connect, this function is"]
#[doc = " initially called for all egos and then again whenever a"]
#[doc = " ego's name changes or if it is deleted.  At the end of"]
#[doc = " the initial pass over all egos, the function is once called"]
#[doc = " with 'NULL' for @a ego. That does NOT mean that the callback won't"]
#[doc = " be invoked in the future or that there was an error."]
#[doc = ""]
#[doc = " When used with #GNUNET_IDENTITY_create or #GNUNET_IDENTITY_get,"]
#[doc = " this function is only called ONCE, and 'NULL' being passed in"]
#[doc = " @a ego does indicate an error (i.e. name is taken or no default"]
#[doc = " value is known).  If @a ego is non-NULL and if '*ctx'"]
#[doc = " is set in those callbacks, the value WILL be passed to a subsequent"]
#[doc = " call to the identity callback of #GNUNET_IDENTITY_connect (if"]
#[doc = " that one was not NULL)."]
#[doc = ""]
#[doc = " When an identity is renamed, this function is called with the"]
#[doc = " (known) @a ego but the NEW @a name."]
#[doc = ""]
#[doc = " When an identity is deleted, this function is called with the"]
#[doc = " (known) ego and \"NULL\" for the @a name.  In this case,"]
#[doc = " the @a ego is henceforth invalid (and the @a ctx should also be"]
#[doc = " cleaned up)."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param ego ego handle"]
#[doc = " @param ctx context for application to store data for this ego"]
#[doc = "                 (during the lifetime of this process, initially NULL)"]
#[doc = " @param name name assigned by the user for this ego,"]
#[doc = "                   NULL if the user just deleted the ego and it"]
#[doc = "                   must thus no longer be used"]
pub type GNUNET_IDENTITY_Callback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        ego: *mut GNUNET_IDENTITY_Ego,
        ctx: *mut *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Connect to the identity service."]
    #[doc = ""]
    #[doc = " @param cfg Configuration to contact the identity service."]
    #[doc = " @param cb function to call on all identity events, can be NULL"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle to communicate with identity service"]
    pub fn GNUNET_IDENTITY_connect(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        cb: GNUNET_IDENTITY_Callback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_Handle;
}
extern "C" {
    #[doc = " Obtain the ego that is currently preferred/default for a service."]
    #[doc = ""]
    #[doc = " @param id identity service to query"]
    #[doc = " @param service_name for which service is an identity wanted"]
    #[doc = " @param cb function to call with the result (will only be called once)"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_IDENTITY_get(
        id: *mut GNUNET_IDENTITY_Handle,
        service_name: *const ::std::os::raw::c_char,
        cb: GNUNET_IDENTITY_Callback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_Operation;
}
#[doc = " Function called once the requested operation has"]
#[doc = " been completed."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param emsg NULL on success, otherwise an error message"]
pub type GNUNET_IDENTITY_Continuation = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, emsg: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Set the preferred/default ego for a service."]
    #[doc = ""]
    #[doc = " @param id identity service to inform"]
    #[doc = " @param service_name for which service is an identity set"]
    #[doc = " @param ego new default identity to be set for this service"]
    #[doc = " @param cont function to call once the operation finished"]
    #[doc = " @param cont_cls closure for @a cont"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_IDENTITY_set(
        id: *mut GNUNET_IDENTITY_Handle,
        service_name: *const ::std::os::raw::c_char,
        ego: *mut GNUNET_IDENTITY_Ego,
        cont: GNUNET_IDENTITY_Continuation,
        cont_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_Operation;
}
extern "C" {
    #[doc = " Disconnect from identity service."]
    #[doc = ""]
    #[doc = " @param h identity service to disconnect"]
    pub fn GNUNET_IDENTITY_disconnect(h: *mut GNUNET_IDENTITY_Handle);
}
#[doc = " Function called once the requested operation has"]
#[doc = " been completed."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param pk private key, NULL on error"]
#[doc = " @param emsg error message, NULL on success"]
pub type GNUNET_IDENTITY_CreateContinuation = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        pk: *const GNUNET_IDENTITY_PrivateKey,
        emsg: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    #[doc = " Create a new ego with the given name."]
    #[doc = ""]
    #[doc = " @param id identity service to use"]
    #[doc = " @param name desired name"]
    #[doc = " @param privkey desired private key or NULL to create one"]
    #[doc = " @param ktype the type of key to create. Ignored if privkey != NULL."]
    #[doc = " @param cont function to call with the result (will only be called once)"]
    #[doc = " @param cont_cls closure for @a cont"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_IDENTITY_create(
        id: *mut GNUNET_IDENTITY_Handle,
        name: *const ::std::os::raw::c_char,
        privkey: *const GNUNET_IDENTITY_PrivateKey,
        ktype: GNUNET_IDENTITY_KeyType,
        cont: GNUNET_IDENTITY_CreateContinuation,
        cont_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_Operation;
}
extern "C" {
    #[doc = " Renames an existing ego."]
    #[doc = ""]
    #[doc = " @param id identity service to use"]
    #[doc = " @param old_name old name"]
    #[doc = " @param new_name desired new name"]
    #[doc = " @param cb function to call with the result (will only be called once)"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_IDENTITY_rename(
        id: *mut GNUNET_IDENTITY_Handle,
        old_name: *const ::std::os::raw::c_char,
        new_name: *const ::std::os::raw::c_char,
        cb: GNUNET_IDENTITY_Continuation,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_Operation;
}
extern "C" {
    #[doc = " Delete an existing ego."]
    #[doc = ""]
    #[doc = " @param id identity service to use"]
    #[doc = " @param name name of the identity to delete"]
    #[doc = " @param cb function to call with the result (will only be called once)"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_IDENTITY_delete(
        id: *mut GNUNET_IDENTITY_Handle,
        name: *const ::std::os::raw::c_char,
        cb: GNUNET_IDENTITY_Continuation,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_Operation;
}
extern "C" {
    #[doc = " Cancel an identity operation.  Note that the operation MAY still"]
    #[doc = " be executed; this merely cancels the continuation; if the request"]
    #[doc = " was already transmitted, the service may still choose to complete"]
    #[doc = " the operation."]
    #[doc = ""]
    #[doc = " @param op operation to cancel"]
    pub fn GNUNET_IDENTITY_cancel(op: *mut GNUNET_IDENTITY_Operation);
}
extern "C" {
    #[doc = " Get the compacted length of a #GNUNET_IDENTITY_PublicKey."]
    #[doc = " Compacted means that it returns the minimum number of bytes this"]
    #[doc = " key is long, as opposed to the union structure inside"]
    #[doc = " #GNUNET_IDENTITY_PublicKey."]
    #[doc = " Useful for compact serializations."]
    #[doc = ""]
    #[doc = " @param key the key."]
    #[doc = " @return -1 on error, else the compacted length of the key."]
    pub fn GNUNET_IDENTITY_key_get_length(key: *const GNUNET_IDENTITY_PublicKey) -> isize;
}
extern "C" {
    #[doc = " Reads a #GNUNET_IDENTITY_PublicKey from a compact buffer."]
    #[doc = " The buffer has to contain at least the compacted length of"]
    #[doc = " a #GNUNET_IDENTITY_PublicKey in bytes."]
    #[doc = " If the buffer is too small, the function returns -1 as error."]
    #[doc = " If the buffer does not contain a valid key, it returns -2 as error."]
    #[doc = ""]
    #[doc = " @param key the key"]
    #[doc = " @param buffer the buffer"]
    #[doc = " @param len the length of buffer"]
    #[doc = " @return -1 or -2 on error, else the amount of bytes read from the buffer"]
    pub fn GNUNET_IDENTITY_read_key_from_buffer(
        key: *mut GNUNET_IDENTITY_PublicKey,
        buffer: *const ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Writes a #GNUNET_IDENTITY_PublicKey to a compact buffer."]
    #[doc = " The buffer requires space for at least the compacted length of"]
    #[doc = " a #GNUNET_IDENTITY_PublicKey in bytes."]
    #[doc = " If the buffer is too small, the function returns -1 as error."]
    #[doc = " If the key is not valid, it returns -2 as error."]
    #[doc = ""]
    #[doc = " @param key the key"]
    #[doc = " @param buffer the buffer"]
    #[doc = " @param len the length of buffer"]
    #[doc = " @return -1 or -2 on error, else the amount of bytes written to the buffer"]
    pub fn GNUNET_IDENTITY_write_key_to_buffer(
        key: *const GNUNET_IDENTITY_PublicKey,
        buffer: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Get the compacted length of a #GNUNET_IDENTITY_Signature."]
    #[doc = " Compacted means that it returns the minimum number of bytes this"]
    #[doc = " signature is long, as opposed to the union structure inside"]
    #[doc = " #GNUNET_IDENTITY_Signature."]
    #[doc = " Useful for compact serializations."]
    #[doc = ""]
    #[doc = " @param sig the signature."]
    #[doc = " @return -1 on error, else the compacted length of the signature."]
    pub fn GNUNET_IDENTITY_signature_get_length(sig: *const GNUNET_IDENTITY_Signature) -> isize;
}
extern "C" {
    #[doc = " Reads a #GNUNET_IDENTITY_Signature from a compact buffer."]
    #[doc = " The buffer has to contain at least the compacted length of"]
    #[doc = " a #GNUNET_IDENTITY_Signature in bytes."]
    #[doc = " If the buffer is too small, the function returns -1 as error."]
    #[doc = " If the buffer does not contain a valid key, it returns -2 as error."]
    #[doc = ""]
    #[doc = " @param sig the signature"]
    #[doc = " @param buffer the buffer"]
    #[doc = " @param len the length of buffer"]
    #[doc = " @return -1 or -2 on error, else the amount of bytes read from the buffer"]
    pub fn GNUNET_IDENTITY_read_signature_from_buffer(
        sig: *mut GNUNET_IDENTITY_Signature,
        buffer: *const ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " Writes a #GNUNET_IDENTITY_Signature to a compact buffer."]
    #[doc = " The buffer requires space for at least the compacted length of"]
    #[doc = " a #GNUNET_IDENTITY_Signature in bytes."]
    #[doc = " If the buffer is too small, the function returns -1 as error."]
    #[doc = " If the key is not valid, it returns -2 as error."]
    #[doc = ""]
    #[doc = " @param sig the signature"]
    #[doc = " @param buffer the buffer"]
    #[doc = " @param len the length of buffer"]
    #[doc = " @return -1 or -2 on error, else the amount of bytes written to the buffer"]
    pub fn GNUNET_IDENTITY_write_signature_to_buffer(
        sig: *const GNUNET_IDENTITY_Signature,
        buffer: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> isize;
}
extern "C" {
    #[doc = " @brief Sign a given block."]
    #[doc = ""]
    #[doc = " The @a purpose data is the beginning of the data of which the signature is"]
    #[doc = " to be created. The `size` field in @a purpose must correctly indicate the"]
    #[doc = " number of bytes of the data structure, including its header. If possible,"]
    #[doc = " use #GNUNET_IDENTITY_sign() instead of this function."]
    #[doc = ""]
    #[doc = " @param priv private key to use for the signing"]
    #[doc = " @param purpose what to sign (size, purpose)"]
    #[doc = " @param[out] sig where to write the signature"]
    #[doc = " @return #GNUNET_SYSERR on error, #GNUNET_OK on success"]
    pub fn GNUNET_IDENTITY_sign_(
        priv_: *const GNUNET_IDENTITY_PrivateKey,
        purpose: *const GNUNET_CRYPTO_EccSignaturePurpose,
        sig: *mut GNUNET_IDENTITY_Signature,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verify a given signature."]
    #[doc = ""]
    #[doc = " The @a validate data is the beginning of the data of which the signature"]
    #[doc = " is to be verified. The `size` field in @a validate must correctly indicate"]
    #[doc = " the number of bytes of the data structure, including its header.  If @a"]
    #[doc = " purpose does not match the purpose given in @a validate (the latter must be"]
    #[doc = " in big endian), signature verification fails.  If possible,"]
    #[doc = " use #GNUNET_IDENTITY_signature_verify() instead of this function (only if @a validate"]
    #[doc = " is not fixed-size, you must use this function directly)."]
    #[doc = ""]
    #[doc = " @param purpose what is the purpose that the signature should have?"]
    #[doc = " @param validate block to validate (size, purpose, data)"]
    #[doc = " @param sig signature that is being validated"]
    #[doc = " @param pub public key of the signer"]
    #[doc = " @returns #GNUNET_OK if ok, #GNUNET_SYSERR if invalid"]
    pub fn GNUNET_IDENTITY_signature_verify_(
        purpose: u32,
        validate: *const GNUNET_CRYPTO_EccSignaturePurpose,
        sig: *const GNUNET_IDENTITY_Signature,
        pub_: *const GNUNET_IDENTITY_PublicKey,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encrypt a block with #GNUNET_IDENTITY_PublicKey and derives a"]
    #[doc = " #GNUNET_CRYPTO_EcdhePublicKey which is required for decryption"]
    #[doc = " using ecdh to derive a symmetric key."]
    #[doc = ""]
    #[doc = " @param block the block to encrypt"]
    #[doc = " @param size the size of the @a block"]
    #[doc = " @param pub public key to use for ecdh"]
    #[doc = " @param ecc where to write the ecc public key"]
    #[doc = " @param result the output parameter in which to store the encrypted result"]
    #[doc = "               can be the same or overlap with @c block"]
    #[doc = " @returns the size of the encrypted block, -1 for errors."]
    #[doc = "          Due to the use of CFB and therefore an effective stream cipher,"]
    #[doc = "          this size should be the same as @c len."]
    pub fn GNUNET_IDENTITY_encrypt(
        block: *const ::std::os::raw::c_void,
        size: usize,
        pub_: *const GNUNET_IDENTITY_PublicKey,
        ecc: *mut GNUNET_CRYPTO_EcdhePublicKey,
        result: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    #[doc = " Decrypt a given block with #GNUNET_IDENTITY_PrivateKey and a given"]
    #[doc = " #GNUNET_CRYPTO_EcdhePublicKey using ecdh to derive a symmetric key."]
    #[doc = ""]
    #[doc = " @param block the data to decrypt, encoded as returned by encrypt"]
    #[doc = " @param size the size of the @a block to decrypt"]
    #[doc = " @param priv private key to use for ecdh"]
    #[doc = " @param ecc the ecc public key"]
    #[doc = " @param result address to store the result at"]
    #[doc = "               can be the same or overlap with @c block"]
    #[doc = " @return -1 on failure, size of decrypted block on success."]
    #[doc = "         Due to the use of CFB and therefore an effective stream cipher,"]
    #[doc = "         this size should be the same as @c size."]
    pub fn GNUNET_IDENTITY_decrypt(
        block: *const ::std::os::raw::c_void,
        size: usize,
        priv_: *const GNUNET_IDENTITY_PrivateKey,
        ecc: *const GNUNET_CRYPTO_EcdhePublicKey,
        result: *mut ::std::os::raw::c_void,
    ) -> isize;
}
extern "C" {
    #[doc = " Creates a (Base32) string representation of the public key."]
    #[doc = " The resulting string encodes a compacted representation of the key."]
    #[doc = " See also #GNUNET_IDENTITY_key_get_length."]
    #[doc = ""]
    #[doc = " @param key the key."]
    #[doc = " @return the string representation of the key, or NULL on error."]
    pub fn GNUNET_IDENTITY_public_key_to_string(
        key: *const GNUNET_IDENTITY_PublicKey,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a (Base32) string representation of the private key."]
    #[doc = " The resulting string encodes a compacted representation of the key."]
    #[doc = " See also #GNUNET_IDENTITY_key_get_length."]
    #[doc = ""]
    #[doc = " @param key the key."]
    #[doc = " @return the string representation of the key, or NULL on error."]
    pub fn GNUNET_IDENTITY_private_key_to_string(
        key: *const GNUNET_IDENTITY_PrivateKey,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parses a (Base32) string representation of the public key."]
    #[doc = " See also #GNUNET_IDENTITY_public_key_to_string."]
    #[doc = ""]
    #[doc = " @param str the encoded key."]
    #[doc = " @param key where to write the key."]
    #[doc = " @return GNUNET_SYSERR on error."]
    pub fn GNUNET_IDENTITY_public_key_from_string(
        str_: *const ::std::os::raw::c_char,
        key: *mut GNUNET_IDENTITY_PublicKey,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Parses a (Base32) string representation of the private key."]
    #[doc = " See also #GNUNET_IDENTITY_private_key_to_string."]
    #[doc = ""]
    #[doc = " @param str the encoded key."]
    #[doc = " @param key where to write the key."]
    #[doc = " @return GNUNET_SYSERR on error."]
    pub fn GNUNET_IDENTITY_private_key_from_string(
        str_: *const ::std::os::raw::c_char,
        key: *mut GNUNET_IDENTITY_PrivateKey,
    ) -> GNUNET_GenericReturnValue;
}
extern "C" {
    #[doc = " Retrieves the public key representation of a private key."]
    #[doc = ""]
    #[doc = " @param privkey the private key."]
    #[doc = " @param key the public key result."]
    #[doc = " @return GNUNET_SYSERR on error."]
    pub fn GNUNET_IDENTITY_key_get_public(
        privkey: *const GNUNET_IDENTITY_PrivateKey,
        key: *mut GNUNET_IDENTITY_PublicKey,
    ) -> GNUNET_GenericReturnValue;
}
#[doc = " Function called with the result."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param ego NULL on error / ego not found"]
pub type GNUNET_IDENTITY_EgoCallback = ::std::option::Option<
    unsafe extern "C" fn(cls: *mut ::std::os::raw::c_void, ego: *mut GNUNET_IDENTITY_Ego),
>;
#[doc = " Handle for ego lookup."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_IDENTITY_EgoLookup {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Lookup an ego by name."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param name name to look up"]
    #[doc = " @param cb callback to invoke with the result"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return NULL on error"]
    pub fn GNUNET_IDENTITY_ego_lookup(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        name: *const ::std::os::raw::c_char,
        cb: GNUNET_IDENTITY_EgoCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_EgoLookup;
}
extern "C" {
    #[doc = " Abort ego lookup attempt."]
    #[doc = ""]
    #[doc = " @param el handle for lookup to abort"]
    pub fn GNUNET_IDENTITY_ego_lookup_cancel(el: *mut GNUNET_IDENTITY_EgoLookup);
}
#[doc = " Function called with the result."]
#[doc = ""]
#[doc = " @param cls closure"]
#[doc = " @param ego NULL on error / ego not found"]
#[doc = " @param ego_name NULL on error, name of the ego otherwise"]
pub type GNUNET_IDENTITY_EgoSuffixCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut ::std::os::raw::c_void,
        priv_: *const GNUNET_IDENTITY_PrivateKey,
        ego_name: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Handle for suffix lookup."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GNUNET_IDENTITY_EgoSuffixLookup {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Obtain the ego with the maximum suffix match between the"]
    #[doc = " ego's name and the given domain name @a suffix.  I.e., given"]
    #[doc = " a @a suffix \"a.b.c\" and egos with names \"d.a.b.c\", \"b.c\" and \"c\","]
    #[doc = " we return the ego for \"b.c\"."]
    #[doc = ""]
    #[doc = " @param cfg configuration to use"]
    #[doc = " @param suffix for which domain name suffix is an identity wanted"]
    #[doc = " @param cb function to call with the result (will only be called once)"]
    #[doc = " @param cb_cls closure for @a cb"]
    #[doc = " @return handle to abort the operation"]
    pub fn GNUNET_IDENTITY_ego_lookup_by_suffix(
        cfg: *const GNUNET_CONFIGURATION_Handle,
        suffix: *const ::std::os::raw::c_char,
        cb: GNUNET_IDENTITY_EgoSuffixCallback,
        cb_cls: *mut ::std::os::raw::c_void,
    ) -> *mut GNUNET_IDENTITY_EgoSuffixLookup;
}
extern "C" {
    #[doc = " Abort ego suffix lookup attempt."]
    #[doc = ""]
    #[doc = " @param el handle for lookup to abort"]
    pub fn GNUNET_IDENTITY_ego_lookup_by_suffix_cancel(el: *mut GNUNET_IDENTITY_EgoSuffixLookup);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_at {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ax25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_dl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_eon {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_inarp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ipx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_iso {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_ns {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_x25 {
    pub _address: u8,
}
